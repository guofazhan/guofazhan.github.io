<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> Eureka之server端集群节点发现，数据同步 · Mr.G-博客</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Eureka之server端集群节点发现，数据同步 - Mr.G"><meta name="keywords"><meta name="author" content="Mr.G"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://guofazhan.github.io/atom.xml" title="Mr.G-博客"></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about/" target="_self" data-hover="关于" class="nav-list-link">关于</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">Eureka之server端集群节点发现，数据同步</h1><div class="post-info">2018-08-23<!-- p.visit--><!--    if (is_home())--><!--        i(data-hk-page='http://bubuzou.com'+url_for(item.path)) ---><!--    else--><!--        i(data-hk-page="current") ---><!--   span 次访问--></div><div class="post-content"><blockquote>
<p>Eureka服务端支持集群部署，通过源码查看集群节点发现以及数据同步功能的实现</p>
</blockquote>
<h4 id="提供集群功能的包路径"><a href="#提供集群功能的包路径" class="headerlink" title="提供集群功能的包路径"></a>提供集群功能的包路径</h4><blockquote>
<p>com.netflix.eureka.cluster</p>
</blockquote>
<h4 id="集群节点发现以及动态更新节点功能"><a href="#集群节点发现以及动态更新节点功能" class="headerlink" title="集群节点发现以及动态更新节点功能"></a>集群节点发现以及动态更新节点功能</h4><blockquote>
<p>Eureka服务端封装了一个集群节点管理的类名称为PeerEurekaNodes 通过名称翻译出来为对等的Eureka节点集合，可以看出这个类是对eureka服务端集群节点抽象，下面通过源码查询eureka是怎么管理与发现节点信息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * eureka server 集群节点 集合类 帮助管理维护集群节点</span></span><br><span class="line"><span class="comment"> * Helper class to manage lifecycle of a collection of &#123;<span class="doctag">@link</span> PeerEurekaNode&#125;s.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Tomasz Bak</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeerEurekaNodes</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集群节点集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;PeerEurekaNode&gt; peerEurekaNodes = Collections.emptyList();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集群节点URL集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;String&gt; peerEurekaNodeUrls = Collections.emptySet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时任务线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ScheduledExecutorService taskExecutor;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过PeerEurekaNodes类属性可以看到提供了两个集合以及一个执行定时任务的线程池，其它配置属性忽略</p>
<ol>
<li>peerEurekaNodes 表示集群节点集合</li>
<li>peerEurekaNodeUrls 表示集群节点对应的URL集合</li>
<li>taskExecutor 执行定时任务的线程池<a id="more"></a>
同时 PeerEurekaNodes 类提供start 与shutdown方法，接下来主要看start方法的实现</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动方法，此方法管理集群节点间的通讯</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化定时任务线程池</span></span><br><span class="line">        taskExecutor = Executors.newSingleThreadScheduledExecutor(</span><br><span class="line">                <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                        Thread thread = <span class="keyword">new</span> Thread(r, <span class="string">"Eureka-PeerNodesUpdater"</span>);</span><br><span class="line">                        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> thread;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            updatePeerEurekaNodes(resolvePeerUrls());</span><br><span class="line">            <span class="comment">//节点更新任务线程</span></span><br><span class="line">            Runnable peersUpdateTask = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        updatePeerEurekaNodes(resolvePeerUrls());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        logger.error(<span class="string">"Cannot update the replica Nodes"</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。</span></span><br><span class="line"><span class="comment">//            如果任务的任一执行遇到异常，就会取消后续执行。否则，只能通过执行程序的取消或终止方法来终止该任务。</span></span><br><span class="line"><span class="comment">//            参数：</span></span><br><span class="line"><span class="comment">//            command - 要执行的任务</span></span><br><span class="line"><span class="comment">//            initialdelay - 首次执行的延迟时间</span></span><br><span class="line"><span class="comment">//            delay - 一次执行终止和下一次执行开始之间的延迟</span></span><br><span class="line"><span class="comment">//            unit - initialdelay 和 delay 参数的时间单位</span></span><br><span class="line">            <span class="comment">//定时执行节点更新任务线程</span></span><br><span class="line">            taskExecutor.scheduleWithFixedDelay(</span><br><span class="line">                    peersUpdateTask,</span><br><span class="line">                    serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</span><br><span class="line">                    serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</span><br><span class="line">                    TimeUnit.MILLISECONDS</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (PeerEurekaNode node : peerEurekaNodes) &#123;</span><br><span class="line">            logger.info(<span class="string">"Replica node URL:  "</span> + node.getServiceUrl());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>start 方法主要完成以下几件事</p>
<ol>
<li>初始化定时任务线程池</li>
<li>首次更新集群节点 updatePeerEurekaNodes方法</li>
<li>创建更新集群节点任务线程</li>
<li>通过定时任务线程池定时执行更新集群节点线程</li>
</ol>
</blockquote>
<blockquote>
<p>通过start 可以看出 eureka是通过一个定时线程定时去更新集群的节点信息达到对集群节点的动态发现和感知，在上面我们可以看到更新操作主要由updatePeerEurekaNodes方法完成，下面查看此方法的实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updatePeerEurekaNodes</span><span class="params">(List&lt;String&gt; newPeerUrls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newPeerUrls.isEmpty()) &#123;</span><br><span class="line">        logger.warn(<span class="string">"The replica size seems to be empty. Check the route 53 DNS Registry"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; toShutdown = <span class="keyword">new</span> HashSet&lt;&gt;(peerEurekaNodeUrls);</span><br><span class="line">    toShutdown.removeAll(newPeerUrls);</span><br><span class="line">    Set&lt;String&gt; toAdd = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</span><br><span class="line">    toAdd.removeAll(peerEurekaNodeUrls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验新的URL集合与旧有的URL集合是否一致，一致，不需要更新直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (toShutdown.isEmpty() &amp;&amp; toAdd.isEmpty()) &#123; <span class="comment">// No change</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove peers no long available</span></span><br><span class="line">    List&lt;PeerEurekaNode&gt; newNodeList = <span class="keyword">new</span> ArrayList&lt;&gt;(peerEurekaNodes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除旧集合中不可用的节点信息</span></span><br><span class="line">    <span class="keyword">if</span> (!toShutdown.isEmpty()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Removing no longer available peer nodes &#123;&#125;"</span>, toShutdown);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; newNodeList.size()) &#123;</span><br><span class="line">            PeerEurekaNode eurekaNode = newNodeList.get(i);</span><br><span class="line">            <span class="keyword">if</span> (toShutdown.contains(eurekaNode.getServiceUrl())) &#123;</span><br><span class="line">                newNodeList.remove(i);</span><br><span class="line">                eurekaNode.shutDown();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加新增加的节点信息</span></span><br><span class="line">    <span class="comment">// Add new peers</span></span><br><span class="line">    <span class="keyword">if</span> (!toAdd.isEmpty()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Adding new peer nodes &#123;&#125;"</span>, toAdd);</span><br><span class="line">        <span class="keyword">for</span> (String peerUrl : toAdd) &#123;</span><br><span class="line">            newNodeList.add(createPeerEurekaNode(peerUrl));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新赋值peerEurekaNodes与peerEurekaNodeUrls</span></span><br><span class="line">    <span class="keyword">this</span>.peerEurekaNodes = newNodeList;</span><br><span class="line">    <span class="keyword">this</span>.peerEurekaNodeUrls = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>updatePeerEurekaNodes根据传入的新集群URL集合完成节点的更新</p>
<ol>
<li>校验传入的URL集合是否需要更新</li>
<li>移除新url集合中没有的旧节点并关闭节点</li>
<li>创建旧节点集合中没有的新URL节点通过createPeerEurekaNode方法</li>
<li>重新赋值节点集合以及URL集合完成节点的更新</li>
</ol>
</blockquote>
<blockquote>
<p>updatePeerEurekaNodes传入的新URL集合是通过resolvePeerUrls方法获取，这个方法实际上是解析配置文件中的eureka.serviceUrl前缀的配置获取，并动态监听配置的更新。 创建新的节点是通过createPeerEurekaNode创建，下面查看此方法源码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据URL创建server新节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> peerEurekaNodeUrl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> PeerEurekaNode <span class="title">createPeerEurekaNode</span><span class="params">(String peerEurekaNodeUrl)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个连接远程节点的客户端</span></span><br><span class="line">    HttpReplicationClient replicationClient = JerseyReplicationClient.createReplicationClient(serverConfig, serverCodecs, peerEurekaNodeUrl);</span><br><span class="line">    <span class="comment">//获取新节点host信息</span></span><br><span class="line">    String targetHost = hostFromUrl(peerEurekaNodeUrl);</span><br><span class="line">    <span class="keyword">if</span> (targetHost == <span class="keyword">null</span>) &#123;</span><br><span class="line">        targetHost = <span class="string">"host"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建新节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PeerEurekaNode(registry, targetHost, peerEurekaNodeUrl, replicationClient, serverConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PeerEurekaNode 方法 </p>
<ol>
<li>创建远程通讯客户端replicationClient 用户与此节点间通讯，数据同步等工作</li>
<li>获取要创建的远程节点的host</li>
<li>创建一个表示远程节点实例 PeerEurekaNode</li>
</ol>
</blockquote>
<blockquote>
<p>PeerEurekaNode 表示一个与当前节点对等的远程节点，当前节点与远程节点的数据同步工作都是在此实例中完成的。</p>
</blockquote>
<h4 id="集群节点数据同步"><a href="#集群节点数据同步" class="headerlink" title="集群节点数据同步"></a>集群节点数据同步</h4><blockquote>
<p>在上面节点发现中知道eureka是通过PeerEurekaNode表示远程对等接点，并将远程通讯客户端replicationClient传入到PeerEurekaNode中，接下来通过查看PeerEurekaNode源码来看eureka集群节点间都有那些数据需要同步以及通讯内容</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* For testing */</span> PeerEurekaNode(PeerAwareInstanceRegistry registry, String targetHost, String serviceUrl,</span><br><span class="line">                                 HttpReplicationClient replicationClient, EurekaServerConfig config,</span><br><span class="line">                                 <span class="keyword">int</span> batchSize, <span class="keyword">long</span> maxBatchingDelayMs,</span><br><span class="line">                                 <span class="keyword">long</span> retrySleepTimeMs, <span class="keyword">long</span> serverUnavailableSleepTimeMs) &#123;</span><br><span class="line">    String batcherName = getBatcherName();</span><br><span class="line">    <span class="comment">//任务处理器</span></span><br><span class="line">    ReplicationTaskProcessor taskProcessor = <span class="keyword">new</span> ReplicationTaskProcessor(targetHost, replicationClient);</span><br><span class="line">    <span class="comment">//创建一个批量执行的任务调度器</span></span><br><span class="line">    <span class="keyword">this</span>.batchingDispatcher = TaskDispatchers.createBatchingTaskDispatcher(</span><br><span class="line">            batcherName,</span><br><span class="line">            config.getMaxElementsInPeerReplicationPool(),</span><br><span class="line">            batchSize,</span><br><span class="line">            config.getMaxThreadsForPeerReplication(),</span><br><span class="line">            maxBatchingDelayMs,</span><br><span class="line">            serverUnavailableSleepTimeMs,</span><br><span class="line">            retrySleepTimeMs,</span><br><span class="line">            taskProcessor</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//创建一个单任务调度器</span></span><br><span class="line">    <span class="keyword">this</span>.nonBatchingDispatcher = TaskDispatchers.createNonBatchingTaskDispatcher(</span><br><span class="line">            targetHost,</span><br><span class="line">            config.getMaxElementsInStatusReplicationPool(),</span><br><span class="line">            config.getMaxThreadsForStatusReplication(),</span><br><span class="line">            maxBatchingDelayMs,</span><br><span class="line">            serverUnavailableSleepTimeMs,</span><br><span class="line">            retrySleepTimeMs,</span><br><span class="line">            taskProcessor</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PeerEurekaNode 完成以下事件</p>
<ol>
<li>创建数据同步的任务处理器ReplicationTaskProcessor</li>
<li>创建批处理任务调度器</li>
<li>创建单任务处理调度器</li>
</ol>
</blockquote>
<blockquote>
<p><strong>说明:</strong>  eureka将节点间的数据同步工作包装成一个个细微的任务ReplicationTask ，每一个数据操作代表一个任务，将任务发送给任务调度器TaskDispatcher去异步处理。</p>
</blockquote>
<blockquote>
<p>下来查看PeerEurekaNode都可以创建那些同步任务</p>
<ul>
<li>register</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当eureka server注册新服务时，同时创建一个定时任务将新服务同步到集群其它节点</span></span><br><span class="line"><span class="comment"> * Sends the registration information of &#123;<span class="doctag">@link</span> InstanceInfo&#125; receiving by</span></span><br><span class="line"><span class="comment"> * this node to the peer node represented by this class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> info</span></span><br><span class="line"><span class="comment"> *            the instance information &#123;<span class="doctag">@link</span> InstanceInfo&#125; of any instance</span></span><br><span class="line"><span class="comment"> *            that is send to this instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info);</span><br><span class="line">    <span class="comment">//任务调度器中添加一个请求类型为注册register新服务的同步任务</span></span><br><span class="line">    batchingDispatcher.process(</span><br><span class="line">            taskId(<span class="string">"register"</span>, info),</span><br><span class="line">            <span class="keyword">new</span> InstanceReplicationTask(targetHost, Action.Register, info, <span class="keyword">null</span>, <span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> replicationClient.register(info);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            expiryTime</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注册同步任务，当有服务注册到当前节点时，通过注册同步任务将服务信息同步到集群远程节点</p>
</blockquote>
<ul>
<li>cancel</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">(<span class="keyword">final</span> String appName, <span class="keyword">final</span> String id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> expiryTime = System.currentTimeMillis() + maxProcessingDelayMs;</span><br><span class="line">     <span class="comment">//任务调度器中添加一个请求类型为取消cancel服务的同步任务</span></span><br><span class="line">     batchingDispatcher.process(</span><br><span class="line">             taskId(<span class="string">"cancel"</span>, appName, id),</span><br><span class="line">             <span class="keyword">new</span> InstanceReplicationTask(targetHost, Action.Cancel, appName, id) &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                     <span class="keyword">return</span> replicationClient.cancel(appName, id);</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleFailure</span><span class="params">(<span class="keyword">int</span> statusCode, Object responseEntity)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                     <span class="keyword">super</span>.handleFailure(statusCode, responseEntity);</span><br><span class="line">                     <span class="keyword">if</span> (statusCode == <span class="number">404</span>) &#123;</span><br><span class="line">                         logger.warn(<span class="string">"&#123;&#125;: missing entry."</span>, getTaskName());</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;,</span><br><span class="line">             expiryTime</span><br><span class="line">     );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>取消服务注册任务，当前节点有服务取消注册，将信息同步到集群远程节点</p>
<ul>
<li>heartbeat</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public void heartbeat(final String appName, final String id,</span><br><span class="line">                      final InstanceInfo info, final InstanceStatus overriddenStatus,</span><br><span class="line">                      boolean primeConnection) throws Throwable &#123;</span><br><span class="line">    //当第一次连接时直接发送心跳到远端</span><br><span class="line">    if (primeConnection) &#123;</span><br><span class="line">        // We do not care about the result for priming request.</span><br><span class="line">        replicationClient.sendHeartBeat(appName, id, info, overriddenStatus);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //心跳同步任务</span><br><span class="line">    ReplicationTask replicationTask = new InstanceReplicationTask(targetHost, Action.Heartbeat, info, overriddenStatus, false) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public EurekaHttpResponse&lt;InstanceInfo&gt; execute() throws Throwable &#123;</span><br><span class="line">            return replicationClient.sendHeartBeat(appName, id, info, overriddenStatus);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleFailure(int statusCode, Object responseEntity) throws Throwable &#123;</span><br><span class="line">            super.handleFailure(statusCode, responseEntity);</span><br><span class="line">            if (statusCode == 404) &#123;</span><br><span class="line">                logger.warn(&quot;&#123;&#125;: missing entry.&quot;, getTaskName());</span><br><span class="line">                if (info != null) &#123;</span><br><span class="line">                    logger.warn(&quot;&#123;&#125;: cannot find instance id &#123;&#125; and hence replicating the instance with status &#123;&#125;&quot;,</span><br><span class="line">                            getTaskName(), info.getId(), info.getStatus());</span><br><span class="line">                    register(info);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (config.shouldSyncWhenTimestampDiffers()) &#123;</span><br><span class="line">                InstanceInfo peerInstanceInfo = (InstanceInfo) responseEntity;</span><br><span class="line">                if (peerInstanceInfo != null) &#123;</span><br><span class="line">                    syncInstancesIfTimestampDiffers(appName, id, info, peerInstanceInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    long expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info);</span><br><span class="line">    //任务调度器中添加一个请求类型为heartbeat服务的同步任务</span><br><span class="line">    batchingDispatcher.process(taskId(&quot;heartbeat&quot;, info), replicationTask, expiryTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>心跳同步任务，当前节点有服务发送心跳续租，将信息同步到集群远程节点</p>
<ul>
<li>StatusUpdate </li>
<li>DeleteStatusOverride</li>
</ul>
</blockquote>
<h4 id="集群节点数据同步任务处理"><a href="#集群节点数据同步任务处理" class="headerlink" title="集群节点数据同步任务处理"></a>集群节点数据同步任务处理</h4><blockquote>
<p>在PeerEurekaNode的构造函数中可以看到同步任务处理由ReplicationTaskProcessor完成，下面看此类源码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 单个处理ReplicationTask任务</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ProcessingResult <span class="title">process</span><span class="params">(ReplicationTask task)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//调用任务execute方法，完成任务的执行</span></span><br><span class="line">           EurekaHttpResponse&lt;?&gt; httpResponse = task.execute();</span><br><span class="line">           <span class="keyword">int</span> statusCode = httpResponse.getStatusCode();</span><br><span class="line">           <span class="comment">//判断任务返回结果</span></span><br><span class="line">           Object entity = httpResponse.getEntity();</span><br><span class="line">           <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">               logger.debug(<span class="string">"Replication task &#123;&#125; completed with status &#123;&#125;, (includes entity &#123;&#125;)"</span>, task.getTaskName(), statusCode, entity != <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (isSuccess(statusCode)) &#123;</span><br><span class="line">               task.handleSuccess();</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusCode == <span class="number">503</span>) &#123;</span><br><span class="line">               logger.debug(<span class="string">"Server busy (503) reply for task &#123;&#125;"</span>, task.getTaskName());</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.Congestion;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               task.handleFailure(statusCode, entity);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.PermanentError;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           <span class="keyword">if</span> (isNetworkConnectException(e)) &#123;</span><br><span class="line">               logNetworkErrorSample(task, e);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.TransientError;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               logger.error(peerId + <span class="string">": "</span> + task.getTaskName() + <span class="string">"Not re-trying this exception because it does not seem to be a network exception"</span>, e);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.PermanentError;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ProcessingResult.Success;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>单任务处理 </p>
<ol>
<li>调用任务task的execute完成远程数据同步</li>
<li>分析远程返回结果</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 批量处理ReplicationTask任务</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> tasks</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ProcessingResult <span class="title">process</span><span class="params">(List&lt;ReplicationTask&gt; tasks)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//根据task集合创建ReplicationList</span></span><br><span class="line">       ReplicationList list = createReplicationListOf(tasks);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//调用批量同步接口 将同步集合发送到远端节点同步数据</span></span><br><span class="line">           EurekaHttpResponse&lt;ReplicationListResponse&gt; response = replicationClient.submitBatchUpdates(list);</span><br><span class="line">           <span class="comment">//判断同步返回结果</span></span><br><span class="line">           <span class="keyword">int</span> statusCode = response.getStatusCode();</span><br><span class="line">           <span class="keyword">if</span> (!isSuccess(statusCode)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (statusCode == <span class="number">503</span>) &#123;</span><br><span class="line">                   logger.warn(<span class="string">"Server busy (503) HTTP status code received from the peer &#123;&#125;; rescheduling tasks after delay"</span>, peerId);</span><br><span class="line">                   <span class="keyword">return</span> ProcessingResult.Congestion;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// Unexpected error returned from the server. This should ideally never happen.</span></span><br><span class="line">                   logger.error(<span class="string">"Batch update failure with HTTP status code &#123;&#125;; discarding &#123;&#125; replication tasks"</span>, statusCode, tasks.size());</span><br><span class="line">                   <span class="keyword">return</span> ProcessingResult.PermanentError;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               handleBatchResponse(tasks, response.getEntity().getResponseList());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           <span class="keyword">if</span> (isNetworkConnectException(e)) &#123;</span><br><span class="line">               logNetworkErrorSample(<span class="keyword">null</span>, e);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.TransientError;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               logger.error(<span class="string">"Not re-trying this exception because it does not seem to be a network exception"</span>, e);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.PermanentError;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ProcessingResult.Success;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>批处理任务，将一组任务一次性发送到远程进行处理</p>
<ol>
<li>根据task集合创建ReplicationList</li>
<li>调用批量同步接口将同步集合发送到远端节点同步数据 即调用rest API /{version}/peerreplication</li>
<li>分析远程返回结果</li>
</ol>
</blockquote>
<hr>
<blockquote>
<p><strong>eureka 服务端 集群节点发现，数据同步功能主要是由PeerEurekaNodes与PeerEurekaNode类实现,通过源码的跟踪可以清晰看出集群实现的逻辑，方便在实际应用中对问题的定位</strong></p>
</blockquote>
</div></article></div><div class="right-container"><div class="widget"><div class="category"><h4>分类归档</h4><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/微服务/">微服务</a><span class="category-list-count">6</span></li></ul></div></div><div class="widget"><div class="tagcloud"><h4>标签云</h4><a href="/tags/Eureka/" style="font-size: 10px;">Eureka</a> <a href="/tags/微服务/" style="font-size: 10px;">微服务</a></div></div><div class="widget"><div class="recent"><h4>最近文章</h4><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/09/04/Eureka-Server之注册服务实例租约信息管理LeaseManager/">Eureka Server之注册服务实例租约信息管理LeaseManager</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/Eureka之服务发现LookupService/">Eureka之服务发现LookupService</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/25/Eureka之远程通讯模块/">Eureka之远程通讯模块</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/23/Eureka之REST-API-1/">Eureka之REST API</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/23/Eureka之服务注册数据模型/">Eureka之服务注册数据模型</a></li></ul></div></div><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2018/08/23/Eureka之服务注册数据模型/" class="prev">上一篇</a><a href="/2018/08/23/hello-world/" class="next">下一篇</a></div><div class="copyright"><p>© 2017 - 2018 <a href="#" target="_blank">Mr.G</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p>陕ICP备16007301</p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="http://apps.bdimg.com/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="/scripts/hit-kounter-lc-0.2.0.js"></script><script src="/scripts/arAnchor.js"></script><script src="/scripts/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>