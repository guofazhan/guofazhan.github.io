{"meta":{"title":"Mr.G-博客","subtitle":"博客","description":"学习分享、源码阅读、笔记","author":"Mr.G","url":"https://guofazhan.github.io"},"pages":[{"title":"","date":"2018-08-23T11:32:07.768Z","updated":"2018-08-23T11:32:07.720Z","comments":true,"path":"about/index.html","permalink":"https://guofazhan.github.io/about/index.html","excerpt":"","text":"关于 作者：guofazhan 邮箱：guofazhan@hotmail.com"}],"posts":[{"title":"zuul之过滤器Filter管理","slug":"zuul之过滤器Filter管理","date":"2018-11-23T10:30:40.000Z","updated":"2018-11-23T02:39:08.030Z","comments":true,"path":"2018/11/23/zuul之过滤器Filter管理/","link":"","permalink":"https://guofazhan.github.io/2018/11/23/zuul之过滤器Filter管理/","excerpt":"目录 zuul之请求处理流程 zuul之动态过滤器Filter类文件管理加载 zuul之过滤器Filter管理 概述 zuul通过FilterLoader类负责filter的管理，是ZUUL的核心类之一。它编译、从文件加载，并检查源代码是否更改。它还包含按filterType的ZuulFilters。此类再如下两处使用： zuul之请求处理流程:FilterProcessor 通过FilterLoader加载给定类型的过滤器列表 zuul之动态过滤器Filter类文件管理加载:调用processGroovyFiles方法遍历filter列表通过FilterLoader类处理加载Filter","text":"目录 zuul之请求处理流程 zuul之动态过滤器Filter类文件管理加载 zuul之过滤器Filter管理 概述 zuul通过FilterLoader类负责filter的管理，是ZUUL的核心类之一。它编译、从文件加载，并检查源代码是否更改。它还包含按filterType的ZuulFilters。此类再如下两处使用： zuul之请求处理流程:FilterProcessor 通过FilterLoader加载给定类型的过滤器列表 zuul之动态过滤器Filter类文件管理加载:调用processGroovyFiles方法遍历filter列表通过FilterLoader类处理加载Filter FilterLoader 根据过滤器类型获取过滤器列表 FilterLoader 中缓存了所有过滤器的集合，可以根据过滤器的类型获取对应的过滤器列表 123456789101112131415161718192021222324public List&lt;ZuulFilter&gt; getFiltersByType(String filterType) &#123; //在缓存中获取当前类型的过滤器列表 List&lt;ZuulFilter&gt; list = hashFiltersByType.get(filterType); if (list != null) return list; list = new ArrayList&lt;ZuulFilter&gt;(); //通过filterRegistry获取所有过滤器 Collection&lt;ZuulFilter&gt; filters = filterRegistry.getAllFilters(); //遍历筛选过滤器获取给定的列表 for (Iterator&lt;ZuulFilter&gt; iterator = filters.iterator(); iterator.hasNext(); ) &#123; ZuulFilter filter = iterator.next(); if (filter.filterType().equals(filterType)) &#123; list.add(filter); &#125; &#125; //排序过滤器列表 Collections.sort(list); // sort by priority //添加到缓存中 hashFiltersByType.putIfAbsent(filterType, list); return list; &#125; getFiltersByType 在缓存中查找给定的类型列表 当前缓存为空时，通过全部过滤器列表缓存遍历组装给定类型的列表并缓存返回 通过过滤器源码加载编译过滤器并缓存 12345678910111213141516171819202122232425262728293031public boolean putFilter(File file) throws Exception &#123; // 获取类文件的全名 String sName = file.getAbsolutePath() + file.getName(); //校验类文件是否修改过，根据类文件的最后修改时间判断 if (filterClassLastModified.get(sName) != null &amp;&amp; (file.lastModified() != filterClassLastModified.get(sName))) &#123; // 类文件修改过时，删除全局缓存中当前过滤器的信息 LOG.debug(\"reloading filter \" + sName); filterRegistry.remove(sName); &#125; //在全局缓存中判断是否存在当前过滤器 ZuulFilter filter = filterRegistry.get(sName); if (filter == null) &#123; //缓存中无当前要加载的过滤器时，编译当前类文件 Class clazz = COMPILER.compile(file); if (!Modifier.isAbstract(clazz.getModifiers())) &#123; // 反射创建通过class创建过滤器对象 filter = (ZuulFilter) FILTER_FACTORY.newInstance(clazz); //缓存当前过滤器对象 List&lt;ZuulFilter&gt; list = hashFiltersByType.get(filter.filterType()); if (list != null) &#123; hashFiltersByType.remove(filter.filterType()); //rebuild this list &#125; //全局缓存当前过滤器对象 filterRegistry.put(file.getAbsolutePath() + file.getName(), filter); filterClassLastModified.put(sName, file.lastModified()); return true; &#125; &#125; return false;&#125; putFilter校验给定的类文件是否变更过，变更过，删除旧缓存信息，编译新源文件并反射创建对象缓存到系统的全局缓存中 FilterLoader主要完成了上述两个功能，一个为请求进来获取过滤器列表服务，一个为动态加载变更过滤器服务。至此 zuul的核心功能已经通过源码学习分析完毕","categories":[],"tags":[]},{"title":"zuul之动态过滤器Filter类文件管理加载","slug":"zuul之动态过滤器Filter类文件管理加载","date":"2018-11-23T10:28:10.000Z","updated":"2018-11-23T02:41:23.720Z","comments":true,"path":"2018/11/23/zuul之动态过滤器Filter类文件管理加载/","link":"","permalink":"https://guofazhan.github.io/2018/11/23/zuul之动态过滤器Filter类文件管理加载/","excerpt":"目录 zuul之请求处理流程 zuul之动态过滤器Filter类文件管理加载 zuul之过滤器Filter管理 概述 zuul 支持过滤器动态修改动态加载功能，目前支持动态Filter由Groovy编写。动态管理Groovy编写的Filter类文件变更以及动态编译等功能。","text":"目录 zuul之请求处理流程 zuul之动态过滤器Filter类文件管理加载 zuul之过滤器Filter管理 概述 zuul 支持过滤器动态修改动态加载功能，目前支持动态Filter由Groovy编写。动态管理Groovy编写的Filter类文件变更以及动态编译等功能。 实现原理 实现原理是监控存放Filter文件的目录，定期扫描这些目录，如果发现有新Filter源码文件或者Filter源码文件有改动，则对文件进行编译加载 Filter类文件动态管理 通过原理知道zuul通过定期扫描Filter文件存放的目录来校验是否有新的文件或有改动的文件，对这些文件进行加载，源码是通过FilterFileManager实现此功能的。FilterFileManager管理目录轮询的变化和新的Groovy过滤器。轮询间隔和目录在类的初始化中指定，并且轮询器将检查,更改和添加。 FilterFileManager 功能如下: 开启一个线程，开始轮询(startPoller) 每次轮询，处理目录内的所有*.groovy文件，即调用FilterLoader.getInstance().putFilter(file) 轮询部分1234567891011121314151617181920//开启轮询线程 void startPoller() &#123; //创建轮询线程 poller = new Thread(\"GroovyFilterFileManagerPoller\") &#123; public void run() &#123; while (bRunning) &#123; try &#123; //定时休眠 sleep(pollingIntervalSeconds * 1000); //扫描目录监听目录变化 manageFiles(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; poller.setDaemon(true); //开启轮询线程 poller.start(); &#125; startPoller 开启轮询线程定时调用manageFiles方法执行扫描目录，监听目录变化 startPoller方法在FilterFileManager初始化时（init）调用一次 目录扫描以及检测 1234567891011121314151617181920212223242526272829303132//目录扫描检测主入口方法void manageFiles() throws Exception, IllegalAccessException, InstantiationException &#123; // 1. 通过getFiles方法获取到目录的所有Filter文件 List&lt;File&gt; aFiles = getFiles(); //2. 通过processGroovyFiles方法处理所有Filter文件 processGroovyFiles(aFiles);&#125;//加载所有动态Filter文件List&lt;File&gt; getFiles() &#123; List&lt;File&gt; list = new ArrayList&lt;File&gt;(); //遍历配置的动态Filter文件存放目录，加载目录文件 for (String sDirectory : aDirectories) &#123; if (sDirectory != null) &#123; File directory = getDirectory(sDirectory); File[] aFiles = directory.listFiles(FILENAME_FILTER); if (aFiles != null) &#123; list.addAll(Arrays.asList(aFiles)); &#125; &#125; &#125; return list;&#125;//处理所有动态Filter文件void processGroovyFiles(List&lt;File&gt; aFiles) throws Exception, InstantiationException, IllegalAccessException &#123; //遍历动态Filter列表 for (File file : aFiles) &#123; //通过FilterLoader类来加载处理Filter FilterLoader.getInstance().putFilter(file); &#125;&#125; manageFiles方法完成两件事 调用getFiles方法加载所有预制目录中的动态Filter文件 调用processGroovyFiles方法遍历filter列表通过FilterLoader类处理加载Filter Filter类文件动态编译 zuul 动态加载filter文件，并通过编译器将文件编译成class目前zuul通过定义DynamicCodeCompiler接口以及Groovy编译的实现类GroovyCompiler来完成Groovy编写的filter的动态编译 DynamicCodeCompiler 123456789101112public interface DynamicCodeCompiler &#123; /** * 通过源码字符串以及filter 名称编译class * */ Class compile(String sCode, String sName) throws Exception; /** * * 通过源码文件编译class */ Class compile(File file) throws Exception;&#125; DynamicCodeCompiler 动态代码编译器接口定义两个方法根据不同的参数返回编译好的class GroovyCompiler 123456789101112131415161718192021222324252627282930313233343536373839404142public class GroovyCompiler implements DynamicCodeCompiler &#123; private static final Logger LOG = LoggerFactory.getLogger(GroovyCompiler.class); /** * Compiles Groovy code and returns the Class of the compiles code. * * @param sCode * @param sName * @return */ @Override public Class compile(String sCode, String sName) &#123; GroovyClassLoader loader = getGroovyClassLoader(); LOG.warn(\"Compiling filter: \" + sName); Class groovyClass = loader.parseClass(sCode, sName); return groovyClass; &#125; /** * 获取GroovyClassLoader * @return a new GroovyClassLoader */ GroovyClassLoader getGroovyClassLoader() &#123; return new GroovyClassLoader(); &#125; /** * 编译groovy class从文件中 * Compiles groovy class from a file * * @param file * @return * @throws java.io.IOException */ @Override public Class compile(File file) throws IOException &#123; GroovyClassLoader loader = getGroovyClassLoader(); Class groovyClass = loader.parseClass(file); return groovyClass; &#125;&#125; GroovyCompiler 为groovy编写的Filter的动态编译实现类。 zuul 默认支持groovy编写的Filter，这给在不停服的情况下动态变更业务规则提供了可靠的保障","categories":[],"tags":[]},{"title":"zuul之请求处理流程","slug":"zuul之请求处理流程","date":"2018-11-23T10:26:26.000Z","updated":"2018-11-23T02:39:35.137Z","comments":true,"path":"2018/11/23/zuul之请求处理流程/","link":"","permalink":"https://guofazhan.github.io/2018/11/23/zuul之请求处理流程/","excerpt":"目录 zuul之请求处理流程 zuul之动态过滤器Filter类文件管理加载 zuul之过滤器Filter管理 概述 zuul 是netflix开源的一个API Gateway 服务器, 本质上是一个web servlet应用，下面通过源码分析zuul的请求处理流程","text":"目录 zuul之请求处理流程 zuul之动态过滤器Filter类文件管理加载 zuul之过滤器Filter管理 概述 zuul 是netflix开源的一个API Gateway 服务器, 本质上是一个web servlet应用，下面通过源码分析zuul的请求处理流程 Zuul请求的生命周期 如图，该图详细描述了各种类型的过滤器的执行顺序 通过上图可以看到zuul通过拦截servlet应用http请求后进入zuul定义的过滤器链表进行处理路由； 一般我们开发web应用需要在请求进来前进行统一处理,通常有两种方式 定义一个servlet Filter来在请求进来前拦截处理，例如会话校验，请求header校验等 定义一个统一servlet，所有请求进来都走此servlet，一般mvc框架通过此方式实现，例如springMvc的DispatcherServlet zuul也不例外，zuul分别实现了这两种拦截方式: ZuulServletFilter与ZuulServlet。 ZuulServletFilter 所在包:com.netflix.zuul.filters 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class ZuulServletFilter implements Filter &#123; //zuul核心运行器 private ZuulRunner zuulRunner; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; String bufferReqsStr = filterConfig.getInitParameter(\"buffer-requests\"); boolean bufferReqs = bufferReqsStr != null &amp;&amp; bufferReqsStr.equals(\"true\") ? true : false; //创建 zuulRunner = new ZuulRunner(bufferReqs); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; try &#123; //初始化当前请求zuul的上下问环境信息 init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse); //执行前置过滤器列表 try &#123; preRouting(); &#125; catch (ZuulException e) &#123; //执行错误过滤器列表 //执行后置路由过滤器列表 error(e); postRouting(); return; &#125; //判断响应是否已经发送，发送完成时不需要执行下面路由列表流程 // Only forward onto to the chain if a zuul response is not being sent if (!RequestContext.getCurrentContext().sendZuulResponse()) &#123; filterChain.doFilter(servletRequest, servletResponse); return; &#125; //执行路由中过滤器列表 try &#123; routing(); &#125; catch (ZuulException e) &#123; //执行错误过滤器列表 //执行后置路由过滤器列表 error(e); postRouting(); return; &#125; //执行后置路由过滤器列表 try &#123; postRouting(); &#125; catch (ZuulException e) &#123; //执行错误过滤器列表 error(e); return; &#125; &#125; catch (Throwable e) &#123; //执行错误过滤器列表 error(new ZuulException(e, 500, \"UNCAUGHT_EXCEPTION_FROM_FILTER_\" + e.getClass().getName())); &#125; finally &#123; RequestContext.getCurrentContext().unset(); &#125; &#125; void postRouting() throws ZuulException &#123; //zuul核心运行器执行后置过滤器列表 zuulRunner.postRoute(); &#125; void routing() throws ZuulException &#123; zuulRunner.route(); &#125; void preRouting() throws ZuulException &#123; zuulRunner.preRoute(); &#125; void init(HttpServletRequest servletRequest, HttpServletResponse servletResponse) &#123; zuulRunner.init(servletRequest, servletResponse); &#125; void error(ZuulException e) &#123; //设置异常的上下文环境中 RequestContext.getCurrentContext().setThrowable(e); zuulRunner.error(); &#125;&#125; ZuulServlet 所在包：com.netflix.zuul.http 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class ZuulServlet extends HttpServlet &#123; private static final long serialVersionUID = -3374242278843351500L; private ZuulRunner zuulRunner; @Override public void init(ServletConfig config) throws ServletException &#123; super.init(config); String bufferReqsStr = config.getInitParameter(\"buffer-requests\"); boolean bufferReqs = bufferReqsStr != null &amp;&amp; bufferReqsStr.equals(\"true\") ? true : false; zuulRunner = new ZuulRunner(bufferReqs); &#125; @Override public void service(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse) throws ServletException, IOException &#123; try &#123; init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse); // Marks this request as having passed through the \"Zuul engine\", as opposed to servlets // explicitly bound in web.xml, for which requests will not have the same data attached RequestContext context = RequestContext.getCurrentContext(); context.setZuulEngineRan(); try &#123; preRoute(); &#125; catch (ZuulException e) &#123; error(e); postRoute(); return; &#125; try &#123; route(); &#125; catch (ZuulException e) &#123; error(e); postRoute(); return; &#125; try &#123; postRoute(); &#125; catch (ZuulException e) &#123; error(e); return; &#125; &#125; catch (Throwable e) &#123; error(new ZuulException(e, 500, \"UNHANDLED_EXCEPTION_\" + e.getClass().getName())); &#125; finally &#123; RequestContext.getCurrentContext().unset(); &#125; &#125; /** * executes \"post\" ZuulFilters * * @throws ZuulException */ void postRoute() throws ZuulException &#123; zuulRunner.postRoute(); &#125; /** * executes \"route\" filters * * @throws ZuulException */ void route() throws ZuulException &#123; zuulRunner.route(); &#125; /** * executes \"pre\" filters * * @throws ZuulException */ void preRoute() throws ZuulException &#123; zuulRunner.preRoute(); &#125; /** * initializes request * * @param servletRequest * @param servletResponse */ void init(HttpServletRequest servletRequest, HttpServletResponse servletResponse) &#123; zuulRunner.init(servletRequest, servletResponse); &#125; /** * sets error context info and executes \"error\" filters * * @param e */ void error(ZuulException e) &#123; RequestContext.getCurrentContext().setThrowable(e); zuulRunner.error(); &#125;&#125; ZuulServlet与ZuulServletFilter完成了相同的功能 初始化时创建ZuulRunner 请求进入调用ZuulRunner.init初始化当前请求的上下文环境 按规则执行zuul的过滤器列表: 正常情况 :preRoute()-&gt;route()-&gt;postRoute() preRoute异常：preRoute()-&gt;error()-&gt;postRoute() route异常：route()-&gt;error()-&gt;postRoute() postRoute异常：postRoute()-&gt;error() ZuulRunner ZuulRunner将servlet请求和响应初始化到请求上下文中，并封装过滤器处理器调用preRoute()、Router（）、postRoute（）和Error（）方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class ZuulRunner &#123; private boolean bufferRequests; /** * Creates a new &lt;code&gt;ZuulRunner&lt;/code&gt; instance. */ public ZuulRunner() &#123; this.bufferRequests = true; &#125; /** * * @param bufferRequests - whether to wrap the ServletRequest in HttpServletRequestWrapper and buffer the body. */ public ZuulRunner(boolean bufferRequests) &#123; this.bufferRequests = bufferRequests; &#125; /** * sets HttpServlet request and HttpResponse * * @param servletRequest * @param servletResponse */ public void init(HttpServletRequest servletRequest, HttpServletResponse servletResponse) &#123; RequestContext ctx = RequestContext.getCurrentContext(); if (bufferRequests) &#123; ctx.setRequest(new HttpServletRequestWrapper(servletRequest)); &#125; else &#123; ctx.setRequest(servletRequest); &#125; ctx.setResponse(new HttpServletResponseWrapper(servletResponse)); &#125; /** * executes \"post\" filterType ZuulFilters * * @throws ZuulException */ public void postRoute() throws ZuulException &#123; FilterProcessor.getInstance().postRoute(); &#125; /** * executes \"route\" filterType ZuulFilters * * @throws ZuulException */ public void route() throws ZuulException &#123; FilterProcessor.getInstance().route(); &#125; /** * executes \"pre\" filterType ZuulFilters * * @throws ZuulException */ public void preRoute() throws ZuulException &#123; FilterProcessor.getInstance().preRoute(); &#125; /** * executes \"error\" filterType ZuulFilters */ public void error() &#123; FilterProcessor.getInstance().error(); &#125;&#125; ZuulRunner 是提供给请求的核心处理类，主要完成下面事件 初始化request，response到上下问环境 将 FilterProcessor的过滤器调用暴露出去 FilterProcessor FilterProcessor是执行过滤器的核心类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206public class FilterProcessor &#123; static FilterProcessor INSTANCE = new FilterProcessor(); protected static final Logger logger = LoggerFactory.getLogger(FilterProcessor.class); private FilterUsageNotifier usageNotifier; public FilterProcessor() &#123; usageNotifier = new BasicFilterUsageNotifier(); &#125; /** * @return the singleton FilterProcessor */ public static FilterProcessor getInstance() &#123; return INSTANCE; &#125; /** * sets a singleton processor in case of a need to override default behavior * * @param processor */ public static void setProcessor(FilterProcessor processor) &#123; INSTANCE = processor; &#125; /** * Override the default filter usage notification impl. * * @param notifier */ public void setFilterUsageNotifier(FilterUsageNotifier notifier) &#123; this.usageNotifier = notifier; &#125; /** * 按顺序执行类型为post的过滤器列表（后置过滤器） * runs \"post\" filters which are called after \"route\" filters. ZuulExceptions from ZuulFilters are thrown. * Any other Throwables are caught and a ZuulException is thrown out with a 500 status code * * @throws ZuulException */ public void postRoute() throws ZuulException &#123; try &#123; runFilters(\"post\"); &#125; catch (ZuulException e) &#123; throw e; &#125; catch (Throwable e) &#123; throw new ZuulException(e, 500, \"UNCAUGHT_EXCEPTION_IN_POST_FILTER_\" + e.getClass().getName()); &#125; &#125; /** * 按顺序执行类型为error的过滤器列表（错误过滤器） * runs all \"error\" filters. These are called only if an exception occurs. Exceptions from this are swallowed and logged so as not to bubble up. */ public void error() &#123; try &#123; runFilters(\"error\"); &#125; catch (Throwable e) &#123; logger.error(e.getMessage(), e); &#125; &#125; /** * 按顺序执行类型为route的过滤器列表（路由过滤器） * Runs all \"route\" filters. These filters route calls to an origin. * * @throws ZuulException if an exception occurs. */ public void route() throws ZuulException &#123; try &#123; runFilters(\"route\"); &#125; catch (ZuulException e) &#123; throw e; &#125; catch (Throwable e) &#123; throw new ZuulException(e, 500, \"UNCAUGHT_EXCEPTION_IN_ROUTE_FILTER_\" + e.getClass().getName()); &#125; &#125; /** * 按顺序执行类型为pre的过滤器列表（前置过滤器） * runs all \"pre\" filters. These filters are run before routing to the orgin. * * @throws ZuulException */ public void preRoute() throws ZuulException &#123; try &#123; runFilters(\"pre\"); &#125; catch (ZuulException e) &#123; throw e; &#125; catch (Throwable e) &#123; throw new ZuulException(e, 500, \"UNCAUGHT_EXCEPTION_IN_PRE_FILTER_\" + e.getClass().getName()); &#125; &#125; /** * 按顺序执行给定类型的过滤器列表 * 通过FilterLoader加载所有给定类型type的过滤器 * 循环遍历过滤器列表依次执行 * runs all filters of the filterType sType/ Use this method within filters to run custom filters by type * * @param sType the filterType. * @return * @throws Throwable throws up an arbitrary exception */ public Object runFilters(String sType) throws Throwable &#123; if (RequestContext.getCurrentContext().debugRouting()) &#123; Debug.addRoutingDebug(\"Invoking &#123;\" + sType + \"&#125; type filters\"); &#125; boolean bResult = false; List&lt;ZuulFilter&gt; list = FilterLoader.getInstance().getFiltersByType(sType); if (list != null) &#123; for (int i = 0; i &lt; list.size(); i++) &#123; ZuulFilter zuulFilter = list.get(i); Object result = processZuulFilter(zuulFilter); if (result != null &amp;&amp; result instanceof Boolean) &#123; bResult |= ((Boolean) result); &#125; &#125; &#125; return bResult; &#125; /** * Processes an individual ZuulFilter. This method adds Debug information. Any uncaught Thowables are caught by this method and converted to a ZuulException with a 500 status code. * * @param filter * @return the return value for that filter * @throws ZuulException */ public Object processZuulFilter(ZuulFilter filter) throws ZuulException &#123; RequestContext ctx = RequestContext.getCurrentContext(); boolean bDebug = ctx.debugRouting(); final String metricPrefix = \"zuul.filter-\"; long execTime = 0; String filterName = \"\"; try &#123; long ltime = System.currentTimeMillis(); filterName = filter.getClass().getSimpleName(); RequestContext copy = null; Object o = null; Throwable t = null; if (bDebug) &#123; Debug.addRoutingDebug(\"Filter \" + filter.filterType() + \" \" + filter.filterOrder() + \" \" + filterName); copy = ctx.copy(); &#125; ZuulFilterResult result = filter.runFilter(); ExecutionStatus s = result.getStatus(); execTime = System.currentTimeMillis() - ltime; switch (s) &#123; case FAILED: t = result.getException(); ctx.addFilterExecutionSummary(filterName, ExecutionStatus.FAILED.name(), execTime); break; case SUCCESS: o = result.getResult(); ctx.addFilterExecutionSummary(filterName, ExecutionStatus.SUCCESS.name(), execTime); if (bDebug) &#123; Debug.addRoutingDebug(\"Filter &#123;\" + filterName + \" TYPE:\" + filter.filterType() + \" ORDER:\" + filter.filterOrder() + \"&#125; Execution time = \" + execTime + \"ms\"); Debug.compareContextState(filterName, copy); &#125; break; default: break; &#125; if (t != null) throw t; usageNotifier.notify(filter, s); return o; &#125; catch (Throwable e) &#123; if (bDebug) &#123; Debug.addRoutingDebug(\"Running Filter failed \" + filterName + \" type:\" + filter.filterType() + \" order:\" + filter.filterOrder() + \" \" + e.getMessage()); &#125; usageNotifier.notify(filter, ExecutionStatus.FAILED); if (e instanceof ZuulException) &#123; throw (ZuulException) e; &#125; else &#123; ZuulException ex = new ZuulException(e, \"Filter threw Exception\", 500, filter.filterType() + \":\" + filterName); ctx.addFilterExecutionSummary(filterName, ExecutionStatus.FAILED.name(), execTime); throw ex; &#125; &#125; &#125; /** * Publishes a counter metric for each filter on each use. */ public static class BasicFilterUsageNotifier implements FilterUsageNotifier &#123; private static final String METRIC_PREFIX = \"zuul.filter-\"; @Override public void notify(ZuulFilter filter, ExecutionStatus status) &#123; DynamicCounter.increment(METRIC_PREFIX + filter.getClass().getSimpleName(), \"status\", status.name(), \"filtertype\", filter.filterType()); &#125; &#125;&#125; FilterProcessor 通过FilterLoader加载给定类型的过滤器列表，然后按顺序依次执行过滤器，根据过滤器的类型包含如下方法： preRoute：按顺序执行类型为pre的过滤器列表（前置过滤器） route:按顺序执行类型为route的过滤器列表（路由过滤器） postRoute:按顺序执行类型为post的过滤器列表（后置过滤器） error:按顺序执行类型为error的过滤器列表（错误过滤器） 到此，zuul拦截servlet应用http请求后通过过滤器列表进行处理路由的整个流程以及代码都查看完毕，对后期我们根据业务改造还是自定义过滤器有很大的指导意义。 备注 过滤器分类： pre：前置过滤器 route：路由过滤器 post：后置过滤器 error：错误过滤器","categories":[],"tags":[]},{"title":"Hystrix之信号量隔离熔断","slug":"Hystrix之信号量隔离熔断","date":"2018-09-11T10:38:00.000Z","updated":"2018-09-11T02:39:02.585Z","comments":true,"path":"2018/09/11/Hystrix之信号量隔离熔断/","link":"","permalink":"https://guofazhan.github.io/2018/09/11/Hystrix之信号量隔离熔断/","excerpt":"Hystrix 是spring cloud默认集成的熔断组件，用于保护系统的流量过载。Hystrix支持两种方式的隔离熔断操作。线程池、信号量；下面主要通过源码学习Hystrix是怎么实现信号量的熔断隔离。","text":"Hystrix 是spring cloud默认集成的熔断组件，用于保护系统的流量过载。Hystrix支持两种方式的隔离熔断操作。线程池、信号量；下面主要通过源码学习Hystrix是怎么实现信号量的熔断隔离。 SemaphoreHystrix 信号量模型以及实现主要在com.netflix.hystrix.AbstractCommand以及其内部类中，下面看下Semaphore的模型接口以及实现 TryableSemaphore 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 信号量接口 */ /* package */static interface TryableSemaphore &#123; /** * 获取信号量，当获取到时返回true，否则返回false * Use like this: * &lt;p&gt; * * &lt;pre&gt; * if (s.tryAcquire()) &#123; * try &#123; * // do work that is protected by 's' * &#125; finally &#123; * s.release(); * &#125; * &#125; * &lt;/pre&gt; * * @return boolean */ public abstract boolean tryAcquire(); /** * 当tryAcquire获取到信号量时，使用完成后调用此方法释放信号量，使信号量计数器复原 * ONLY call release if tryAcquire returned true. * &lt;p&gt; * * &lt;pre&gt; * if (s.tryAcquire()) &#123; * try &#123; * // do work that is protected by 's' * &#125; finally &#123; * s.release(); * &#125; * &#125; * &lt;/pre&gt; */ public abstract void release(); /** * 获取当前信号的计数器的大小 * @return */ public abstract int getNumberOfPermitsUsed(); &#125; TryableSemaphore接口提供信号量的获取以及释放操作。 tryAcquire: 获取信号量，获取到时返回true，获取失败返回false release ：tryAcquire返回true时，通过此方法释放持有的信号量，复原信号量计数器 getNumberOfPermitsUsed:获取已使用的信号量数 TryableSemaphoreNoOp 1234567891011121314151617181920212223/** * 空操作信号量实现，此类调用tryAcquire永远返回true，始终可以获取信号量，不做最大信号量限制 *//* package */static class TryableSemaphoreNoOp implements TryableSemaphore &#123; public static final TryableSemaphore DEFAULT = new TryableSemaphoreNoOp(); @Override public boolean tryAcquire() &#123; return true; &#125; @Override public void release() &#123; &#125; @Override public int getNumberOfPermitsUsed() &#123; return 0; &#125;&#125; TryableSemaphoreNoOp类为不限制信号量的实现，当hystrix.command.default.execution.isolation.strategy!=SEMAPHORE是默认使用TryableSemaphoreNoOp标识，任何时候都可以通过信号量的检测。 TryableSemaphoreActual 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 信号量，仅支持tryAcquire，无阻塞功能，信号量大小可动态配置 * Semaphore that only supports tryAcquire and never blocks and that supports a dynamic permit count. * &lt;p&gt; * Using AtomicInteger increment/decrement instead of java.util.concurrent.Semaphore since we don't need blocking and need a custom implementation to get the dynamic permit count and since * AtomicInteger achieves the same behavior and performance without the more complex implementation of the actual Semaphore class using AbstractQueueSynchronizer. */ /* package */static class TryableSemaphoreActual implements TryableSemaphore &#123; /** * 许可通过的最大信号量数值，可在配置中配置 */ protected final HystrixProperty&lt;Integer&gt; numberOfPermits; /** * 信号量计数器，线程安全 */ private final AtomicInteger count = new AtomicInteger(0); public TryableSemaphoreActual(HystrixProperty&lt;Integer&gt; numberOfPermits) &#123; this.numberOfPermits = numberOfPermits; &#125; @Override public boolean tryAcquire() &#123; //信号量加一并返回新的总数 int currentCount = count.incrementAndGet(); //对比计数总数与最大许可的数值 if (currentCount &gt; numberOfPermits.get()) &#123; //计数总数大于最大许可，返回false，标识无信号量可用 //信号量减一，复原计数器 count.decrementAndGet(); return false; &#125; else &#123; return true; &#125; &#125; /** * 释放持有的信号量 */ @Override public void release() &#123; //信号量减一 count.decrementAndGet(); &#125; /** * 获取信号量已使用的值 * @return */ @Override public int getNumberOfPermitsUsed() &#123; return count.get(); &#125; &#125; TryableSemaphoreActual类最大信号量可配置，通过hystrix.command.default.fallback.isolation.semaphore.maxConcurrentRequests配置。 tryAcquire： 对已使用的信号量+1；比较计数器与最大许可，判断是否有可用的信号量，有返回true，无返回false； Semaphore实例创建 AbstractCommand 方法中缓存有信号量map如下: 123/* each circuit has a semaphore to restrict concurrent fallback execution */ protected static final ConcurrentHashMap&lt;String, TryableSemaphore&gt; fallbackSemaphorePerCircuit = new ConcurrentHashMap&lt;String, TryableSemaphore&gt;(); /* END FALLBACK Semaphore */ 查询command命令的Semaphore实例根据commandkey 123456789101112131415161718192021222324protected TryableSemaphore getExecutionSemaphore() &#123; //校验是否配置以信号量隔离 if (properties.executionIsolationStrategy().get() == ExecutionIsolationStrategy.SEMAPHORE) &#123; if (executionSemaphoreOverride == null) &#123; //缓存中获取当前命令的信号量信息 TryableSemaphore _s = executionSemaphorePerCircuit.get(commandKey.name()); if (_s == null) &#123; // 创建当前命令的信号量实例，并保存在缓存中 // we didn't find one cache so setup executionSemaphorePerCircuit.putIfAbsent(commandKey.name(), new TryableSemaphoreActual(properties.executionIsolationSemaphoreMaxConcurrentRequests())); // assign whatever got set (this or another thread) return executionSemaphorePerCircuit.get(commandKey.name()); &#125; else &#123; return _s; &#125; &#125; else &#123; return executionSemaphoreOverride; &#125; &#125; else &#123; //返回空实现 // return NoOp implementation since we're not using SEMAPHORE isolation return TryableSemaphoreNoOp.DEFAULT; &#125;&#125; Semaphore在command中使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private Observable&lt;R&gt; applyHystrixSemantics(final AbstractCommand&lt;R&gt; _cmd) &#123; // mark that we're starting execution on the ExecutionHook // if this hook throws an exception, then a fast-fail occurs with no fallback. No state is left inconsistent executionHook.onStart(_cmd); /* determine if we're allowed to execute */ if (circuitBreaker.attemptExecution()) &#123; //获取当前命令的信号量信息 final TryableSemaphore executionSemaphore = getExecutionSemaphore(); //信号量是否需要释放标识 final AtomicBoolean semaphoreHasBeenReleased = new AtomicBoolean(false); //信号量释放action final Action0 singleSemaphoreRelease = new Action0() &#123; @Override public void call() &#123; if (semaphoreHasBeenReleased.compareAndSet(false, true)) &#123; executionSemaphore.release(); &#125; &#125; &#125;; final Action1&lt;Throwable&gt; markExceptionThrown = new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable t) &#123; eventNotifier.markEvent(HystrixEventType.EXCEPTION_THROWN, commandKey); &#125; &#125;; //信号量获取 if (executionSemaphore.tryAcquire()) &#123; //获取成功，执行命令具体操作，并将信号量释放action添加到流式操作中 try &#123; /* used to track userThreadExecutionTime */ executionResult = executionResult.setInvocationStartTime(System.currentTimeMillis()); return executeCommandAndObserve(_cmd) .doOnError(markExceptionThrown) .doOnTerminate(singleSemaphoreRelease) .doOnUnsubscribe(singleSemaphoreRelease); &#125; catch (RuntimeException e) &#123; return Observable.error(e); &#125; &#125; else &#123; //获取失败熔断进入Fallback return handleSemaphoreRejectionViaFallback(); &#125; &#125; else &#123; return handleShortCircuitViaFallback(); &#125; &#125; applyHystrixSemantics 核心流程： 获取TryableSemaphore 调用TryableSemaphore.tryAcquire() 调用TryableSemaphore.release() Hystrix使用了rxJava响应式编码，所以这里的代码组织结构有点难以理解，弄懂rxJava的原理，其实也是很好看懂的。","categories":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"Hystrix","slug":"Hystrix","permalink":"https://guofazhan.github.io/tags/Hystrix/"}]},{"title":"Spring-Cloud-Gateway之配置路由过滤器","slug":"Spring-Cloud-Gateway之配置路由过滤器","date":"2018-09-03T17:01:00.000Z","updated":"2018-09-03T09:02:17.831Z","comments":true,"path":"2018/09/04/Spring-Cloud-Gateway之配置路由过滤器/","link":"","permalink":"https://guofazhan.github.io/2018/09/04/Spring-Cloud-Gateway之配置路由过滤器/","excerpt":"","text":"上篇我们阅读了过滤器整个结构以及加载使用流程，接下来我们阅读下Spring-Cloud-Gateway对配置中的过滤器创建流程。 加载GatewayFilter 在路由定位器中以及看到了通过路由定义转换路由方法，其中包含了通过过滤器定义(FilterDefinition)转换过滤器(GatewayFilter)的部分,在RouteDefinitionRouteLocator类中源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * 加载过滤器，根据过滤器的定义加载 * @param id * @param filterDefinitions * @return */@SuppressWarnings(&quot;unchecked&quot;)private List&lt;GatewayFilter&gt; loadGatewayFilters(String id, List&lt;FilterDefinition&gt; filterDefinitions) &#123; //遍历过滤器定义，将过滤器定义转换成对应的过滤器 List&lt;GatewayFilter&gt; filters = filterDefinitions.stream() .map(definition -&gt; &#123; //通过过滤器定义名称获取过滤器创建工厂 GatewayFilterFactory factory = this.gatewayFilterFactories.get(definition.getName()); if (factory == null) &#123; throw new IllegalArgumentException(&quot;Unable to find GatewayFilterFactory with name &quot; + definition.getName()); &#125; //获取参数 Map&lt;String, String&gt; args = definition.getArgs(); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;RouteDefinition &quot; + id + &quot; applying filter &quot; + args + &quot; to &quot; + definition.getName()); &#125; //根据args组装配置信息 Map&lt;String, Object&gt; properties = factory.shortcutType().normalize(args, factory, this.parser, this.beanFactory); //构建过滤器创建配置信息 Object configuration = factory.newConfig(); ConfigurationUtils.bind(configuration, properties, factory.shortcutFieldPrefix(), definition.getName(), validator); //通过过滤器工厂创建GatewayFilter GatewayFilter gatewayFilter = factory.apply(configuration); if (this.publisher != null) &#123; //发布事件 this.publisher.publishEvent(new FilterArgsEvent(this, id, properties)); &#125; return gatewayFilter; &#125;) .collect(Collectors.toList()); ArrayList&lt;GatewayFilter&gt; ordered = new ArrayList&lt;&gt;(filters.size()); //包装过滤器使其所有过滤器继承Ordered属性，可进行排序 for (int i = 0; i &lt; filters.size(); i++) &#123; GatewayFilter gatewayFilter = filters.get(i); if (gatewayFilter instanceof Ordered) &#123; ordered.add(gatewayFilter); &#125; else &#123; ordered.add(new OrderedGatewayFilter(gatewayFilter, i + 1)); &#125; &#125; return ordered;&#125;/** * 获取RouteDefinition中的过滤器集合 * @param routeDefinition * @return */private List&lt;GatewayFilter&gt; getFilters(RouteDefinition routeDefinition) &#123; List&lt;GatewayFilter&gt; filters = new ArrayList&lt;&gt;(); //校验gatewayProperties是否含义默认的过滤器集合 //TODO: support option to apply defaults after route specific filters? if (!this.gatewayProperties.getDefaultFilters().isEmpty()) &#123; //加载全局配置的默认过滤器集合 filters.addAll(loadGatewayFilters(&quot;defaultFilters&quot;, this.gatewayProperties.getDefaultFilters())); &#125; if (!routeDefinition.getFilters().isEmpty()) &#123; //加载路由定义中的过滤器集合 filters.addAll(loadGatewayFilters(routeDefinition.getId(), routeDefinition.getFilters())); &#125; //排序 AnnotationAwareOrderComparator.sort(filters); return filters;&#125; getFilters方法 合并配置中的全局过滤器与路由自身配置的过滤器，并对其排序（全局配置过滤器信息通过gatewayProperties.getDefaultFilters()获取） loadGatewayFilters 依次遍历路由定义下的FilterDefinition并将其通过对应的GatewayFilterFactory转换为GatewayFilter对象。 GatewayFilterFactory配置过滤器创建工厂创建GatewayFilter对象 Spring-Cloud-Gateway默认内置很多GatewayFilterFactory实现类，用于创建作用不同的网关过滤器，下面通过图展示各个工厂类创建的过滤器的作用。 AddResponseHeaderGatewayFilterFactory 创建解析 123456789101112131415161718/** * * 响应header添加数据过滤器 * 用户在response header中添加配置数据 * @author Spencer Gibb */public class AddResponseHeaderGatewayFilterFactory extends AbstractNameValueGatewayFilterFactory &#123; @Override public GatewayFilter apply(NameValueConfig config) &#123; return (exchange, chain) -&gt; &#123; //获取Response并将配置的数据添加到header中 exchange.getResponse().getHeaders().add(config.getName(), config.getValue()); return chain.filter(exchange); &#125;; &#125;&#125; 配置样例： 12345spring: cloud: gateway: default-filters: - AddResponseHeader=X-Response-Default-Foo, Default-Bar AddResponseHeader=X-Response-Default-Foo, Default-Bar 会被解析成FilterDefinition对象 （name =AddResponseHeader ，args= [X-Response-Default-Foo,Default-Bar]） 通FilterDefinition的Name找到AddResponseHeaderGatewayFilterFactory工厂 通过FilterDefinition 的args 创建Config对象（name=X-Response-Default-Foo,value=Default-Bar） 通过 AddResponseHeaderGatewayFilterFactory工厂的apply方法传入config创建GatewayFilter对象。","categories":[{"name":"Spring-Cloud-Gateway","slug":"Spring-Cloud-Gateway","permalink":"https://guofazhan.github.io/categories/Spring-Cloud-Gateway/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"网关","slug":"网关","permalink":"https://guofazhan.github.io/tags/网关/"}]},{"title":"Spring-Cloud-Gateway之RoutePredicate","slug":"Spring-Cloud-Gateway之RoutePredicate","date":"2018-09-03T16:57:00.000Z","updated":"2018-09-03T08:59:09.480Z","comments":true,"path":"2018/09/04/Spring-Cloud-Gateway之RoutePredicate/","link":"","permalink":"https://guofazhan.github.io/2018/09/04/Spring-Cloud-Gateway之RoutePredicate/","excerpt":"Spring-Cloud-Gateway路由选择是通过Predicate函数式接口进行判断当前路由是否满足给定条件。下来阅读Spring-Cloud-Gateway路由的Predicate构建流程以及选择路由的源码","text":"Spring-Cloud-Gateway路由选择是通过Predicate函数式接口进行判断当前路由是否满足给定条件。下来阅读Spring-Cloud-Gateway路由的Predicate构建流程以及选择路由的源码 首先看下JDK8中Predicate接口定义 Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。可以用于接口请求参数校验、判断新老数据是否有变化需要进行更新操作。add–与、or–或、negate–非 boolean test(T t); 判断 Predicate and(Predicate&lt;? super T&gt; other) 接收一个Predicate类型，也就是将传入的条件和当前条件以并且(AND)的关系组合 Predicate or(Predicate&lt;? super T&gt; other)接收一个Predicate类型，也就是将传入的条件和当前条件以或(OR)的关系组合 加载路由中的Predicate 在路由定位器中以及看到了通过路由定义转换路由方法，其中包含了通过谓语定义(PredicateDefinition)转换谓语(Predicate)的部分,在RouteDefinitionRouteLocator类中源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 返回组合的谓词 * @param routeDefinition * @return */private Predicate&lt;ServerWebExchange&gt; combinePredicates(RouteDefinition routeDefinition) &#123; //获取RouteDefinition中的PredicateDefinition集合 List&lt;PredicateDefinition&gt; predicates = routeDefinition.getPredicates(); Predicate&lt;ServerWebExchange&gt; predicate = lookup(routeDefinition, predicates.get(0)); for (PredicateDefinition andPredicate : predicates.subList(1, predicates.size())) &#123; Predicate&lt;ServerWebExchange&gt; found = lookup(routeDefinition, andPredicate); //返回一个组合的谓词，表示该谓词与另一个谓词的短路逻辑AND predicate = predicate.and(found); &#125; return predicate;&#125; /** * 获取一个谓语定义（PredicateDefinition）转换的谓语 * @param route * @param predicate * @return */@SuppressWarnings(\"unchecked\")private Predicate&lt;ServerWebExchange&gt; lookup(RouteDefinition route, PredicateDefinition predicate) &#123; //获取谓语创建工厂 RoutePredicateFactory&lt;Object&gt; factory = this.predicates.get(predicate.getName()); if (factory == null) &#123; throw new IllegalArgumentException(\"Unable to find RoutePredicateFactory with name \" + predicate.getName()); &#125; //获取参数 Map&lt;String, String&gt; args = predicate.getArgs(); if (logger.isDebugEnabled()) &#123; logger.debug(\"RouteDefinition \" + route.getId() + \" applying \" + args + \" to \" + predicate.getName()); &#125; //组装参数 Map&lt;String, Object&gt; properties = factory.shortcutType().normalize(args, factory, this.parser, this.beanFactory); //构建创建谓语的配置信息 Object config = factory.newConfig(); ConfigurationUtils.bind(config, properties, factory.shortcutFieldPrefix(), predicate.getName(), validator); if (this.publisher != null) &#123; this.publisher.publishEvent(new PredicateArgsEvent(this, route.getId(), properties)); &#125; //通过谓语工厂构建谓语 return factory.apply(config);&#125; 获取路由定义（routeDefinition）所有的谓语定位（PredicateDefinition） 以此根据谓语定义（PredicateDefinition）查找谓语对于的创建工厂（RoutePredicateFactory） 创建谓语 通过 Predicate接口 and方法合并谓语集合返回一个新的复合谓语 使用路由Predicate判断路由是否可用 在Spring-Cloud-Gateway之请求处理流程里我们已经了解在handlerMapping中通过路由定位器获取所有路由，并过滤掉谓语判断失败的路由，最终获取满足条件的路由，下面再看下过滤的具体逻辑。 123456789protected Mono&lt;Route&gt; lookupRoute(ServerWebExchange exchange) &#123; //通过路由定位器获取路由信息 return this.routeLocator.getRoutes() .filter(route -&gt; &#123; exchange.getAttributes().put(GATEWAY_PREDICATE_ROUTE_ATTR, route.getId()); //返回通过谓语过滤的路由信息 return route.getPredicate().test(exchange); &#125;) &#125; 通过routeLocator的getRoutes方法获取所有路由 在所有路由中通过filter方法匹配Predicate.test匹配的路由信息 通过上面1，2两步我们看到了整个路由的条件创建以及使用的地方以及流程，Spring-Cloud-Gateway通过Predicate接口完成简单条件组合以及判断。 接下来看通过RoutePredicateFactory创建PredicateSpring-Cloud-Gateway预制了很多RoutePredicateFactory使其可以通过简单的配置就可以创建出理想的Predicate RoutePredicateFactory类图如下：RoutePredicateFactory子类功能分类图： MethodRoutePredicateFactory 1234567891011121314151617181920212223242526272829303132/** * 请求方式（GET,POST,DEL,PUT）校验匹配创建工厂 * @author Spencer Gibb */public class MethodRoutePredicateFactory extends AbstractRoutePredicateFactory&lt;MethodRoutePredicateFactory.Config&gt; &#123; public static final String METHOD_KEY = \"method\"; @Override public Predicate&lt;ServerWebExchange&gt; apply(Config config) &#123; return exchange -&gt; &#123; //获取当前请求的HttpMethod HttpMethod requestMethod = exchange.getRequest().getMethod(); //校验请求HttpMethod与配置是否一致 return requestMethod == config.getMethod(); &#125;; &#125; public static class Config &#123; /** * http 请求Method */ private HttpMethod method; public HttpMethod getMethod() &#123; return method; &#125; public void setMethod(HttpMethod method) &#123; this.method = method; &#125; &#125;&#125; 配置列子 123456789spring: cloud: gateway: routes: # ===================================== - id: method_route uri: http://example.org predicates: - Method=GET Method=GET 会被解析成PredicateDefinition对象 （name =Method ，args= GET） 通过PredicateDefinition的Name找到MethodRoutePredicateFactory工厂 通过 PredicateDefinition 的args 创建Config对象（HttpMethod=GET） 通过 MethodRoutePredicateFactory工厂的apply方法传入config创建Predicate对象。 在此只对MethodRoutePredicateFactory做了描述和说明，其它的谓语工程基本与此一致。此时Spring-Cloud-Gateway的RoutePredicate所有逻辑代码都已经阅读完毕，对阅读过程做文档记录以便加深印象，后期翻阅","categories":[{"name":"Spring-Cloud-Gateway","slug":"Spring-Cloud-Gateway","permalink":"https://guofazhan.github.io/categories/Spring-Cloud-Gateway/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"网关","slug":"网关","permalink":"https://guofazhan.github.io/tags/网关/"}]},{"title":"Spring-Cloud-Gateway初始化","slug":"Spring-Cloud-Gateway初始化","date":"2018-09-03T16:49:00.000Z","updated":"2018-09-03T08:51:28.362Z","comments":true,"path":"2018/09/04/Spring-Cloud-Gateway初始化/","link":"","permalink":"https://guofazhan.github.io/2018/09/04/Spring-Cloud-Gateway初始化/","excerpt":"Spring-Cloud项目使用EnableAutoConfiguration注解自动初始化配置信息，Spring-Cloud-Gateway同样，Spring-Cloud-Gateway下的spring.factories如下: 123456789101112# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\//依赖包的校验配置org.springframework.cloud.gateway.config.GatewayClassPathWarningAutoConfiguration,\\//网关的核心配置org.springframework.cloud.gateway.config.GatewayAutoConfiguration,\\//负载均衡相关依赖配置信息org.springframework.cloud.gateway.config.GatewayLoadBalancerClientAutoConfiguration,\\//流控的依赖配置信息org.springframework.cloud.gateway.config.GatewayRedisAutoConfiguration,\\//注册中心相关的依赖配置org.springframework.cloud.gateway.discovery.GatewayDiscoveryClientAutoConfiguration","text":"Spring-Cloud项目使用EnableAutoConfiguration注解自动初始化配置信息，Spring-Cloud-Gateway同样，Spring-Cloud-Gateway下的spring.factories如下: 123456789101112# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\//依赖包的校验配置org.springframework.cloud.gateway.config.GatewayClassPathWarningAutoConfiguration,\\//网关的核心配置org.springframework.cloud.gateway.config.GatewayAutoConfiguration,\\//负载均衡相关依赖配置信息org.springframework.cloud.gateway.config.GatewayLoadBalancerClientAutoConfiguration,\\//流控的依赖配置信息org.springframework.cloud.gateway.config.GatewayRedisAutoConfiguration,\\//注册中心相关的依赖配置org.springframework.cloud.gateway.discovery.GatewayDiscoveryClientAutoConfiguration 析配置功能 分析配置功能前先了解下springboot常用的注解的含义 1234执行顺序@AutoConfigureAfter：在指定的配置类初始化后再加载@AutoConfigureBefore：在指定的配置类初始化前加载@AutoConfigureOrder：数越小越先初始化 12345678910111213条件配置@ConditionalOnClass ： classpath中存在该类时起效@ConditionalOnMissingClass ： classpath中不存在该类时起效@ConditionalOnBean ： DI容器中存在该类型Bean时起效@ConditionalOnMissingBean ： DI容器中不存在该类型Bean时起效@ConditionalOnSingleCandidate ： DI容器中该类型Bean只有一个或@Primary的只有一个时起效@ConditionalOnExpression ： SpEL表达式结果为true时@ConditionalOnProperty ： 参数设置或者值一致时起效@ConditionalOnResource ： 指定的文件存在时起效@ConditionalOnJndi ： 指定的JNDI存在时起效@ConditionalOnJava ： 指定的Java版本存在时起效@ConditionalOnWebApplication ： Web应用环境下起效@ConditionalOnNotWebApplication ： 非Web应用环境下起效 GatewayClassPathWarningAutoConfiguration配置 GatewayClassPathWarningAutoConfiguration配置用于检查项目是否正确导入 spring-boot-starter-webflux 依赖，而不是错误导入 spring-boot-starter-web 依赖，同时 GatewayClassPathWarningAutoConfiguration配置在EnableAutoConfiguration配置加载前加载接下来我看代码如何实现 12345678910111213141516171819202122232425262728293031@Configuration//执行顺序注解//当前注解标识需要在GatewayAutoConfiguration前加载此配置@AutoConfigureBefore(GatewayAutoConfiguration.class)public class GatewayClassPathWarningAutoConfiguration &#123; @Configuration //条件判断注解 //classpath中存在org.springframework.web.servlet.DispatcherServlet时起效，标识项目导入了spring-boot-starter-web包 @ConditionalOnClass(name = &quot;org.springframework.web.servlet.DispatcherServlet&quot;) protected static class SpringMvcFoundOnClasspathConfiguration &#123; public SpringMvcFoundOnClasspathConfiguration() &#123; //当前项目导入了spring-boot-starter-web依赖时，打印警告日志 log.warn(BORDER+&quot;Spring MVC found on classpath, which is incompatible with Spring Cloud Gateway at this time. &quot;+ &quot;Please remove spring-boot-starter-web dependency.&quot;+BORDER); &#125; &#125; @Configuration //条件判断注解 //classpath中不存在org.springframework.web.reactive.DispatcherHandler时起效，标识项目未导入了spring-boot-starter-webflux包 @ConditionalOnMissingClass(&quot;org.springframework.web.reactive.DispatcherHandler&quot;) protected static class WebfluxMissingFromClasspathConfiguration &#123; public WebfluxMissingFromClasspathConfiguration() &#123; //当前项目未导入了boot-starter-webflux依赖时，打印警告日志 log.warn(BORDER+&quot;Spring Webflux is missing from the classpath, which is required for Spring Cloud Gateway at this time. &quot;+ &quot;Please add spring-boot-starter-webflux dependency.&quot;+BORDER); &#125; &#125;&#125; GatewayLoadBalancerClientAutoConfiguration GatewayLoadBalancerClientAutoConfiguration配置作用是初始化 LoadBalancerClientFilter 路由的负载均衡拦截器 12345678910111213141516@Configuration//条件判断注解//classpath中存在LoadBalancerClient和RibbonAutoConfiguration和DispatcherHandler时此配置起效@ConditionalOnClass(&#123;LoadBalancerClient.class, RibbonAutoConfiguration.class, DispatcherHandler.class&#125;)//执行顺序注解@AutoConfigureAfter(RibbonAutoConfiguration.class)public class GatewayLoadBalancerClientAutoConfiguration &#123; // GlobalFilter beans @Bean //条件判断注解 //DI容器中存在LoadBalancerClient类型Bean时起效 @ConditionalOnBean(LoadBalancerClient.class) public LoadBalancerClientFilter loadBalancerClientFilter(LoadBalancerClient client) &#123; return new LoadBalancerClientFilter(client); &#125;&#125; GatewayRedisAutoConfiguration GatewayRedisAutoConfiguration 配置作用是初始化初始化 RedisRateLimiter 限流功能的RequestRateLimiterGatewayFilterFactory 基于 RedisRateLimiter 实现网关的限流功能，代码略 GatewayAutoConfiguration GatewayAutoConfiguration配置是Spring Cloud Gateway 核心配置类，初始化如下 ： NettyConfiguration 底层通信netty配置 GlobalFilter （AdaptCachedBodyGlobalFilter，RouteToRequestUrlFilter，ForwardRoutingFilter，ForwardPathFilter，WebsocketRoutingFilter，WeightCalculatorWebFilter等） FilteringWebHandler GatewayProperties PrefixPathGatewayFilterFactory RoutePredicateFactory RouteDefinitionLocator RouteLocator RoutePredicateHandlerMapping 查找匹配到 Route并进行处理 GatewayWebfluxEndpoint 管理网关的 HTTP API 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Configuration//条件注解//通过 spring.cloud.gateway.enabled配置网关的开启与关闭//matchIfMissing = true =&gt; 网关默认开启。@ConditionalOnProperty(name = &quot;spring.cloud.gateway.enabled&quot;, matchIfMissing = true)@EnableConfigurationProperties@AutoConfigureBefore(HttpHandlerAutoConfiguration.class)@AutoConfigureAfter(&#123;GatewayLoadBalancerClientAutoConfiguration.class, GatewayClassPathWarningAutoConfiguration.class&#125;)@ConditionalOnClass(DispatcherHandler.class)public class GatewayAutoConfiguration &#123; @Configuration //当classpath中存在HttpClient起效 @ConditionalOnClass(HttpClient.class) protected static class NettyConfiguration &#123; .....略 &#125; //加载配置beans // ConfigurationProperty beans @Bean public GatewayProperties gatewayProperties() &#123; return new GatewayProperties(); &#125; @Bean public SecureHeadersProperties secureHeadersProperties() &#123; return new SecureHeadersProperties(); &#125; // GlobalFilter beans //加载全局的拦截器 @Bean public AdaptCachedBodyGlobalFilter adaptCachedBodyGlobalFilter() &#123; return new AdaptCachedBodyGlobalFilter(); &#125; @Bean public RouteToRequestUrlFilter routeToRequestUrlFilter() &#123; return new RouteToRequestUrlFilter(); &#125; @Bean @ConditionalOnBean(DispatcherHandler.class) public ForwardRoutingFilter forwardRoutingFilter(DispatcherHandler dispatcherHandler) &#123; return new ForwardRoutingFilter(dispatcherHandler); &#125; @Bean public ForwardPathFilter forwardPathFilter() &#123; return new ForwardPathFilter(); &#125; @Bean public WebSocketService webSocketService() &#123; return new HandshakeWebSocketService(); &#125; @Bean public WebsocketRoutingFilter websocketRoutingFilter(WebSocketClient webSocketClient, return new WebsocketRoutingFilter(webSocketClient, webSocketService, headersFilters); &#125; @Bean public WeightCalculatorWebFilter weightCalculatorWebFilter(Validator validator) &#123; return new WeightCalculatorWebFilter(validator); &#125;&#125; GatewayDiscoveryClientAutoConfiguration GatewayDiscoveryClientAutoConfiguration配置的作用是初始化配置路由中的注册发现服务信息 123456789101112131415161718@Configuration//同4@ConditionalOnProperty(name = &quot;spring.cloud.gateway.enabled&quot;, matchIfMissing = true)@AutoConfigureBefore(GatewayAutoConfiguration.class)@ConditionalOnClass(&#123;DispatcherHandler.class, DiscoveryClient.class&#125;)@EnableConfigurationPropertiespublic class GatewayDiscoveryClientAutoConfiguration &#123; @Bean //当classpath中存在DiscoveryClient起效 @ConditionalOnBean(DiscoveryClient.class) //通过spring.cloud.gateway.discovery.locator.enabled配置注册中心查找的开启与关闭 @ConditionalOnProperty(name = &quot;spring.cloud.gateway.discovery.locator.enabled&quot;) public DiscoveryClientRouteDefinitionLocator discoveryClientRouteDefinitionLocator( DiscoveryClient discoveryClient, DiscoveryLocatorProperties properties) &#123; return new DiscoveryClientRouteDefinitionLocator(discoveryClient, properties); &#125;&#125; 通过自动加载初始化上述五个配置实例Spring-Cloud-Gateway就完成自身的信息加载和初始化工作，而对于使用者来说是无感知的","categories":[{"name":"Spring-Cloud-Gateway","slug":"Spring-Cloud-Gateway","permalink":"https://guofazhan.github.io/categories/Spring-Cloud-Gateway/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"网关","slug":"网关","permalink":"https://guofazhan.github.io/tags/网关/"}]},{"title":"Eureka Server之注册服务实例租约信息管理LeaseManager","slug":"Eureka-Server之注册服务实例租约信息管理LeaseManager","date":"2018-09-03T16:41:00.000Z","updated":"2018-09-03T08:42:53.733Z","comments":true,"path":"2018/09/04/Eureka-Server之注册服务实例租约信息管理LeaseManager/","link":"","permalink":"https://guofazhan.github.io/2018/09/04/Eureka-Server之注册服务实例租约信息管理LeaseManager/","excerpt":"Eureka 注册中心服务端对注册进来的服务信息提供了一个基于时间的可用性管理(租约Lease)。通过此来管理注册服务的有效性","text":"Eureka 注册中心服务端对注册进来的服务信息提供了一个基于时间的可用性管理(租约Lease)。通过此来管理注册服务的有效性 提供租约管理的包路径1com.netflix.eureka.lease 描述注册服务基于时间可用性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 实例租约包装类，描述实例基于时间的可用性 */public class Lease&lt;T&gt; &#123; /** * 实例针对租约变化的动作类型 */ enum Action &#123; //实例注册 Register, //实例取消 Cancel, //实例刷新 Renew &#125;; /** * 默认的租约有效时长 90s */ public static final int DEFAULT_DURATION_IN_SECS = 90; /** * 实例信息，此处默认为 InstanceInfo */ private T holder; /** * 取消注册时间 */ private long evictionTimestamp; /** * 注册时间 */ private long registrationTimestamp; /** * */ private long serviceUpTimestamp; /** * 最后更新时间 */ // Make it volatile so that the expiration task would see this quicker private volatile long lastUpdateTimestamp; /** * 租约的有效时长 */ private long duration; /** * 构造函数 * @param r * @param durationInSecs */ public Lease(T r, int durationInSecs) &#123; holder = r; registrationTimestamp = System.currentTimeMillis(); lastUpdateTimestamp = registrationTimestamp; duration = (durationInSecs * 1000); &#125; 在Lease类中可以看到是使用了装饰模式对注册实例进行了包装，提供了基于时间可用性的新功能。 enum Action 定义了租约时间变更的动作类型，此处包含注册，下线，刷新（心跳发送刷新租约信息）等三个动作 evictionTimestamp：服务下线时间 registrationTimestamp: 服务注册时间 lastUpdateTimestamp: 最后更新时间 duration : 租约的有效时长默认90s Lease类对实例InstanceInfo进行功能扩展的方法： renew 12345678910/** * 刷新租约的时间信息，租约续订更新最后更新时间为当前时间+租约有效时长 * Renew the lease, use renewal duration if it was specified by the * associated &#123;@link T&#125; during registration, otherwise default duration is * &#123;@link #DEFAULT_DURATION_IN_SECS&#125;. */public void renew() &#123; lastUpdateTimestamp = System.currentTimeMillis() + duration;&#125; cancel 123456789/** * 注册列表剔除当前服务，更新租约的时间信息 * Cancels the lease by updating the eviction time. */public void cancel() &#123; if (evictionTimestamp &lt;= 0) &#123; evictionTimestamp = System.currentTimeMillis(); &#125;&#125; serviceUp 12345678910/** * 服务上线时间 * Mark the service as up. This will only take affect the first time called, * subsequent calls will be ignored. */public void serviceUp() &#123; if (serviceUpTimestamp == 0) &#123; serviceUpTimestamp = System.currentTimeMillis(); &#125;&#125; isExpired 1234567/** * 检测租约是否过期 */public boolean isExpired(long additionalLeaseMs) &#123; //剔除服务时间&gt;0或当前时间&gt;（最后更新时间+租约有效时长+时间偏差）时 表示租约已失效 return (evictionTimestamp &gt; 0 || System.currentTimeMillis() &gt; (lastUpdateTimestamp + duration + additionalLeaseMs));&#125; renew:针对动作Renew cancel:针对动作cancel serviceUp:针对动作Register isExpired: 用于校验当前实例的租约是否有效，对外提供服务可用性的检测 注册服务基于时间可用性管理123456789101112131415161718192021222324252627282930/** * 实例租约管理接口，根据租约更新的动作类型操作实例的租约信息 */public interface LeaseManager&lt;T&gt; &#123; /** * 注册实例，更新实例租约信息 * Assign a new &#123;@link Lease&#125; to the passed in &#123;@link T&#125;. */ void register(T r, int leaseDuration, boolean isReplication); /** * 剔除实例时，更新实例租约信息 * Cancel the &#123;@link Lease&#125; associated w/ the passed in &lt;code&gt;appName&lt;/code&gt; * and &lt;code&gt;id&lt;/code&gt;. */ boolean cancel(String appName, String id, boolean isReplication); /** * 刷新实例时更新实例租约信息 * Renew the &#123;@link Lease&#125; associated w/ the passed in &lt;code&gt;appName&lt;/code&gt; * and &lt;code&gt;id&lt;/code&gt;. */ boolean renew(String appName, String id, boolean isReplication); /** * 剔除已过期的租约实例信息 */ void evict();&#125; LeaseManager接口用于提供服务实例基于时间可控性的管理（租约管理），提供以下功能： register ： 服务注册进来设置租约的serviceUp cancel : 服务下线，设置实例租约的cancel renew ： 服务报活（心跳检测）设置租约的renew evict : 遍历注册表通过实例租约isExpired方法校验是否过期，过期强制服务下线操作 其中 1-3 是Eureka 客户端发起操作，4,为服务端定时任务轮询服务注册表，主动剔除过期实例。 LeaseManager默认实现类 AbstractInstanceRegistry register 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * 注册实例，更新实例租约信息 * Registers a new instance with a given duration. */ public void register(InstanceInfo registrant, int leaseDuration, boolean isReplication) &#123; try &#123; read.lock(); //注册表中查询当前注册服务的集群列表信息 Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(registrant.getAppName()); REGISTER.increment(isReplication); if (gMap == null) &#123; //集群不存在时，创建一个新的空集群并添加到注册表 final ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt; gNewMap = new ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt;(); gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap); if (gMap == null) &#123; gMap = gNewMap; &#125; &#125; //在集群列表中根据服务ID查询实例信息 Lease&lt;InstanceInfo&gt; existingLease = gMap.get(registrant.getId()); // Retain the last dirty timestamp without overwriting it, if there is already a lease if (existingLease != null &amp;&amp; (existingLease.getHolder() != null)) &#123; //服务实例信息已存在与集群中 //根据传入实例与已存在实例的LastDirtyTimestamp判断使用具体实例 Long existingLastDirtyTimestamp = existingLease.getHolder().getLastDirtyTimestamp(); Long registrationLastDirtyTimestamp = registrant.getLastDirtyTimestamp(); logger.debug(\"Existing lease found (existing=&#123;&#125;, provided=&#123;&#125;\", existingLastDirtyTimestamp, registrationLastDirtyTimestamp); // this is a &gt; instead of a &gt;= because if the timestamps are equal, we still take the remote transmitted // InstanceInfo instead of the server local copy. if (existingLastDirtyTimestamp &gt; registrationLastDirtyTimestamp) &#123; registrant = existingLease.getHolder(); &#125; &#125; else &#123; //服务实例信息不存在与集群中 // The lease does not exist and hence it is a new registration synchronized (lock) &#123; if (this.expectedNumberOfRenewsPerMin &gt; 0) &#123; // Since the client wants to cancel it, reduce the threshold // (1 // for 30 seconds, 2 for a minute) this.expectedNumberOfRenewsPerMin = this.expectedNumberOfRenewsPerMin + 2; this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold()); &#125; &#125; logger.debug(\"No previous lease information found; it is new registration\"); &#125; //根据服务实例信息构建新的租约实例信息 Lease&lt;InstanceInfo&gt; lease = new Lease&lt;InstanceInfo&gt;(registrant, leaseDuration); if (existingLease != null) &#123; lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp()); &#125; //添加服务实例到集群列表 gMap.put(registrant.getId(), lease); synchronized (recentRegisteredQueue) &#123; //新注册队列中添加当前注册的信息 recentRegisteredQueue.add(new Pair&lt;Long, String&gt;( System.currentTimeMillis(), registrant.getAppName() + \"(\" + registrant.getId() + \")\")); &#125; //判断重载状态 // This is where the initial state transfer of overridden status happens if (!InstanceStatus.UNKNOWN.equals(registrant.getOverriddenStatus())) &#123; logger.debug(\"Found overridden status &#123;&#125; for instance &#123;&#125;. Checking to see if needs to be add to the \" + \"overrides\", registrant.getOverriddenStatus(), registrant.getId()); if (!overriddenInstanceStatusMap.containsKey(registrant.getId())) &#123; logger.info(\"Not found overridden id &#123;&#125; and hence adding it\", registrant.getId()); //将当前服务实例的重载状态添加到重载状态MAP集合中 overriddenInstanceStatusMap.put(registrant.getId(), registrant.getOverriddenStatus()); &#125; &#125; //获取当前实例的重载状态 InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(registrant.getId()); if (overriddenStatusFromMap != null) &#123; logger.info(\"Storing overridden status &#123;&#125; from map\", overriddenStatusFromMap); //设置服务的重载状态 registrant.setOverriddenStatus(overriddenStatusFromMap); &#125; //基于状态规则重新设置状态 // Set the status based on the overridden status rules InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(registrant, existingLease, isReplication); registrant.setStatusWithoutDirty(overriddenInstanceStatus); // 判断服务注册状态，当状态为UP 更新租约信息 // If the lease is registered with UP status, set lease service up timestamp if (InstanceStatus.UP.equals(registrant.getStatus())) &#123; lease.serviceUp(); &#125; //设置服务实例的动作类型为ADD registrant.setActionType(ActionType.ADDED); //将服务添加到最近的改变队列 recentlyChangedQueue.add(new RecentlyChangedItem(lease)); //设置服务最后更新时间 registrant.setLastUpdatedTimestamp(); //校验缓存信息 invalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress()); logger.info(\"Registered instance &#123;&#125;/&#123;&#125; with status &#123;&#125; (replication=&#123;&#125;)\", registrant.getAppName(), registrant.getId(), registrant.getStatus(), isReplication); &#125; finally &#123; read.unlock(); &#125; &#125; cancel 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 根据集群ID ，服务实例ID剔除集群中服务信息 */ protected boolean internalCancel(String appName, String id, boolean isReplication) &#123; try &#123; read.lock(); CANCEL.increment(isReplication); //注册表中获取集群信息列表 Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName); Lease&lt;InstanceInfo&gt; leaseToCancel = null; if (gMap != null) &#123; //在就集群列表中根据服务ID移除服务 leaseToCancel = gMap.remove(id); &#125; synchronized (recentCanceledQueue) &#123; //添加最近下线队列，将当前的下线信息 recentCanceledQueue.add(new Pair&lt;Long, String&gt;(System.currentTimeMillis(), appName + \"(\" + id + \")\")); &#125; //重载实例状态map集合中移除当前的实例的重载状态 InstanceStatus instanceStatus = overriddenInstanceStatusMap.remove(id); if (instanceStatus != null) &#123; logger.debug(\"Removed instance id &#123;&#125; from the overridden map which has value &#123;&#125;\", id, instanceStatus.name()); &#125; if (leaseToCancel == null) &#123; CANCEL_NOT_FOUND.increment(isReplication); logger.warn(\"DS: Registry: cancel failed because Lease is not registered for: &#123;&#125;/&#123;&#125;\", appName, id); return false; &#125; else &#123; //调用租约实例的下线方法，变更租约信息 leaseToCancel.cancel(); //获取实例信息 InstanceInfo instanceInfo = leaseToCancel.getHolder(); String vip = null; String svip = null; if (instanceInfo != null) &#123; //设置实例操作类型为DELETED instanceInfo.setActionType(ActionType.DELETED); //最近变更队列中添加当前实例信息 recentlyChangedQueue.add(new RecentlyChangedItem(leaseToCancel)); //更新实例的最后更新时间 instanceInfo.setLastUpdatedTimestamp(); vip = instanceInfo.getVIPAddress(); svip = instanceInfo.getSecureVipAddress(); &#125; //校验缓存信息 invalidateCache(appName, vip, svip); logger.info(\"Cancelled instance &#123;&#125;/&#123;&#125; (replication=&#123;&#125;)\", appName, id, isReplication); return true; &#125; &#125; finally &#123; read.unlock(); &#125; &#125; renew 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 刷新实例时更新实例租约信息 */ public boolean renew(String appName, String id, boolean isReplication) &#123; RENEW.increment(isReplication); //获取集群列表 Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName); Lease&lt;InstanceInfo&gt; leaseToRenew = null; if (gMap != null) &#123; //集群列表中查询实例信息 leaseToRenew = gMap.get(id); &#125; if (leaseToRenew == null) &#123; RENEW_NOT_FOUND.increment(isReplication); logger.warn(\"DS: Registry: lease doesn't exist, registering resource: &#123;&#125; - &#123;&#125;\", appName, id); return false; &#125; else &#123; //获取实例信息 InstanceInfo instanceInfo = leaseToRenew.getHolder(); if (instanceInfo != null) &#123; // touchASGCache(instanceInfo.getASGName()); //基于状态规则重新设置状态 InstanceStatus overriddenInstanceStatus = this.getOverriddenInstanceStatus( instanceInfo, leaseToRenew, isReplication); if (overriddenInstanceStatus == InstanceStatus.UNKNOWN) &#123; RENEW_NOT_FOUND.increment(isReplication); return false; &#125; if (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) &#123; Object[] args = &#123; instanceInfo.getStatus().name(), instanceInfo.getOverriddenStatus().name(), instanceInfo.getId() &#125;; //设置实例状态 instanceInfo.setStatusWithoutDirty(overriddenInstanceStatus); &#125; &#125; renewsLastMin.increment(); //租约刷新 leaseToRenew.renew(); return true; &#125; &#125; evict 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 剔除已过期的租约实例信息 * @param additionalLeaseMs */ public void evict(long additionalLeaseMs) &#123; logger.debug(\"Running the evict task\"); if (!isLeaseExpirationEnabled()) &#123; logger.debug(\"DS: lease expiration is currently disabled.\"); return; &#125; // We collect first all expired items, to evict them in random order. For large eviction sets, // if we do not that, we might wipe out whole apps before self preservation kicks in. By randomizing it, // the impact should be evenly distributed across all applications. List&lt;Lease&lt;InstanceInfo&gt;&gt; expiredLeases = new ArrayList&lt;&gt;(); //在注册表中查询租约过期的实例列表 for (Entry&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; groupEntry : registry.entrySet()) &#123; Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseMap = groupEntry.getValue(); if (leaseMap != null) &#123; for (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseEntry : leaseMap.entrySet()) &#123; Lease&lt;InstanceInfo&gt; lease = leaseEntry.getValue(); //lease.isExpired() 判断租约是否过期 if (lease.isExpired(additionalLeaseMs) &amp;&amp; lease.getHolder() != null) &#123; expiredLeases.add(lease); &#125; &#125; &#125; &#125; // To compensate for GC pauses or drifting local time, we need to use current registry size as a base for // triggering self-preservation. Without that we would wipe out full registry. //获取本地注册表的大小 int registrySize = (int) getLocalRegistrySize(); //注册表阈值，由registrySize * 配置百分比参数RenewalPercentThreshold int registrySizeThreshold = (int) (registrySize * serverConfig.getRenewalPercentThreshold()); //剔除租约过期的数量 由于RenewalPercentThreshold取值在0-1之间，当为1时，evictionLimit为0 // 即toEvict为0，每次时不会进行对过期的租约服务下线操作，同时 evictionLimit &lt; expiredLeases.size() 时， // 每次操作不会将全部的过期租约实例下线 int evictionLimit = registrySize - registrySizeThreshold; //在租约过期列表大小与每次剔除配置大小中取小值作为本地要剔除的服务实例数 int toEvict = Math.min(expiredLeases.size(), evictionLimit); if (toEvict &gt; 0) &#123; logger.info(\"Evicting &#123;&#125; items (expired=&#123;&#125;, evictionLimit=&#123;&#125;)\", toEvict, expiredLeases.size(), evictionLimit); Random random = new Random(System.currentTimeMillis()); //遍历剔除服务 for (int i = 0; i &lt; toEvict; i++) &#123; // Pick a random item (Knuth shuffle algorithm) int next = i + random.nextInt(expiredLeases.size() - i); Collections.swap(expiredLeases, i, next); Lease&lt;InstanceInfo&gt; lease = expiredLeases.get(i); String appName = lease.getHolder().getAppName(); String id = lease.getHolder().getId(); EXPIRED.increment(); logger.warn(\"DS: Registry: expired lease for &#123;&#125;/&#123;&#125;\", appName, id); //调用下线服务方法 internalCancel(appName, id, false); &#125; &#125; &#125; AbstractInstanceRegistry类中保存这服务注册表信息，1-3方法为客户端主动发起请求到server端的resources模块，resource接受到客户端的请求，根据请求类型调用AbstractInstanceRegistry中的1-3方法。 4 方法为服务端定时清除注册表中的租约过期实例；在AbstractInstanceRegistry类中如下实现： 123456789101112protected void postInit() &#123; renewsLastMin.start(); if (evictionTaskRef.get() != null) &#123; evictionTaskRef.get().cancel(); &#125; //创建清除过期租约任务 evictionTaskRef.set(new EvictionTask()); //启动定时清除注册表中过期租约信息定时任务 evictionTimer.schedule(evictionTaskRef.get(), serverConfig.getEvictionIntervalTimerInMs(), serverConfig.getEvictionIntervalTimerInMs()); &#125; postInit 初始化定时任务信息，执行定时清除租约过期任务 123456789101112131415class EvictionTask extends TimerTask &#123; private final AtomicLong lastExecutionNanosRef = new AtomicLong(0l); @Override public void run() &#123; try &#123; long compensationTimeMs = getCompensationTimeMs(); // 执行租约管理方法evict evict(compensationTimeMs); &#125; catch (Throwable e) &#123; logger.error(\"Could not run the evict task\", e); &#125; &#125; EvictionTask任务run方法中，执行租约管理的evict方法检测注册表中的过期租约实例，并对其进行下线操作。 至此，Eureka赋予了服务注册实例InstanceInfo的基于时间的可用性，并对实例提供了基于时间的可用性的管理。","categories":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"Eureka","slug":"Eureka","permalink":"https://guofazhan.github.io/tags/Eureka/"}]},{"title":"Spring-Cloud-Gateway之GatewayProperties初始化加载","slug":"Spring-Cloud-Gateway之GatewayProperties初始化加载","date":"2018-09-03T08:55:00.000Z","updated":"2018-09-03T09:02:55.683Z","comments":true,"path":"2018/09/03/Spring-Cloud-Gateway之GatewayProperties初始化加载/","link":"","permalink":"https://guofazhan.github.io/2018/09/03/Spring-Cloud-Gateway之GatewayProperties初始化加载/","excerpt":"在Spring-Cloud-Gateway初始化时我们在GatewayAutoConfiguration配置中看到了有初始化加载GatewayProperties实例的配置，接下来学习下GatewayProperties都加载了哪些信息","text":"在Spring-Cloud-Gateway初始化时我们在GatewayAutoConfiguration配置中看到了有初始化加载GatewayProperties实例的配置，接下来学习下GatewayProperties都加载了哪些信息 GatewayAutoConfiguration中我看到加载GatewayProperties如下： 123456 //加载配置beans// ConfigurationProperty beans@Beanpublic GatewayProperties gatewayProperties() &#123; return new GatewayProperties();&#125; GatewayProperties的代码如下： 123456789101112131415161718192021222324252627282930313233/** * 网关配置信息加载 * 从appliccation.yml中解析前缀为spring.cloud.gateway的配置 * @author Spencer Gibb */@ConfigurationProperties(&quot;spring.cloud.gateway&quot;)@Validatedpublic class GatewayProperties &#123; /** * 路由定义列表 * 加载配置key=spring.cloud.gateway.routes 列表 * List of Routes */ @NotNull @Valid private List&lt;RouteDefinition&gt; routes = new ArrayList&lt;&gt;(); /** * 默认的过滤器定义列表 * 加载配置 key = spring.cloud.gateway.default-filters 列表 * List of filter definitions that are applied to every route. */ private List&lt;FilterDefinition&gt; defaultFilters = new ArrayList&lt;&gt;(); /** * 网媒体类型列表 * 加载配置 key = spring.cloud.gateway.streamingMediaTypes 列表 * 默认包含&#123;text/event-stream,application/stream+json&#125; */ private List&lt;MediaType&gt; streamingMediaTypes = Arrays.asList(MediaType.TEXT_EVENT_STREAM, MediaType.APPLICATION_STREAM_JSON);&#125; 由GatewayProperties代码可以看出其包含如下配置信息 spring.cloud.gateway.routes:网关路由定义配置，列表形式 spring.cloud.gateway.default-filters: 网关默认过滤器定义配置，列表形式 spring.cloud.gateway.streamingMediaTypes:网关网络媒体类型，列表形式 同时，我们看到代码中的routes其实RouteDefinition集合，defaultFilters是FilterDefinition集合，在Spring-Cloud-Gateway之route数据模型我们已经分析了这两个数据模型所有的字段含义以及类型了。通过数据模型以及代码可以看出配置中可以包含的具体信息。 spring.cloud.gateway.routes id:路由ID 编号，唯一 uri: 路由指向的URI order: 顺序 predicates:谓语数组，列表形式 spring.cloud.gateway.default-filters name:过滤器定义名称 args: 参数 接下来看下Spring-Cloud-Gateway给的样例工程（spring-cloud-gateway-sample）中的配置 1234567891011121314151617spring: cloud: gateway: default-filters: - PrefixPath=/httpbin - AddResponseHeader=X-Response-Default-Foo, Default-Bar routes: - id: websocket_test uri: ws://localhost:9000 order: 9000 predicates: - Path=/echo - id: default_path_to_httpbin uri: $&#123;test.uri&#125; order: 10000 predicates: - Path=/** 备注 default-filters下配置PrefixPath=/httpbin字符串，可以查看FilterDefinition中构造函数，它接收一个text字符串解析字符传并创建实例信息。同样predicates配置与其一致。字符传格式：name=param1,param2,param3…..。 如下： 1234567891011121314public FilterDefinition(String text) &#123; int eqIdx = text.indexOf(&quot;=&quot;); if (eqIdx &lt;= 0) &#123; setName(text); return; &#125; setName(text.substring(0, eqIdx)); String[] args = tokenizeToStringArray(text.substring(eqIdx+1), &quot;,&quot;); for (int i=0; i &lt; args.length; i++) &#123; this.args.put(NameUtils.generateName(i), args[i]); &#125;&#125; 上面的配置可以很容易的知道最终加载出来GatewayProperties实例中都包含哪些信息。 弄懂了配置的具体加载以及初始化会加深对网关整体流程的理解，合理的使用配置文件定义我们自己的需求，快速的根据配置定位，了解服务的详细情况","categories":[{"name":"Spring-Cloud-Gateway","slug":"Spring-Cloud-Gateway","permalink":"https://guofazhan.github.io/categories/Spring-Cloud-Gateway/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"网关","slug":"网关","permalink":"https://guofazhan.github.io/tags/网关/"}]},{"title":"Spring-Cloud-Gateway之route数据模型","slug":"Spring-Cloud-Gateway之route数据模型","date":"2018-09-03T08:52:00.000Z","updated":"2018-09-03T09:03:18.020Z","comments":true,"path":"2018/09/03/Spring-Cloud-Gateway之route数据模型/","link":"","permalink":"https://guofazhan.github.io/2018/09/03/Spring-Cloud-Gateway之route数据模型/","excerpt":"网关服务核心是将进入的请求正确合理的路由到下层具体的服务进行业务处理，由此可见网关服务的核心就是路由信息的构建。下面学习和阅读下Spring-Cloud-Gateway的route数据模型","text":"网关服务核心是将进入的请求正确合理的路由到下层具体的服务进行业务处理，由此可见网关服务的核心就是路由信息的构建。下面学习和阅读下Spring-Cloud-Gateway的route数据模型 首先查看Route模型的代码如下： 12345678910111213141516171819202122232425262728293031public class Route implements Ordered &#123; /** * 路由编号 * ID 编号，唯一 */ private final String id; /** * 路由向的 URI * */ private final URI uri; /** * 顺序 * 当请求匹配到多个路由时，使用顺序小的 */ private final int order; /** * 谓语数组 * 请求通过 predicates 判断是否匹配 */ private final Predicate&lt;ServerWebExchange&gt; predicate; /** * 过滤器数组 */ private final List&lt;GatewayFilter&gt; gatewayFilters; &#125; 由代码可以看到一个路由应该包含如下必要的信息： id：路由编号，唯一 uri:路由向的 URI,对应的具体业务服务的URL order:顺序，当请求匹配多个路由时，使用顺序小的 predicate: 请求匹配路由的断言条件 gatewayFilters: 当前路由上存在的过滤器，用于对请求做拦截处理 Route模型是通过RouteDefinition（路由定义）模型构建起来的，接下来查看RouteDefinition 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 路由定义实体信息，包含路由的定义信息 * @author Spencer Gibb */@Validatedpublic class RouteDefinition &#123; /** * 路由ID 编号，唯一 */ @NotEmpty private String id = UUID.randomUUID().toString(); /** * 谓语定义数组 * predicates 属性，谓语定义数组 * 请求通过 predicates 判断是否匹配。在 Route 里，PredicateDefinition 转换成 Predicate */ @NotEmpty @Valid private List&lt;PredicateDefinition&gt; predicates = new ArrayList&lt;&gt;(); /** *过滤器定义数组 * filters 属性，过滤器定义数组。 * 在 Route 里，FilterDefinition 转换成 GatewayFilter */ @Valid private List&lt;FilterDefinition&gt; filters = new ArrayList&lt;&gt;(); /** * 路由指向的URI */ @NotNull private URI uri; /** * 顺序 */ private int order = 0;&#125; 这个模型与上面的Route模型是不是很相似，它是对route的定义以及描述，Spring-Cloud-Gateway最终会通过RouteDefinition来构建起Route实例信息。细看RouteDefinition代码会发现其中包含两个数组分别是PredicateDefinition，FilterDefinition的数组。 PredicateDefinition : 断言条件(谓语)定义，构建 Route 时，PredicateDefinition 转换成 Predicate FilterDefinition : 过滤条件的定义，构建Route 时，FilterDefinition 转换成 GatewayFilter 那么我们看下PredicateDefinition与FilterDefinition的代码 PredicateDefinition12345678910111213141516171819/** * 谓语定义,在 Route 里，PredicateDefinition将转换成 Predicate * @author Spencer Gibb */@Validatedpublic class PredicateDefinition &#123; /** * 谓语定义名字 * 通过 name 对应到 org.springframework.cloud.gateway.handler.predicate.RoutePredicateFactory 的实现类。 * 例如: name=Query 对应到 QueryRoutePredicateFactory */ @NotNull private String name; /** * 参数数组 * 例如，name=Host / args=&#123;&quot;_genkey_0&quot; : &quot;iocoder.cn&quot;&#125; ，匹配请求的 hostname 为 iocoder.cn */ private Map&lt;String, String&gt; args = new LinkedHashMap&lt;&gt;();&#125; PredicateDefinition 描述了构建Predicate的必要条件 name:名称，Spring-Cloud-Gateway会根据name找到Predicate的构建工厂类 args:参数，构建Predicate的参数 FilterDefinition 123456789101112131415161718192021/** * 过滤器定义，在 Route 里，FilterDefinition将转换成 GatewayFilter * @author Spencer Gibb */@Validatedpublic class FilterDefinition &#123; /** * 过滤器定义名字 * 通过 name 对应到 org.springframework.cloud.gateway.filter.factory.GatewayFilterFactory 的实现类。 * 例如，name=AddRequestParameter 对应到 AddRequestParameterGatewayFilterFactory */ @NotNull private String name; /** * 参数数组 * 例如 name=AddRequestParameter / args=&#123;&quot;_genkey_0&quot;: &quot;foo&quot;, &quot;_genkey_1&quot;: &quot;bar&quot;&#125; ，添加请求参数 foo 为 bar */ private Map&lt;String, String&gt; args = new LinkedHashMap&lt;&gt;();&#125; FilterDefinition 描述了构建GatewayFilter的必要条件 name:名称，Spring-Cloud-Gateway会根据name找到GatewayFilter的构建工厂类 args:参数，构建GatewayFilter的参数 通过这些基础的数据模型我可以清晰看到Spring-Cloud-Gateway构建路由的数据流向 1234graph LRFilterDefinition--&gt;RouteDefinitionPredicateDefinition--&gt;RouteDefinitionRouteDefinition--&gt;Route 通过数据流向可以帮助我们接下来阅读Route信息的初始化加载以及路由的使用","categories":[{"name":"Spring-Cloud-Gateway","slug":"Spring-Cloud-Gateway","permalink":"https://guofazhan.github.io/categories/Spring-Cloud-Gateway/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"网关","slug":"网关","permalink":"https://guofazhan.github.io/tags/网关/"}]},{"title":"Eureka之服务发现LookupService","slug":"Eureka之服务发现LookupService","date":"2018-08-28T11:38:00.000Z","updated":"2018-08-28T03:42:55.877Z","comments":true,"path":"2018/08/28/Eureka之服务发现LookupService/","link":"","permalink":"https://guofazhan.github.io/2018/08/28/Eureka之服务发现LookupService/","excerpt":"Eureka 注册中心，核心为提供服务注册，以及服务发现功能，下面我们重点讨论下Eureka核心功能之一的服务发现。我们知道Eureka采用的C-S架构，客户端要通过请求服务端获取注册列表，提供给服务使用，服务端要保存客户端发来的注册信息保存下（Eureka采用的是内存存储），并提供给资源服务Resources使用，有关资源服务可见Eureka之REST API","text":"Eureka 注册中心，核心为提供服务注册，以及服务发现功能，下面我们重点讨论下Eureka核心功能之一的服务发现。我们知道Eureka采用的C-S架构，客户端要通过请求服务端获取注册列表，提供给服务使用，服务端要保存客户端发来的注册信息保存下（Eureka采用的是内存存储），并提供给资源服务Resources使用，有关资源服务可见Eureka之REST API LookupService体系图 InstanceRegistry为Server端对资源服务提供服务发现功能的接口，用来读取服务端本地缓存注册表信息 EurekaClient 为Client端实现的服务发现接口，用来获取客户端本地缓存中的注册表信息 RemoteRegionRegistry 为Server用来读取其它区域的服务注册表的接口，并将其它区域的服务注册表缓存到本地，供本地InstanceRegistry使用。 Eureka区域，分区 eureka提供了region和zone两个概念来进行分区，这两个概念均来自于亚马逊的AWS： region：可以简单理解为地理上的分区，比如亚洲地区，或者华北地区，再或者北京等等，没有具体大小的限制。根据项目具体的情况，可以自行合理划分region。RemoteRegionRegistry就是其它分区的服务注册信息。 zone：可以简单理解为region内的具体机房，比如说region划分为北京，然后北京有两个机房，就可以在此region之下划分出zone1,zone2两个zone。 RemoteRegionRegistry 根据配置实例化： 配置KEY： eureka.remoteRegionUrlsWithName 格式： eureka.remoteRegionUrlsWithName=region1;http://region1host/eureka/v2,region2;http://region2host/eureka/v2 解析: regionName-&gt;remoteRegionURL 根据解析出来的MAP 创建相应的 RemoteRegionRegistry 备注： 一般中小行项目基本所有服务都部署在同一机房，不存在区域划分这些，即初始化时:RemoteRegionRegistry List为空,具体可参见AbstractInstanceRegistry的initRemoteRegionRegistry方法 LookupService类图以及实现 服务发现LookupService接口1234567891011121314151617181920212223242526272829303132333435363738394041/** * 服务发现接口 * Lookup service for finding active instances. * * @author Karthik Ranganathan, Greg Kim. * @param &lt;T&gt; for backward compatibility */public interface LookupService&lt;T&gt; &#123; /** * 根据集群ID获取集群列表 * Returns the corresponding &#123;@link Application&#125; object which is basically a * container of all registered &lt;code&gt;appName&lt;/code&gt; &#123;@link InstanceInfo&#125;s. * * @param appName * @return a &#123;@link Application&#125; or null if we couldn't locate any app of * the requested appName */ Application getApplication(String appName); /** * 获取服务注册列表 * Returns the &#123;@link Applications&#125; object which is basically a container of * all currently registered &#123;@link Application&#125;s. * * @return &#123;@link Applications&#125; */ Applications getApplications(); /** * 根据实例ID获取实例信息 */ List&lt;InstanceInfo&gt; getInstancesById(String id); /** * 轮询获取集群中的下一个可用的注册服务，起到负载均衡作用，保证每个可用注册服务均衡的被使用，此方法仅提供个Eureka 客户端使用实现，服务端默认为空实现 * Gets the next possible server to process the requests from the registry * information received from eureka. */ InstanceInfo getNextServerFromEureka(String virtualHostname, boolean secure); 从接口可以看到提供了四个功能方法如下： getApplication:根据集群ID获取集群列表 getApplications:获取服务注册列表 getInstancesById:根据实例ID获取实例信息 getNextServerFromEureka:轮询获取集群中的下一个可用的注册服务，起到负载均衡作用，保证每个可用注册服务均衡的被使用，此方法仅提供个Eureka 客户端使用实现，服务端默认为空实现 服务端实现AbstractInstanceRegistry 缓存服务注册属性 123456/** * 服务注册表 */ private final ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; registry = new ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;(); 其它区域服务发现集合属性 1234/** * 远程区域服务发现注册服务集合 */protected Map&lt;String, RemoteRegionRegistry&gt; regionNameVSRemoteRegistry = new HashMap&lt;String, RemoteRegionRegistry&gt;(); getApplications功能方法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** * 获取服务注册列表信息 * Get all applications in this instance registry, falling back to other regions if allowed in the Eureka config. * * @return the list of all known applications * * @see com.netflix.discovery.shared.LookupService#getApplications() */public Applications getApplications() &#123; //配置参数，是否禁用远程区域的服务注册列表 boolean disableTransparentFallback = serverConfig.disableTransparentFallbackToOtherRegion(); if (disableTransparentFallback) &#123; //获取本地服务注册列表 return getApplicationsFromLocalRegionOnly(); &#125; else &#123; //获取服务注册列表在所有区域中，包含本地 return getApplicationsFromAllRemoteRegions(); // Behavior of falling back to remote region can be disabled. &#125;&#125; /** * 获服务注册列表,在所有区域 * Returns applications including instances from all remote regions. &lt;br/&gt; * Same as calling &#123;@link #getApplicationsFromMultipleRegions(String[])&#125; with a &lt;code&gt;null&lt;/code&gt; argument. */public Applications getApplicationsFromAllRemoteRegions() &#123; //根据区域信息获取服务注册列表，此处区域列表传入所有远程区域列表 return getApplicationsFromMultipleRegions(allKnownRemoteRegions);&#125;/** * 获取本地服务注册列表 * Returns applications including instances from local region only. &lt;br/&gt; * Same as calling &#123;@link #getApplicationsFromMultipleRegions(String[])&#125; with an empty array. */@Overridepublic Applications getApplicationsFromLocalRegionOnly() &#123; //根据区域信息获取服务注册列表，此处区域列表传入空值 return getApplicationsFromMultipleRegions(EMPTY_STR_ARRAY);&#125; /** * 根据区域信息查询服务注册列表 */public Applications getApplicationsFromMultipleRegions(String[] remoteRegions) &#123; //是否根据远程区域查询服务注册列表标识 boolean includeRemoteRegion = null != remoteRegions &amp;&amp; remoteRegions.length != 0; logger.debug(\"Fetching applications registry with remote regions: &#123;&#125;, Regions argument &#123;&#125;\", includeRemoteRegion, Arrays.toString(remoteRegions)); //记录统计监控数据 if (includeRemoteRegion) &#123; GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS.increment(); &#125; else &#123; GET_ALL_CACHE_MISS.increment(); &#125; //构建服务注册列表实例信息 Applications apps = new Applications(); apps.setVersion(1L); //加入本地注册信息到服务注册列表实例中 for (Entry&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; entry : registry.entrySet()) &#123; Application app = null; if (entry.getValue() != null) &#123; for (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; stringLeaseEntry : entry.getValue().entrySet()) &#123; Lease&lt;InstanceInfo&gt; lease = stringLeaseEntry.getValue(); if (app == null) &#123; app = new Application(lease.getHolder().getAppName()); &#125; app.addInstance(decorateInstanceInfo(lease)); &#125; &#125; if (app != null) &#123; apps.addApplication(app); &#125; &#125; //是否加入远程区域的注册信息 if (includeRemoteRegion) &#123; //遍历远程区域，添加远程区域的注册信息到服务注册列表实例 for (String remoteRegion : remoteRegions) &#123; RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion); if (null != remoteRegistry) &#123; Applications remoteApps = remoteRegistry.getApplications(); for (Application application : remoteApps.getRegisteredApplications()) &#123; if (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) &#123; logger.info(\"Application &#123;&#125; fetched from the remote region &#123;&#125;\", application.getName(), remoteRegion); Application appInstanceTillNow = apps.getRegisteredApplications(application.getName()); if (appInstanceTillNow == null) &#123; appInstanceTillNow = new Application(application.getName()); apps.addApplication(appInstanceTillNow); &#125; for (InstanceInfo instanceInfo : application.getInstances()) &#123; appInstanceTillNow.addInstance(instanceInfo); &#125; &#125; else &#123; logger.debug(\"Application &#123;&#125; not fetched from the remote region &#123;&#125; as there exists a \" + \"whitelist and this app is not in the whitelist.\", application.getName(), remoteRegion); &#125; &#125; &#125; else &#123; logger.warn(\"No remote registry available for the remote region &#123;&#125;\", remoteRegion); &#125; &#125; &#125; //设置实例的hashCode apps.setAppsHashCode(apps.getReconcileHashCode()); return apps;&#125; getApplications功能主要由以下方法完成： getApplications : 此方法根据配置参数信息，判断是只从本地缓存中获取注册列表(getApplicationsFromLocalRegionOnly)还是从所以区域获取注册列表(getApplicationsFromAllRemoteRegions)，参数信息：disableTransparentFallback getApplicationsFromLocalRegionOnly :获取本地缓存中的注册表信息，调用getApplicationsFromMultipleRegions传入空区域集合 getApplicationsFromAllRemoteRegions : 从所有区域查找注册表信息，传入全部区域集合。 getApplicationsFromMultipleRegions ：根据传入区域信息查询注册表信息 getApplicationsFromMultipleRegions完成如下功能: 构建空注册表实例：Applications 添加本地缓存的注册信息到Applications 判断是否查找其它区域 遍历其它区域RemoteRegionRegistry获取Applications 添加其它区域中注册的信息到Applications（剔除重复的） 设置apps的hashCode 用于增量更新 getApplications功能方法实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 根据服务集群ID，查询服务集群列表 * * @param appName the application name of the application * @return the application * * @see com.netflix.discovery.shared.LookupService#getApplication(java.lang.String) */@Overridepublic Application getApplication(String appName) &#123; //获取配置信息 //配置参数，是否禁用远程区域的服务注册列表 boolean disableTransparentFallback = serverConfig.disableTransparentFallbackToOtherRegion(); return this.getApplication(appName, !disableTransparentFallback);&#125;/** * 根据服务集群ID，查询服务集群列表 * Get application information. * @return the application */@Overridepublic Application getApplication(String appName, boolean includeRemoteRegion) &#123; Application app = null; //获取本地注册列表中的服务集群信息 Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseMap = registry.get(appName); if (leaseMap != null &amp;&amp; leaseMap.size() &gt; 0) &#123; //构建集群实例Application for (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; entry : leaseMap.entrySet()) &#123; if (app == null) &#123; app = new Application(appName); &#125; app.addInstance(decorateInstanceInfo(entry.getValue())); &#125; &#125; else if (includeRemoteRegion) &#123; //包含远程区域时，通过远程区域注册服务查询集群信息 for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) &#123; Application application = remoteRegistry.getApplication(appName); if (application != null) &#123; return application; &#125; &#125; &#125; //返回集群实例 return app;&#125; getApplication功能主要由以下方法完成：getApplication ： 根据 集群名称以及参数是否禁用其它区域来获取集群列表Application 通过本地缓存注册信息获取组装集群实例Application 当本地缓存中未查到集群信息且可用远程区域发现服务查询时，遍历远程区域发现服务查询集群信息组装集群实例Application 返回集群实例Application getInstancesById功能方法实现 与4功能类似 getNextServerFromEureka功能方法实现 空实现 客户端实现DiscoveryClient1234567891011121314151617181920212223242526272829303132333435/* * (non-Javadoc) * @see com.netflix.discovery.shared.LookupService#getApplication(java.lang.String) */@Overridepublic Application getApplication(String appName) &#123; return getApplications().getRegisteredApplications(appName);&#125;/* * (non-Javadoc) * * @see com.netflix.discovery.shared.LookupService#getApplications() */@Overridepublic Applications getApplications() &#123; return localRegionApps.get();&#125; /* * (non-Javadoc) * @see com.netflix.discovery.shared.LookupService#getInstancesById(java.lang.String) */@Overridepublic List&lt;InstanceInfo&gt; getInstancesById(String id) &#123; List&lt;InstanceInfo&gt; instancesList = new ArrayList&lt;InstanceInfo&gt;(); for (Application app : this.getApplications() .getRegisteredApplications()) &#123; InstanceInfo instanceInfo = app.getByInstanceId(id); if (instanceInfo != null) &#123; instancesList.add(instanceInfo); &#125; &#125; return instancesList;&#125; 在客户端的实现方法中可以清晰的看到是通过localRegionApps.get()获取服务注册列表实例，此实例是在本地缓存存储且为原子性的。下面我们主要查看localRegionApps是怎么加载以及更新 构造函数首次加载localRegionApps 12345//通过fetchRegistry方法首次从远程Server端获取注册列表缓存到客户端本地，默认选择增量拉取if (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(false)) &#123; fetchRegistryFromBackup();&#125; 在构造函数中调用fetchRegistry 首次初始化从服务端拉取服务注册实例并缓存到客户端内存中 初始化定时任务，定时拉取服务端注册信息刷新本地缓存 12345678910111213141516171819202122232425262728293031323334/** * Initializes all scheduled tasks. */private void initScheduledTasks() &#123; //判断客户端远程拉取注册表禁用配置，true，标识客户端运行定时拉取远程注册表配置 if (clientConfig.shouldFetchRegistry()) &#123; // registry cache refresh timer int registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds(); int expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound(); //定时任务定时执行客户端远程拉取注册表来更新客户端本地缓存 scheduler.schedule( new TimedSupervisorTask( &quot;cacheRefresh&quot;, scheduler, cacheRefreshExecutor, registryFetchIntervalSeconds, TimeUnit.SECONDS, expBackOffBound, new CacheRefreshThread() ), registryFetchIntervalSeconds, TimeUnit.SECONDS); &#125;&#125; /** * 远程拉取Server端注册表信息更新客户端本地缓存，定时任务，客户端定时执行此任务 * The task that fetches the registry information at specified intervals. * */class CacheRefreshThread implements Runnable &#123; public void run() &#123; refreshRegistry(); &#125;&#125; 构造函数初始化定时任务，调用initScheduledTasks 定时任务，初始化刷新服务注册表实例定时任务 CacheRefreshThread线程定时执行，调用refreshRegistry()方法从server端拉取注册信息并刷新本地缓存 fetchRegistry功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/** * 客户端拉取Eureka Server服务注册列表，本地缓存 (forceFullRegistryFetch 是否全量拉取标识) */ private boolean fetchRegistry(boolean forceFullRegistryFetch) &#123; Stopwatch tracer = FETCH_REGISTRY_TIMER.start(); try &#123; // If the delta is disabled or if it is the first time, get all // applications //本地缓存中获取注册列表信息 Applications applications = getApplications(); //判断全量拉取还是增量拉取 if (clientConfig.shouldDisableDelta() || (!Strings.isNullOrEmpty(clientConfig.getRegistryRefreshSingleVipAddress())) || forceFullRegistryFetch || (applications == null) || (applications.getRegisteredApplications().size() == 0) || (applications.getVersion() == -1)) //Client application does not have latest library supporting delta &#123; //全量拉取注册表信息 getAndStoreFullRegistry(); &#125; else &#123; //增量拉取注册表信息 getAndUpdateDelta(applications); &#125; //设置hashCode，注册列表判断变化是根据hashCode applications.setAppsHashCode(applications.getReconcileHashCode()); //日志打印统计 logTotalInstances(); &#125; catch (Throwable e) &#123; logger.error(PREFIX + appPathIdentifier + \" - was unable to refresh its cache! status = \" + e.getMessage(), e); return false; &#125; finally &#123; if (tracer != null) &#123; tracer.stop(); &#125; &#125; //通知缓存刷新事件 // Notify about cache refresh before updating the instance remote status onCacheRefreshed(); //更新实例的远程状态 // Update remote status based on refreshed data held in the cache updateInstanceRemoteStatus(); // registry was fetched successfully, so return true return true; &#125; /** * 全量拉取Eureka Server端的注册列表信息 */ private void getAndStoreFullRegistry() throws Throwable &#123; long currentUpdateGeneration = fetchRegistryGeneration.get(); logger.info(\"Getting all instance registry info from the eureka server\"); Applications apps = null; //通过远程通讯组件请求Server端获取全量注册列表 EurekaHttpResponse&lt;Applications&gt; httpResponse = clientConfig.getRegistryRefreshSingleVipAddress() == null ? eurekaTransport.queryClient.getApplications(remoteRegionsRef.get()) : eurekaTransport.queryClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress(), remoteRegionsRef.get()); if (httpResponse.getStatusCode() == Status.OK.getStatusCode()) &#123; apps = httpResponse.getEntity(); &#125; logger.info(\"The response status is &#123;&#125;\", httpResponse.getStatusCode()); if (apps == null) &#123; logger.error(\"The application is null for some reason. Not storing this information\"); &#125; else if (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + 1)) &#123; //获取的注册列表缓存到本地 localRegionApps.set(this.filterAndShuffle(apps)); logger.debug(\"Got full registry with apps hashcode &#123;&#125;\", apps.getAppsHashCode()); &#125; else &#123; logger.warn(\"Not updating applications as another thread is updating it already\"); &#125; &#125; /** * 增量拉取Eureka Server端的注册列表信息 */ private void getAndUpdateDelta(Applications applications) throws Throwable &#123; long currentUpdateGeneration = fetchRegistryGeneration.get(); Applications delta = null; //通过远程通讯组件请求Server端获取增量注册列表 EurekaHttpResponse&lt;Applications&gt; httpResponse = eurekaTransport.queryClient.getDelta(remoteRegionsRef.get()); if (httpResponse.getStatusCode() == Status.OK.getStatusCode()) &#123; delta = httpResponse.getEntity(); &#125; if (delta == null) &#123; logger.warn(\"The server does not allow the delta revision to be applied because it is not safe. \" + \"Hence got the full registry.\"); //增量获取为空时，全量拉取 getAndStoreFullRegistry(); &#125; else if (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + 1)) &#123; logger.debug(\"Got delta update with apps hashcode &#123;&#125;\", delta.getAppsHashCode()); String reconcileHashCode = \"\"; //拉取注册表更新锁 if (fetchRegistryUpdateLock.tryLock()) &#123; try &#123; //更新增量信息到本地缓存中的注册表中 updateDelta(delta); //获取更新后的HashCode reconcileHashCode = getReconcileHashCode(applications); &#125; finally &#123; fetchRegistryUpdateLock.unlock(); &#125; &#125; else &#123; logger.warn(\"Cannot acquire update lock, aborting getAndUpdateDelta\"); &#125; //判断本地的hashCode是否与远程hashCode一致，不一致时，需要同步一致 // There is a diff in number of instances for some reason if (!reconcileHashCode.equals(delta.getAppsHashCode()) || clientConfig.shouldLogDeltaDiff()) &#123; reconcileAndLogDifference(delta, reconcileHashCode); // this makes a remoteCall &#125; &#125; else &#123; logger.warn(\"Not updating application delta as another thread is updating it already\"); logger.debug(\"Ignoring delta update with apps hashcode &#123;&#125;, as another thread is updating it already\", delta.getAppsHashCode()); &#125; &#125; fetchRegistry : 根据传入参数以及配置信息判断是否全量拉取还是增量拉取，全量拉取调用getAndStoreFullRegistry方法 ；增量拉取调用getAndUpdateDelta方法 getAndStoreFullRegistry：全量从Server拉取服务注册信息，更新本地缓存。此方法通过Eureka提供的远程通讯模块调用Server端暴露的Resources信息获取服务注册列表实例apps getAndUpdateDelta ：增量从Server端拉取服务的增量注册信息，更新本地缓存实例。 远程区域服务发现实现RemoteRegionRegistry 与客户端实现方式基本一致，不在描述 客户端，服务端，远程区域服务端交互","categories":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"Eureka","slug":"Eureka","permalink":"https://guofazhan.github.io/tags/Eureka/"}]},{"title":"Eureka之远程通讯模块","slug":"Eureka之远程通讯模块","date":"2018-08-25T01:10:00.000Z","updated":"2018-08-24T09:15:02.964Z","comments":true,"path":"2018/08/25/Eureka之远程通讯模块/","link":"","permalink":"https://guofazhan.github.io/2018/08/25/Eureka之远程通讯模块/","excerpt":"Eureka 架构为C-S模式 同时支持S 集群 ，不可避免的在client-server、server-server之间是需要远程通讯的，上面已经知道，Eureka 提供是http协议rest api，下面通过源码源码分析学习下eureka 提供的远程通讯模块 提供远程通讯模块的包路径1com.netflix.discovery.shared.transport 通讯模块对外的核心接口矩阵 EurekaHttpClient 通讯请求接口，负责发送http请求 EurekaHttpClientFactory EurekaHttpClient创建工厂接口，负责创建高等级的client TransportClientFactory EurekaHttpClient创建工厂接口，负责创建低等级的client EurekaTransportConfig 通讯相关配置获取接口，负责在配置文件中读取通讯模块的配置信息 备注： EurekaHttpClientFactory与TransportClientFactory同样都是创建client工厂，不过两个的职责不一样，client按功能划分为两大类，下面详细介绍。","text":"Eureka 架构为C-S模式 同时支持S 集群 ，不可避免的在client-server、server-server之间是需要远程通讯的，上面已经知道，Eureka 提供是http协议rest api，下面通过源码源码分析学习下eureka 提供的远程通讯模块 提供远程通讯模块的包路径1com.netflix.discovery.shared.transport 通讯模块对外的核心接口矩阵 EurekaHttpClient 通讯请求接口，负责发送http请求 EurekaHttpClientFactory EurekaHttpClient创建工厂接口，负责创建高等级的client TransportClientFactory EurekaHttpClient创建工厂接口，负责创建低等级的client EurekaTransportConfig 通讯相关配置获取接口，负责在配置文件中读取通讯模块的配置信息 备注： EurekaHttpClientFactory与TransportClientFactory同样都是创建client工厂，不过两个的职责不一样，client按功能划分为两大类，下面详细介绍。 EurekaHttpClient 通过上图可以明确的看出EurekaHttpClient接口实现为两大类: 实现http通讯的lowlevel实现； 使用装饰器模式实现特定功能的top level实现 。 low level实现： Eureka 根据http client 实现了两个AbstractJerseyEurekaHttpClient与AbstractJersey2EurekaHttpClient的low level 实现。从上面可以看出，如果Jersey1与Jersey2都不满足我们的自己的需求的话，我也可以根据自己需要的httpClient实现替代类，例如实现以OKhttp作为底层通讯的OkHttpEurekaHttpClient 或实现以netty作为底层通讯的NettyEurekaHttpClient， top level实现 ： 通过装饰器模式eueka 内置了 响应指标采集功能的装饰器、失败重试功能装饰器等，同时我们也可以扩展。 备注： HttpReplicationClient是eureka 专为server端集群节点通讯提供的通讯接口。其本质low level EurekaHttpClient接口方法 方法 描述 register(InstanceInfo info) 服务注册 cancel(String appName, String id) 服务下线 sendHeartBeat 服务续约 statusUpdate 服务状态更新 deleteStatusOverride getApplications(String… regions) 获取服务注册列表 getDelta(String… regions) 获取增量列表 getVip(String vipAddress, String… regions) 根据vip获取列表 getSecureVip(String secureVipAddress, String… regions) 根据svip获取列表 getApplication(String appName) 根据集群ID获取服务集群列表 getInstance(String appName, String id) 根据集群ID与服务ID获取服务 getInstance(String id) 根据服务ID获取服务 HttpReplicationClient接口方法 (server 节点数据同步特有) 方法 描述 statusUpdate(String asgName, ASGStatus newStatus) 状态更新同步 submitBatchUpdates(ReplicationList replicationList) 批量执行更新同步任务 EurekaTransportConfig通讯配置新获取1234567891011121314151617181920212223/** * eureka 远程通讯客户端配置默认实现 * @author David Liu */public class DefaultEurekaTransportConfig implements EurekaTransportConfig &#123; private static final String SUB_NAMESPACE = TRANSPORT_CONFIG_SUB_NAMESPACE + \".\"; private final String namespace; private final DynamicPropertyFactory configInstance; public DefaultEurekaTransportConfig(String parentNamespace, DynamicPropertyFactory configInstance) &#123; this.namespace = parentNamespace == null ? SUB_NAMESPACE : (parentNamespace.endsWith(\".\") ? parentNamespace + SUB_NAMESPACE : parentNamespace + \".\" + SUB_NAMESPACE); this.configInstance = configInstance; &#125; @Override public int getSessionedClientReconnectIntervalSeconds() &#123; return configInstance.getIntProperty(namespace + SESSION_RECONNECT_INTERVAL_KEY, Values.SESSION_RECONNECT_INTERVAL).get(); &#125; 1.构建函数创建 DynamicPropertyFactory 构建函数 初始化namespace 配置key的前缀 获取配置信息通过DynamicPropertyFactory 动态在配置文件中获取 EurekaHttpClients 工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public final class EurekaHttpClients &#123; private static final Logger logger = LoggerFactory.getLogger(EurekaHttpClients.class); private EurekaHttpClients() &#123; &#125; public static EurekaHttpClientFactory queryClientFactory(ClusterResolver bootstrapResolver, TransportClientFactory transportClientFactory, EurekaClientConfig clientConfig, EurekaTransportConfig transportConfig, InstanceInfo myInstanceInfo, ApplicationsResolver.ApplicationsSource applicationsSource) &#123; ClosableResolver queryResolver = transportConfig.useBootstrapResolverForQuery() ? wrapClosable(bootstrapResolver) : queryClientResolver(bootstrapResolver, transportClientFactory, clientConfig, transportConfig, myInstanceInfo, applicationsSource); return canonicalClientFactory(EurekaClientNames.QUERY, transportConfig, queryResolver, transportClientFactory); &#125; public static EurekaHttpClientFactory registrationClientFactory(ClusterResolver bootstrapResolver, TransportClientFactory transportClientFactory, EurekaTransportConfig transportConfig) &#123; return canonicalClientFactory(EurekaClientNames.REGISTRATION, transportConfig, bootstrapResolver, transportClientFactory); &#125; static EurekaHttpClientFactory canonicalClientFactory(final String name, final EurekaTransportConfig transportConfig, final ClusterResolver&lt;EurekaEndpoint&gt; clusterResolver, final TransportClientFactory transportClientFactory) &#123; return new EurekaHttpClientFactory() &#123; @Override public EurekaHttpClient newClient() &#123; return new SessionedEurekaHttpClient( name, RetryableEurekaHttpClient.createFactory( name, transportConfig, clusterResolver, RedirectingEurekaHttpClient.createFactory(transportClientFactory), ServerStatusEvaluators.legacyEvaluator()), transportConfig.getSessionedClientReconnectIntervalSeconds() * 1000 ); &#125; @Override public void shutdown() &#123; wrapClosable(clusterResolver).shutdown(); &#125; &#125;; &#125; EurekaHttpClients，是创建EurekaHttpClientFactory的工具类 EurekaHttpClient Low Level部分 JerseyEurekaHttpClientFactory 1234567891011121314151617181920212223242526272829public class JerseyEurekaHttpClientFactory implements TransportClientFactory &#123; public static final String HTTP_X_DISCOVERY_ALLOW_REDIRECT = \"X-Discovery-AllowRedirect\"; private final EurekaJerseyClient jerseyClient; private final ApacheHttpClient4 apacheClient; private final ApacheHttpClientConnectionCleaner cleaner; private final Map&lt;String, String&gt; additionalHeaders; private JerseyEurekaHttpClientFactory(EurekaJerseyClient jerseyClient, ApacheHttpClient4 apacheClient, long connectionIdleTimeout, Map&lt;String, String&gt; additionalHeaders) &#123; this.jerseyClient = jerseyClient; this.apacheClient = jerseyClient != null ? jerseyClient.getClient() : apacheClient; this.additionalHeaders = additionalHeaders; this.cleaner = new ApacheHttpClientConnectionCleaner(this.apacheClient, connectionIdleTimeout); &#125; /** * 服务创建JerseyApplicationClient * @param endpoint * @return */ @Override public EurekaHttpClient newClient(EurekaEndpoint endpoint) &#123; return new JerseyApplicationClient(apacheClient, endpoint.getServiceUrl(), additionalHeaders); &#125; JerseyEurekaHttpClientFactory 为TransportClientFactory的Jersey1实现主要负责创建JerseyEurekaHttpClient AbstractJerseyEurekaHttpClient 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public abstract class AbstractJerseyEurekaHttpClient implements EurekaHttpClient &#123; private static final Logger logger = LoggerFactory.getLogger(AbstractJerseyEurekaHttpClient.class); /** * jersey1 http 客户端，负责底层发送http请求 */ protected final Client jerseyClient; /** * server url */ protected final String serviceUrl; protected AbstractJerseyEurekaHttpClient(Client jerseyClient, String serviceUrl) &#123; this.jerseyClient = jerseyClient; this.serviceUrl = serviceUrl; logger.debug(\"Created client for url: &#123;&#125;\", serviceUrl); &#125; /** * 服务注册 * @param info * @return */ @Override public EurekaHttpResponse&lt;Void&gt; register(InstanceInfo info) &#123; String urlPath = \"apps/\" + info.getAppName(); ClientResponse response = null; try &#123; //通过HTTP客户端发送http请求 Builder resourceBuilder = jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder(); addExtraHeaders(resourceBuilder); //构建响应结果 response = resourceBuilder .header(\"Accept-Encoding\", \"gzip\") .type(MediaType.APPLICATION_JSON_TYPE) .accept(MediaType.APPLICATION_JSON) .post(ClientResponse.class, info); return anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build(); &#125; finally &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Jersey HTTP POST &#123;&#125;/&#123;&#125; with instance &#123;&#125;; statusCode=&#123;&#125;\", serviceUrl, urlPath, info.getId(), response == null ? \"N/A\" : response.getStatus()); &#125; if (response != null) &#123; response.close(); &#125; &#125; &#125; 1.通过构建函数 可以看到传入一个jersey1 http 客户端 register方法 实际是通过jersey1HttpClient发送http底层请求 在这里可以看到AbstractJerseyEurekaHttpClient实际上是不做底层通讯的工作的，全部都是交由com.sun.jersey.api.client.Client处理的，这个是在创建工厂创建时设置到AbstractJerseyEurekaHttpClient中的 备注: AbstractJersey2EurekaHttpClient与AbstractJerseyEurekaHttpClient的实现原理基本一样只是底层通讯的client不一致，后边不在描述 EurekaHttpClient Top Level部分 EurekaHttpClientDecorator 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * 抽象Eureka远程通讯客户端装饰器，使用设计模式-装饰器模式 为客户端添加新的功能 * @author Tomasz Bak */public abstract class EurekaHttpClientDecorator implements EurekaHttpClient &#123; /** * 请求类型 */ public enum RequestType &#123; //注册 Register, //下线 Cancel, //心跳 SendHeartBeat, //状态更新 StatusUpdate, DeleteStatusOverride, GetApplications, GetDelta, GetVip, GetSecureVip, GetApplication, GetInstance, GetApplicationInstance &#125; /** * 请求执行接口，负责执行请求 * @param &lt;R&gt; */ public interface RequestExecutor&lt;R&gt; &#123; /** * 执行请求并返回响应信息 * @param delegate 目标的客户端 * @return */ EurekaHttpResponse&lt;R&gt; execute(EurekaHttpClient delegate); /** * 请求的类型 * @return */ RequestType getRequestType(); &#125; /** * 抽象的执行方法，由子装饰器实现，附加其它功能 * @param requestExecutor * @param &lt;R&gt; * @return */ protected abstract &lt;R&gt; EurekaHttpResponse&lt;R&gt; execute(RequestExecutor&lt;R&gt; requestExecutor); @Override public EurekaHttpResponse&lt;Void&gt; register(final InstanceInfo info) &#123; //创建一个注册请求的执行器，并执行 return execute(new RequestExecutor&lt;Void&gt;() &#123; @Override public EurekaHttpResponse&lt;Void&gt; execute(EurekaHttpClient delegate) &#123; return delegate.register(info); &#125; @Override public RequestType getRequestType() &#123; return RequestType.Register; &#125; &#125;); &#125; @Override public EurekaHttpResponse&lt;Void&gt; cancel(final String appName, final String id) &#123; //创建一个下线请求的执行，并执行 return execute(new RequestExecutor&lt;Void&gt;() &#123; @Override public EurekaHttpResponse&lt;Void&gt; execute(EurekaHttpClient delegate) &#123; return delegate.cancel(appName, id); &#125; @Override public RequestType getRequestType() &#123; return RequestType.Cancel; &#125; &#125;); &#125; 基础的包装器 主要完成如下功能 实现EurekaHttpClient接口每个基础方法，都有如下流程 创建一个请求执行接口 通过调用抽象的execute方法将RequestExecutor传入 子类在RequestExecutor执行前或后完成新功能的附加 EurekaHttpClientDecorator实现 实现类 描述 MetricsCollectingEurekaHttpClient 实现请求响应状态指标采集的Eureka远程通讯客户端装饰器，为EurekaHttpClient添加响应状态指标采集向功能 RedirectingEurekaHttpClient 实现请求重定向的Eureka远程通讯客户端装饰器，为EurekaHttpClient添加请求重定向功能 RetryableEurekaHttpClient 实现请求失败重试的Eureka远程通讯客户端装饰器，为EurekaHttpClient添加失败重试功能 SessionedEurekaHttpClient TODO 从以上来看eureka 通讯模块结构和功能还是非常明了清晰，同时后期如果需要扩展，也是非常方便与快捷的","categories":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"Eureka","slug":"Eureka","permalink":"https://guofazhan.github.io/tags/Eureka/"}]},{"title":"Eureka之REST API","slug":"Eureka之REST-API-1","date":"2018-08-23T09:50:00.000Z","updated":"2018-08-23T11:33:14.319Z","comments":true,"path":"2018/08/23/Eureka之REST-API-1/","link":"","permalink":"https://guofazhan.github.io/2018/08/23/Eureka之REST-API-1/","excerpt":"Eureka服务端与客户之间的通讯方式为http，服务端通过提供rest API风格的接口与客户端或其它服务端交互。 交互数据格式 JSON/XML 提供资源服务的包路径 com.netflix.eureka.resources","text":"Eureka服务端与客户之间的通讯方式为http，服务端通过提供rest API风格的接口与客户端或其它服务端交互。 交互数据格式 JSON/XML 提供资源服务的包路径 com.netflix.eureka.resources 提供可使用的REST API接口 /{version}/apps 路径 /{version}/instances 路径 /{version}/status 路径 /{version}/peerreplication 路径 /{version}/vips 路径 /{version}/svips 路径","categories":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"Eureka","slug":"Eureka","permalink":"https://guofazhan.github.io/tags/Eureka/"}]},{"title":"Eureka之服务注册数据模型","slug":"Eureka之服务注册数据模型","date":"2018-08-23T09:43:00.000Z","updated":"2018-08-23T11:33:43.847Z","comments":true,"path":"2018/08/23/Eureka之服务注册数据模型/","link":"","permalink":"https://guofazhan.github.io/2018/08/23/Eureka之服务注册数据模型/","excerpt":"Eureka 作为注册中心，担任着服务节点的注册以及发现，并提供着动态的管理（坏点摘除，服务检测等）。可以说是整个系统的基础设施。 注册列表的数据模型","text":"Eureka 作为注册中心，担任着服务节点的注册以及发现，并提供着动态的管理（坏点摘除，服务检测等）。可以说是整个系统的基础设施。 注册列表的数据模型 1. Applications 注册列表，包含注册到当前注册中心上的所有实例信息，每个注册中心在内存中保持一份数据。在Applications中持有Application的队列 2. Application 注册到注册中心的服务集群信息，Application可以看做为一组对外提供相同服务的集群列表。在Application包含一组提供相同服务的InstanceInfo集合 3. InstanceInfo 注册列表里的单个服务实例信息，代表系统中提供一项服务的某个节点，里面包含节点的基础信息，以及唯一标识instanceId。 4. DataCenterInfo 服务实例所在的数据中心，默认为MyOwn，为InstanceInfo子属性 5. LeaseInfo 服务实例的租约信息，用于对服务做健康检查，续租，过期等服务可用性的管理。为InstanceInfo子属性 通过数据模型图可以清楚的看到Eureka将我们系统中的服务信息抽象成5个对象进行精细化的管理。我们注册进去的服务信息都将实例化成上述对象存储在eureka的服务端内存中，从而对外提供服务的注册以及发现。","categories":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"Eureka","slug":"Eureka","permalink":"https://guofazhan.github.io/tags/Eureka/"}]},{"title":"Eureka之server端集群节点发现，数据同步","slug":"Eureka之server端集群节点发现，数据同步-1","date":"2018-08-23T09:36:00.000Z","updated":"2018-08-23T11:34:19.091Z","comments":true,"path":"2018/08/23/Eureka之server端集群节点发现，数据同步-1/","link":"","permalink":"https://guofazhan.github.io/2018/08/23/Eureka之server端集群节点发现，数据同步-1/","excerpt":"Eureka服务端支持集群部署，通过源码查看集群节点发现以及数据同步功能的实现 提供集群功能的包路径 com.netflix.eureka.cluster 集群节点发现以及动态更新节点功能 Eureka服务端封装了一个集群节点管理的类名称为PeerEurekaNodes 通过名称翻译出来为对等的Eureka节点集合，可以看出这个类是对eureka服务端集群节点抽象，下面通过源码查询eureka是怎么管理与发现节点信息 123456789101112131415161718192021/** * eureka server 集群节点 集合类 帮助管理维护集群节点 * Helper class to manage lifecycle of a collection of &#123;@link PeerEurekaNode&#125;s. * * @author Tomasz Bak */@Singletonpublic class PeerEurekaNodes &#123; /** * 集群节点集合 */ private volatile List&lt;PeerEurekaNode&gt; peerEurekaNodes = Collections.emptyList(); /** * 集群节点URL集合 */ private volatile Set&lt;String&gt; peerEurekaNodeUrls = Collections.emptySet(); /** * 定时任务线程池 */ private ScheduledExecutorService taskExecutor; 通过PeerEurekaNodes类属性可以看到提供了两个集合以及一个执行定时任务的线程池，其它配置属性忽略 peerEurekaNodes 表示集群节点集合 peerEurekaNodeUrls 表示集群节点对应的URL集合 taskExecutor 执行定时任务的线程池","text":"Eureka服务端支持集群部署，通过源码查看集群节点发现以及数据同步功能的实现 提供集群功能的包路径 com.netflix.eureka.cluster 集群节点发现以及动态更新节点功能 Eureka服务端封装了一个集群节点管理的类名称为PeerEurekaNodes 通过名称翻译出来为对等的Eureka节点集合，可以看出这个类是对eureka服务端集群节点抽象，下面通过源码查询eureka是怎么管理与发现节点信息 123456789101112131415161718192021/** * eureka server 集群节点 集合类 帮助管理维护集群节点 * Helper class to manage lifecycle of a collection of &#123;@link PeerEurekaNode&#125;s. * * @author Tomasz Bak */@Singletonpublic class PeerEurekaNodes &#123; /** * 集群节点集合 */ private volatile List&lt;PeerEurekaNode&gt; peerEurekaNodes = Collections.emptyList(); /** * 集群节点URL集合 */ private volatile Set&lt;String&gt; peerEurekaNodeUrls = Collections.emptySet(); /** * 定时任务线程池 */ private ScheduledExecutorService taskExecutor; 通过PeerEurekaNodes类属性可以看到提供了两个集合以及一个执行定时任务的线程池，其它配置属性忽略 peerEurekaNodes 表示集群节点集合 peerEurekaNodeUrls 表示集群节点对应的URL集合 taskExecutor 执行定时任务的线程池 同时 PeerEurekaNodes 类提供start 与shutdown方法，接下来主要看start方法的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 /** * 启动方法，此方法管理集群节点间的通讯 */ public void start() &#123; //初始化定时任务线程池 taskExecutor = Executors.newSingleThreadScheduledExecutor( new ThreadFactory() &#123; @Override public Thread newThread(Runnable r) &#123; Thread thread = new Thread(r, \"Eureka-PeerNodesUpdater\"); thread.setDaemon(true); return thread; &#125; &#125; ); try &#123; updatePeerEurekaNodes(resolvePeerUrls()); //节点更新任务线程 Runnable peersUpdateTask = new Runnable() &#123; @Override public void run() &#123; try &#123; updatePeerEurekaNodes(resolvePeerUrls()); &#125; catch (Throwable e) &#123; logger.error(\"Cannot update the replica Nodes\", e); &#125; &#125; &#125;;// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。// 如果任务的任一执行遇到异常，就会取消后续执行。否则，只能通过执行程序的取消或终止方法来终止该任务。// 参数：// command - 要执行的任务// initialdelay - 首次执行的延迟时间// delay - 一次执行终止和下一次执行开始之间的延迟// unit - initialdelay 和 delay 参数的时间单位 //定时执行节点更新任务线程 taskExecutor.scheduleWithFixedDelay( peersUpdateTask, serverConfig.getPeerEurekaNodesUpdateIntervalMs(), serverConfig.getPeerEurekaNodesUpdateIntervalMs(), TimeUnit.MILLISECONDS ); &#125; catch (Exception e) &#123; throw new IllegalStateException(e); &#125; for (PeerEurekaNode node : peerEurekaNodes) &#123; logger.info(\"Replica node URL: \" + node.getServiceUrl()); &#125; &#125; start 方法主要完成以下几件事 初始化定时任务线程池 首次更新集群节点 updatePeerEurekaNodes方法 创建更新集群节点任务线程 通过定时任务线程池定时执行更新集群节点线程 通过start 可以看出 eureka是通过一个定时线程定时去更新集群的节点信息达到对集群节点的动态发现和感知，在上面我们可以看到更新操作主要由updatePeerEurekaNodes方法完成，下面查看此方法的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647protected void updatePeerEurekaNodes(List&lt;String&gt; newPeerUrls) &#123; if (newPeerUrls.isEmpty()) &#123; logger.warn(\"The replica size seems to be empty. Check the route 53 DNS Registry\"); return; &#125; Set&lt;String&gt; toShutdown = new HashSet&lt;&gt;(peerEurekaNodeUrls); toShutdown.removeAll(newPeerUrls); Set&lt;String&gt; toAdd = new HashSet&lt;&gt;(newPeerUrls); toAdd.removeAll(peerEurekaNodeUrls); //校验新的URL集合与旧有的URL集合是否一致，一致，不需要更新直接返回 if (toShutdown.isEmpty() &amp;&amp; toAdd.isEmpty()) &#123; // No change return; &#125; // Remove peers no long available List&lt;PeerEurekaNode&gt; newNodeList = new ArrayList&lt;&gt;(peerEurekaNodes); //移除旧集合中不可用的节点信息 if (!toShutdown.isEmpty()) &#123; logger.info(\"Removing no longer available peer nodes &#123;&#125;\", toShutdown); int i = 0; while (i &lt; newNodeList.size()) &#123; PeerEurekaNode eurekaNode = newNodeList.get(i); if (toShutdown.contains(eurekaNode.getServiceUrl())) &#123; newNodeList.remove(i); eurekaNode.shutDown(); &#125; else &#123; i++; &#125; &#125; &#125; //添加新增加的节点信息 // Add new peers if (!toAdd.isEmpty()) &#123; logger.info(\"Adding new peer nodes &#123;&#125;\", toAdd); for (String peerUrl : toAdd) &#123; newNodeList.add(createPeerEurekaNode(peerUrl)); &#125; &#125; //重新赋值peerEurekaNodes与peerEurekaNodeUrls this.peerEurekaNodes = newNodeList; this.peerEurekaNodeUrls = new HashSet&lt;&gt;(newPeerUrls);&#125; updatePeerEurekaNodes根据传入的新集群URL集合完成节点的更新 校验传入的URL集合是否需要更新 移除新url集合中没有的旧节点并关闭节点 创建旧节点集合中没有的新URL节点通过createPeerEurekaNode方法 重新赋值节点集合以及URL集合完成节点的更新 updatePeerEurekaNodes传入的新URL集合是通过resolvePeerUrls方法获取，这个方法实际上是解析配置文件中的eureka.serviceUrl前缀的配置获取，并动态监听配置的更新。 创建新的节点是通过createPeerEurekaNode创建，下面查看此方法源码 12345678910111213141516/** * 根据URL创建server新节点信息 * @param peerEurekaNodeUrl * @return */protected PeerEurekaNode createPeerEurekaNode(String peerEurekaNodeUrl) &#123; //创建一个连接远程节点的客户端 HttpReplicationClient replicationClient = JerseyReplicationClient.createReplicationClient(serverConfig, serverCodecs, peerEurekaNodeUrl); //获取新节点host信息 String targetHost = hostFromUrl(peerEurekaNodeUrl); if (targetHost == null) &#123; targetHost = \"host\"; &#125; //创建新节点 return new PeerEurekaNode(registry, targetHost, peerEurekaNodeUrl, replicationClient, serverConfig);&#125; PeerEurekaNode 方法 创建远程通讯客户端replicationClient 用户与此节点间通讯，数据同步等工作 获取要创建的远程节点的host 创建一个表示远程节点实例 PeerEurekaNode PeerEurekaNode 表示一个与当前节点对等的远程节点，当前节点与远程节点的数据同步工作都是在此实例中完成的。 集群节点数据同步 在上面节点发现中知道eureka是通过PeerEurekaNode表示远程对等接点，并将远程通讯客户端replicationClient传入到PeerEurekaNode中，接下来通过查看PeerEurekaNode源码来看eureka集群节点间都有那些数据需要同步以及通讯内容 1234567891011121314151617181920212223242526272829/* For testing */ PeerEurekaNode(PeerAwareInstanceRegistry registry, String targetHost, String serviceUrl, HttpReplicationClient replicationClient, EurekaServerConfig config, int batchSize, long maxBatchingDelayMs, long retrySleepTimeMs, long serverUnavailableSleepTimeMs) &#123; String batcherName = getBatcherName(); //任务处理器 ReplicationTaskProcessor taskProcessor = new ReplicationTaskProcessor(targetHost, replicationClient); //创建一个批量执行的任务调度器 this.batchingDispatcher = TaskDispatchers.createBatchingTaskDispatcher( batcherName, config.getMaxElementsInPeerReplicationPool(), batchSize, config.getMaxThreadsForPeerReplication(), maxBatchingDelayMs, serverUnavailableSleepTimeMs, retrySleepTimeMs, taskProcessor ); //创建一个单任务调度器 this.nonBatchingDispatcher = TaskDispatchers.createNonBatchingTaskDispatcher( targetHost, config.getMaxElementsInStatusReplicationPool(), config.getMaxThreadsForStatusReplication(), maxBatchingDelayMs, serverUnavailableSleepTimeMs, retrySleepTimeMs, taskProcessor );&#125; PeerEurekaNode 完成以下事件 创建数据同步的任务处理器ReplicationTaskProcessor 创建批处理任务调度器 创建单任务处理调度器 说明: eureka将节点间的数据同步工作包装成一个个细微的任务ReplicationTask ，每一个数据操作代表一个任务，将任务发送给任务调度器TaskDispatcher去异步处理。 下来查看PeerEurekaNode都可以创建那些同步任务 register 1234567891011121314151617181920212223/** * 当eureka server注册新服务时，同时创建一个定时任务将新服务同步到集群其它节点 * Sends the registration information of &#123;@link InstanceInfo&#125; receiving by * this node to the peer node represented by this class. * * @param info * the instance information &#123;@link InstanceInfo&#125; of any instance * that is send to this instance. * @throws Exception */public void register(final InstanceInfo info) throws Exception &#123; long expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info); //任务调度器中添加一个请求类型为注册register新服务的同步任务 batchingDispatcher.process( taskId(\"register\", info), new InstanceReplicationTask(targetHost, Action.Register, info, null, true) &#123; public EurekaHttpResponse&lt;Void&gt; execute() &#123; return replicationClient.register(info); &#125; &#125;, expiryTime );&#125; 注册同步任务，当有服务注册到当前节点时，通过注册同步任务将服务信息同步到集群远程节点 cancel 12345678910111213141516171819202122public void cancel(final String appName, final String id) throws Exception &#123; long expiryTime = System.currentTimeMillis() + maxProcessingDelayMs; //任务调度器中添加一个请求类型为取消cancel服务的同步任务 batchingDispatcher.process( taskId(\"cancel\", appName, id), new InstanceReplicationTask(targetHost, Action.Cancel, appName, id) &#123; @Override public EurekaHttpResponse&lt;Void&gt; execute() &#123; return replicationClient.cancel(appName, id); &#125; @Override public void handleFailure(int statusCode, Object responseEntity) throws Throwable &#123; super.handleFailure(statusCode, responseEntity); if (statusCode == 404) &#123; logger.warn(\"&#123;&#125;: missing entry.\", getTaskName()); &#125; &#125; &#125;, expiryTime ); &#125; 取消服务注册任务，当前节点有服务取消注册，将信息同步到集群远程节点 heartbeat 1234567891011121314151617181920212223242526272829303132333435363738public void heartbeat(final String appName, final String id, final InstanceInfo info, final InstanceStatus overriddenStatus, boolean primeConnection) throws Throwable &#123; //当第一次连接时直接发送心跳到远端 if (primeConnection) &#123; // We do not care about the result for priming request. replicationClient.sendHeartBeat(appName, id, info, overriddenStatus); return; &#125; //心跳同步任务 ReplicationTask replicationTask = new InstanceReplicationTask(targetHost, Action.Heartbeat, info, overriddenStatus, false) &#123; @Override public EurekaHttpResponse&lt;InstanceInfo&gt; execute() throws Throwable &#123; return replicationClient.sendHeartBeat(appName, id, info, overriddenStatus); &#125; @Override public void handleFailure(int statusCode, Object responseEntity) throws Throwable &#123; super.handleFailure(statusCode, responseEntity); if (statusCode == 404) &#123; logger.warn(&quot;&#123;&#125;: missing entry.&quot;, getTaskName()); if (info != null) &#123; logger.warn(&quot;&#123;&#125;: cannot find instance id &#123;&#125; and hence replicating the instance with status &#123;&#125;&quot;, getTaskName(), info.getId(), info.getStatus()); register(info); &#125; &#125; else if (config.shouldSyncWhenTimestampDiffers()) &#123; InstanceInfo peerInstanceInfo = (InstanceInfo) responseEntity; if (peerInstanceInfo != null) &#123; syncInstancesIfTimestampDiffers(appName, id, info, peerInstanceInfo); &#125; &#125; &#125; &#125;; long expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info); //任务调度器中添加一个请求类型为heartbeat服务的同步任务 batchingDispatcher.process(taskId(&quot;heartbeat&quot;, info), replicationTask, expiryTime);&#125; 心跳同步任务，当前节点有服务发送心跳续租，将信息同步到集群远程节点 StatusUpdate DeleteStatusOverride 集群节点数据同步任务处理 在PeerEurekaNode的构造函数中可以看到同步任务处理由ReplicationTaskProcessor完成，下面看此类源码 123456789101112131415161718192021222324252627282930313233343536/** * 单个处理ReplicationTask任务 * @param task * @return */ @Override public ProcessingResult process(ReplicationTask task) &#123; try &#123; //调用任务execute方法，完成任务的执行 EurekaHttpResponse&lt;?&gt; httpResponse = task.execute(); int statusCode = httpResponse.getStatusCode(); //判断任务返回结果 Object entity = httpResponse.getEntity(); if (logger.isDebugEnabled()) &#123; logger.debug(\"Replication task &#123;&#125; completed with status &#123;&#125;, (includes entity &#123;&#125;)\", task.getTaskName(), statusCode, entity != null); &#125; if (isSuccess(statusCode)) &#123; task.handleSuccess(); &#125; else if (statusCode == 503) &#123; logger.debug(\"Server busy (503) reply for task &#123;&#125;\", task.getTaskName()); return ProcessingResult.Congestion; &#125; else &#123; task.handleFailure(statusCode, entity); return ProcessingResult.PermanentError; &#125; &#125; catch (Throwable e) &#123; if (isNetworkConnectException(e)) &#123; logNetworkErrorSample(task, e); return ProcessingResult.TransientError; &#125; else &#123; logger.error(peerId + \": \" + task.getTaskName() + \"Not re-trying this exception because it does not seem to be a network exception\", e); return ProcessingResult.PermanentError; &#125; &#125; return ProcessingResult.Success; &#125; 单任务处理 调用任务task的execute完成远程数据同步 分析远程返回结果 12345678910111213141516171819202122232425262728293031323334353637/** * 批量处理ReplicationTask任务 * @param tasks * @return */ @Override public ProcessingResult process(List&lt;ReplicationTask&gt; tasks) &#123; //根据task集合创建ReplicationList ReplicationList list = createReplicationListOf(tasks); try &#123; //调用批量同步接口 将同步集合发送到远端节点同步数据 EurekaHttpResponse&lt;ReplicationListResponse&gt; response = replicationClient.submitBatchUpdates(list); //判断同步返回结果 int statusCode = response.getStatusCode(); if (!isSuccess(statusCode)) &#123; if (statusCode == 503) &#123; logger.warn(\"Server busy (503) HTTP status code received from the peer &#123;&#125;; rescheduling tasks after delay\", peerId); return ProcessingResult.Congestion; &#125; else &#123; // Unexpected error returned from the server. This should ideally never happen. logger.error(\"Batch update failure with HTTP status code &#123;&#125;; discarding &#123;&#125; replication tasks\", statusCode, tasks.size()); return ProcessingResult.PermanentError; &#125; &#125; else &#123; handleBatchResponse(tasks, response.getEntity().getResponseList()); &#125; &#125; catch (Throwable e) &#123; if (isNetworkConnectException(e)) &#123; logNetworkErrorSample(null, e); return ProcessingResult.TransientError; &#125; else &#123; logger.error(\"Not re-trying this exception because it does not seem to be a network exception\", e); return ProcessingResult.PermanentError; &#125; &#125; return ProcessingResult.Success; &#125; 批处理任务，将一组任务一次性发送到远程进行处理 根据task集合创建ReplicationList 调用批量同步接口将同步集合发送到远端节点同步数据 即调用rest API /{version}/peerreplication 分析远程返回结果 eureka 服务端 集群节点发现，数据同步功能主要是由PeerEurekaNodes与PeerEurekaNode类实现,通过源码的跟踪可以清晰看出集群实现的逻辑，方便在实际应用中对问题的定位","categories":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"Eureka","slug":"Eureka","permalink":"https://guofazhan.github.io/tags/Eureka/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-23T06:37:01.950Z","updated":"2018-08-23T06:37:01.951Z","comments":true,"path":"2018/08/23/hello-world/","link":"","permalink":"https://guofazhan.github.io/2018/08/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}