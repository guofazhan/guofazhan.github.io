{"meta":{"title":"Mr.G-博客","subtitle":"博客","description":"学习分享、源码阅读、笔记","author":"Mr.G","url":"https://guofazhan.github.io"},"pages":[{"title":"","date":"2018-08-23T11:32:07.768Z","updated":"2018-08-23T11:32:07.720Z","comments":true,"path":"about/index.html","permalink":"https://guofazhan.github.io/about/index.html","excerpt":"","text":"关于 作者：guofazhan 邮箱：guofazhan@hotmail.com"}],"posts":[{"title":"Eureka之服务发现LookupService","slug":"Eureka之服务发现LookupService","date":"2018-08-28T11:38:00.000Z","updated":"2018-08-28T03:42:55.877Z","comments":true,"path":"2018/08/28/Eureka之服务发现LookupService/","link":"","permalink":"https://guofazhan.github.io/2018/08/28/Eureka之服务发现LookupService/","excerpt":"Eureka 注册中心，核心为提供服务注册，以及服务发现功能，下面我们重点讨论下Eureka核心功能之一的服务发现。我们知道Eureka采用的C-S架构，客户端要通过请求服务端获取注册列表，提供给服务使用，服务端要保存客户端发来的注册信息保存下（Eureka采用的是内存存储），并提供给资源服务Resources使用，有关资源服务可见Eureka之REST API","text":"Eureka 注册中心，核心为提供服务注册，以及服务发现功能，下面我们重点讨论下Eureka核心功能之一的服务发现。我们知道Eureka采用的C-S架构，客户端要通过请求服务端获取注册列表，提供给服务使用，服务端要保存客户端发来的注册信息保存下（Eureka采用的是内存存储），并提供给资源服务Resources使用，有关资源服务可见Eureka之REST API LookupService体系图 InstanceRegistry为Server端对资源服务提供服务发现功能的接口，用来读取服务端本地缓存注册表信息 EurekaClient 为Client端实现的服务发现接口，用来获取客户端本地缓存中的注册表信息 RemoteRegionRegistry 为Server用来读取其它区域的服务注册表的接口，并将其它区域的服务注册表缓存到本地，供本地InstanceRegistry使用。 Eureka区域，分区 eureka提供了region和zone两个概念来进行分区，这两个概念均来自于亚马逊的AWS： region：可以简单理解为地理上的分区，比如亚洲地区，或者华北地区，再或者北京等等，没有具体大小的限制。根据项目具体的情况，可以自行合理划分region。RemoteRegionRegistry就是其它分区的服务注册信息。 zone：可以简单理解为region内的具体机房，比如说region划分为北京，然后北京有两个机房，就可以在此region之下划分出zone1,zone2两个zone。 RemoteRegionRegistry 根据配置实例化： 配置KEY： eureka.remoteRegionUrlsWithName 格式： eureka.remoteRegionUrlsWithName=region1;http://region1host/eureka/v2,region2;http://region2host/eureka/v2 解析: regionName-&gt;remoteRegionURL 根据解析出来的MAP 创建相应的 RemoteRegionRegistry 备注： 一般中小行项目基本所有服务都部署在同一机房，不存在区域划分这些，即初始化时:RemoteRegionRegistry List为空,具体可参见AbstractInstanceRegistry的initRemoteRegionRegistry方法 LookupService类图以及实现 服务发现LookupService接口1234567891011121314151617181920212223242526272829303132333435363738394041/** * 服务发现接口 * Lookup service for finding active instances. * * @author Karthik Ranganathan, Greg Kim. * @param &lt;T&gt; for backward compatibility */public interface LookupService&lt;T&gt; &#123; /** * 根据集群ID获取集群列表 * Returns the corresponding &#123;@link Application&#125; object which is basically a * container of all registered &lt;code&gt;appName&lt;/code&gt; &#123;@link InstanceInfo&#125;s. * * @param appName * @return a &#123;@link Application&#125; or null if we couldn't locate any app of * the requested appName */ Application getApplication(String appName); /** * 获取服务注册列表 * Returns the &#123;@link Applications&#125; object which is basically a container of * all currently registered &#123;@link Application&#125;s. * * @return &#123;@link Applications&#125; */ Applications getApplications(); /** * 根据实例ID获取实例信息 */ List&lt;InstanceInfo&gt; getInstancesById(String id); /** * 轮询获取集群中的下一个可用的注册服务，起到负载均衡作用，保证每个可用注册服务均衡的被使用，此方法仅提供个Eureka 客户端使用实现，服务端默认为空实现 * Gets the next possible server to process the requests from the registry * information received from eureka. */ InstanceInfo getNextServerFromEureka(String virtualHostname, boolean secure); 从接口可以看到提供了四个功能方法如下： getApplication:根据集群ID获取集群列表 getApplications:获取服务注册列表 getInstancesById:根据实例ID获取实例信息 getNextServerFromEureka:轮询获取集群中的下一个可用的注册服务，起到负载均衡作用，保证每个可用注册服务均衡的被使用，此方法仅提供个Eureka 客户端使用实现，服务端默认为空实现 服务端实现AbstractInstanceRegistry 缓存服务注册属性 123456/** * 服务注册表 */ private final ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; registry = new ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;(); 其它区域服务发现集合属性 1234/** * 远程区域服务发现注册服务集合 */protected Map&lt;String, RemoteRegionRegistry&gt; regionNameVSRemoteRegistry = new HashMap&lt;String, RemoteRegionRegistry&gt;(); getApplications功能方法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** * 获取服务注册列表信息 * Get all applications in this instance registry, falling back to other regions if allowed in the Eureka config. * * @return the list of all known applications * * @see com.netflix.discovery.shared.LookupService#getApplications() */public Applications getApplications() &#123; //配置参数，是否禁用远程区域的服务注册列表 boolean disableTransparentFallback = serverConfig.disableTransparentFallbackToOtherRegion(); if (disableTransparentFallback) &#123; //获取本地服务注册列表 return getApplicationsFromLocalRegionOnly(); &#125; else &#123; //获取服务注册列表在所有区域中，包含本地 return getApplicationsFromAllRemoteRegions(); // Behavior of falling back to remote region can be disabled. &#125;&#125; /** * 获服务注册列表,在所有区域 * Returns applications including instances from all remote regions. &lt;br/&gt; * Same as calling &#123;@link #getApplicationsFromMultipleRegions(String[])&#125; with a &lt;code&gt;null&lt;/code&gt; argument. */public Applications getApplicationsFromAllRemoteRegions() &#123; //根据区域信息获取服务注册列表，此处区域列表传入所有远程区域列表 return getApplicationsFromMultipleRegions(allKnownRemoteRegions);&#125;/** * 获取本地服务注册列表 * Returns applications including instances from local region only. &lt;br/&gt; * Same as calling &#123;@link #getApplicationsFromMultipleRegions(String[])&#125; with an empty array. */@Overridepublic Applications getApplicationsFromLocalRegionOnly() &#123; //根据区域信息获取服务注册列表，此处区域列表传入空值 return getApplicationsFromMultipleRegions(EMPTY_STR_ARRAY);&#125; /** * 根据区域信息查询服务注册列表 */public Applications getApplicationsFromMultipleRegions(String[] remoteRegions) &#123; //是否根据远程区域查询服务注册列表标识 boolean includeRemoteRegion = null != remoteRegions &amp;&amp; remoteRegions.length != 0; logger.debug(\"Fetching applications registry with remote regions: &#123;&#125;, Regions argument &#123;&#125;\", includeRemoteRegion, Arrays.toString(remoteRegions)); //记录统计监控数据 if (includeRemoteRegion) &#123; GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS.increment(); &#125; else &#123; GET_ALL_CACHE_MISS.increment(); &#125; //构建服务注册列表实例信息 Applications apps = new Applications(); apps.setVersion(1L); //加入本地注册信息到服务注册列表实例中 for (Entry&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; entry : registry.entrySet()) &#123; Application app = null; if (entry.getValue() != null) &#123; for (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; stringLeaseEntry : entry.getValue().entrySet()) &#123; Lease&lt;InstanceInfo&gt; lease = stringLeaseEntry.getValue(); if (app == null) &#123; app = new Application(lease.getHolder().getAppName()); &#125; app.addInstance(decorateInstanceInfo(lease)); &#125; &#125; if (app != null) &#123; apps.addApplication(app); &#125; &#125; //是否加入远程区域的注册信息 if (includeRemoteRegion) &#123; //遍历远程区域，添加远程区域的注册信息到服务注册列表实例 for (String remoteRegion : remoteRegions) &#123; RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion); if (null != remoteRegistry) &#123; Applications remoteApps = remoteRegistry.getApplications(); for (Application application : remoteApps.getRegisteredApplications()) &#123; if (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) &#123; logger.info(\"Application &#123;&#125; fetched from the remote region &#123;&#125;\", application.getName(), remoteRegion); Application appInstanceTillNow = apps.getRegisteredApplications(application.getName()); if (appInstanceTillNow == null) &#123; appInstanceTillNow = new Application(application.getName()); apps.addApplication(appInstanceTillNow); &#125; for (InstanceInfo instanceInfo : application.getInstances()) &#123; appInstanceTillNow.addInstance(instanceInfo); &#125; &#125; else &#123; logger.debug(\"Application &#123;&#125; not fetched from the remote region &#123;&#125; as there exists a \" + \"whitelist and this app is not in the whitelist.\", application.getName(), remoteRegion); &#125; &#125; &#125; else &#123; logger.warn(\"No remote registry available for the remote region &#123;&#125;\", remoteRegion); &#125; &#125; &#125; //设置实例的hashCode apps.setAppsHashCode(apps.getReconcileHashCode()); return apps;&#125; getApplications功能主要由以下方法完成： getApplications : 此方法根据配置参数信息，判断是只从本地缓存中获取注册列表(getApplicationsFromLocalRegionOnly)还是从所以区域获取注册列表(getApplicationsFromAllRemoteRegions)，参数信息：disableTransparentFallback getApplicationsFromLocalRegionOnly :获取本地缓存中的注册表信息，调用getApplicationsFromMultipleRegions传入空区域集合 getApplicationsFromAllRemoteRegions : 从所有区域查找注册表信息，传入全部区域集合。 getApplicationsFromMultipleRegions ：根据传入区域信息查询注册表信息 getApplicationsFromMultipleRegions完成如下功能: 构建空注册表实例：Applications 添加本地缓存的注册信息到Applications 判断是否查找其它区域 遍历其它区域RemoteRegionRegistry获取Applications 添加其它区域中注册的信息到Applications（剔除重复的） 设置apps的hashCode 用于增量更新 getApplications功能方法实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 根据服务集群ID，查询服务集群列表 * * @param appName the application name of the application * @return the application * * @see com.netflix.discovery.shared.LookupService#getApplication(java.lang.String) */@Overridepublic Application getApplication(String appName) &#123; //获取配置信息 //配置参数，是否禁用远程区域的服务注册列表 boolean disableTransparentFallback = serverConfig.disableTransparentFallbackToOtherRegion(); return this.getApplication(appName, !disableTransparentFallback);&#125;/** * 根据服务集群ID，查询服务集群列表 * Get application information. * @return the application */@Overridepublic Application getApplication(String appName, boolean includeRemoteRegion) &#123; Application app = null; //获取本地注册列表中的服务集群信息 Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseMap = registry.get(appName); if (leaseMap != null &amp;&amp; leaseMap.size() &gt; 0) &#123; //构建集群实例Application for (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; entry : leaseMap.entrySet()) &#123; if (app == null) &#123; app = new Application(appName); &#125; app.addInstance(decorateInstanceInfo(entry.getValue())); &#125; &#125; else if (includeRemoteRegion) &#123; //包含远程区域时，通过远程区域注册服务查询集群信息 for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) &#123; Application application = remoteRegistry.getApplication(appName); if (application != null) &#123; return application; &#125; &#125; &#125; //返回集群实例 return app;&#125; getApplication功能主要由以下方法完成：getApplication ： 根据 集群名称以及参数是否禁用其它区域来获取集群列表Application 通过本地缓存注册信息获取组装集群实例Application 当本地缓存中未查到集群信息且可用远程区域发现服务查询时，遍历远程区域发现服务查询集群信息组装集群实例Application 返回集群实例Application getInstancesById功能方法实现 与4功能类似 getNextServerFromEureka功能方法实现 空实现 客户端实现DiscoveryClient1234567891011121314151617181920212223242526272829303132333435/* * (non-Javadoc) * @see com.netflix.discovery.shared.LookupService#getApplication(java.lang.String) */@Overridepublic Application getApplication(String appName) &#123; return getApplications().getRegisteredApplications(appName);&#125;/* * (non-Javadoc) * * @see com.netflix.discovery.shared.LookupService#getApplications() */@Overridepublic Applications getApplications() &#123; return localRegionApps.get();&#125; /* * (non-Javadoc) * @see com.netflix.discovery.shared.LookupService#getInstancesById(java.lang.String) */@Overridepublic List&lt;InstanceInfo&gt; getInstancesById(String id) &#123; List&lt;InstanceInfo&gt; instancesList = new ArrayList&lt;InstanceInfo&gt;(); for (Application app : this.getApplications() .getRegisteredApplications()) &#123; InstanceInfo instanceInfo = app.getByInstanceId(id); if (instanceInfo != null) &#123; instancesList.add(instanceInfo); &#125; &#125; return instancesList;&#125; 在客户端的实现方法中可以清晰的看到是通过localRegionApps.get()获取服务注册列表实例，此实例是在本地缓存存储且为原子性的。下面我们主要查看localRegionApps是怎么加载以及更新 构造函数首次加载localRegionApps 12345//通过fetchRegistry方法首次从远程Server端获取注册列表缓存到客户端本地，默认选择增量拉取if (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(false)) &#123; fetchRegistryFromBackup();&#125; 在构造函数中调用fetchRegistry 首次初始化从服务端拉取服务注册实例并缓存到客户端内存中 初始化定时任务，定时拉取服务端注册信息刷新本地缓存 12345678910111213141516171819202122232425262728293031323334/** * Initializes all scheduled tasks. */private void initScheduledTasks() &#123; //判断客户端远程拉取注册表禁用配置，true，标识客户端运行定时拉取远程注册表配置 if (clientConfig.shouldFetchRegistry()) &#123; // registry cache refresh timer int registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds(); int expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound(); //定时任务定时执行客户端远程拉取注册表来更新客户端本地缓存 scheduler.schedule( new TimedSupervisorTask( &quot;cacheRefresh&quot;, scheduler, cacheRefreshExecutor, registryFetchIntervalSeconds, TimeUnit.SECONDS, expBackOffBound, new CacheRefreshThread() ), registryFetchIntervalSeconds, TimeUnit.SECONDS); &#125;&#125; /** * 远程拉取Server端注册表信息更新客户端本地缓存，定时任务，客户端定时执行此任务 * The task that fetches the registry information at specified intervals. * */class CacheRefreshThread implements Runnable &#123; public void run() &#123; refreshRegistry(); &#125;&#125; 构造函数初始化定时任务，调用initScheduledTasks 定时任务，初始化刷新服务注册表实例定时任务 CacheRefreshThread线程定时执行，调用refreshRegistry()方法从server端拉取注册信息并刷新本地缓存 fetchRegistry功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/** * 客户端拉取Eureka Server服务注册列表，本地缓存 (forceFullRegistryFetch 是否全量拉取标识) */ private boolean fetchRegistry(boolean forceFullRegistryFetch) &#123; Stopwatch tracer = FETCH_REGISTRY_TIMER.start(); try &#123; // If the delta is disabled or if it is the first time, get all // applications //本地缓存中获取注册列表信息 Applications applications = getApplications(); //判断全量拉取还是增量拉取 if (clientConfig.shouldDisableDelta() || (!Strings.isNullOrEmpty(clientConfig.getRegistryRefreshSingleVipAddress())) || forceFullRegistryFetch || (applications == null) || (applications.getRegisteredApplications().size() == 0) || (applications.getVersion() == -1)) //Client application does not have latest library supporting delta &#123; //全量拉取注册表信息 getAndStoreFullRegistry(); &#125; else &#123; //增量拉取注册表信息 getAndUpdateDelta(applications); &#125; //设置hashCode，注册列表判断变化是根据hashCode applications.setAppsHashCode(applications.getReconcileHashCode()); //日志打印统计 logTotalInstances(); &#125; catch (Throwable e) &#123; logger.error(PREFIX + appPathIdentifier + \" - was unable to refresh its cache! status = \" + e.getMessage(), e); return false; &#125; finally &#123; if (tracer != null) &#123; tracer.stop(); &#125; &#125; //通知缓存刷新事件 // Notify about cache refresh before updating the instance remote status onCacheRefreshed(); //更新实例的远程状态 // Update remote status based on refreshed data held in the cache updateInstanceRemoteStatus(); // registry was fetched successfully, so return true return true; &#125; /** * 全量拉取Eureka Server端的注册列表信息 */ private void getAndStoreFullRegistry() throws Throwable &#123; long currentUpdateGeneration = fetchRegistryGeneration.get(); logger.info(\"Getting all instance registry info from the eureka server\"); Applications apps = null; //通过远程通讯组件请求Server端获取全量注册列表 EurekaHttpResponse&lt;Applications&gt; httpResponse = clientConfig.getRegistryRefreshSingleVipAddress() == null ? eurekaTransport.queryClient.getApplications(remoteRegionsRef.get()) : eurekaTransport.queryClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress(), remoteRegionsRef.get()); if (httpResponse.getStatusCode() == Status.OK.getStatusCode()) &#123; apps = httpResponse.getEntity(); &#125; logger.info(\"The response status is &#123;&#125;\", httpResponse.getStatusCode()); if (apps == null) &#123; logger.error(\"The application is null for some reason. Not storing this information\"); &#125; else if (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + 1)) &#123; //获取的注册列表缓存到本地 localRegionApps.set(this.filterAndShuffle(apps)); logger.debug(\"Got full registry with apps hashcode &#123;&#125;\", apps.getAppsHashCode()); &#125; else &#123; logger.warn(\"Not updating applications as another thread is updating it already\"); &#125; &#125; /** * 增量拉取Eureka Server端的注册列表信息 */ private void getAndUpdateDelta(Applications applications) throws Throwable &#123; long currentUpdateGeneration = fetchRegistryGeneration.get(); Applications delta = null; //通过远程通讯组件请求Server端获取增量注册列表 EurekaHttpResponse&lt;Applications&gt; httpResponse = eurekaTransport.queryClient.getDelta(remoteRegionsRef.get()); if (httpResponse.getStatusCode() == Status.OK.getStatusCode()) &#123; delta = httpResponse.getEntity(); &#125; if (delta == null) &#123; logger.warn(\"The server does not allow the delta revision to be applied because it is not safe. \" + \"Hence got the full registry.\"); //增量获取为空时，全量拉取 getAndStoreFullRegistry(); &#125; else if (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + 1)) &#123; logger.debug(\"Got delta update with apps hashcode &#123;&#125;\", delta.getAppsHashCode()); String reconcileHashCode = \"\"; //拉取注册表更新锁 if (fetchRegistryUpdateLock.tryLock()) &#123; try &#123; //更新增量信息到本地缓存中的注册表中 updateDelta(delta); //获取更新后的HashCode reconcileHashCode = getReconcileHashCode(applications); &#125; finally &#123; fetchRegistryUpdateLock.unlock(); &#125; &#125; else &#123; logger.warn(\"Cannot acquire update lock, aborting getAndUpdateDelta\"); &#125; //判断本地的hashCode是否与远程hashCode一致，不一致时，需要同步一致 // There is a diff in number of instances for some reason if (!reconcileHashCode.equals(delta.getAppsHashCode()) || clientConfig.shouldLogDeltaDiff()) &#123; reconcileAndLogDifference(delta, reconcileHashCode); // this makes a remoteCall &#125; &#125; else &#123; logger.warn(\"Not updating application delta as another thread is updating it already\"); logger.debug(\"Ignoring delta update with apps hashcode &#123;&#125;, as another thread is updating it already\", delta.getAppsHashCode()); &#125; &#125; fetchRegistry : 根据传入参数以及配置信息判断是否全量拉取还是增量拉取，全量拉取调用getAndStoreFullRegistry方法 ；增量拉取调用getAndUpdateDelta方法 getAndStoreFullRegistry：全量从Server拉取服务注册信息，更新本地缓存。此方法通过Eureka提供的远程通讯模块调用Server端暴露的Resources信息获取服务注册列表实例apps getAndUpdateDelta ：增量从Server端拉取服务的增量注册信息，更新本地缓存实例。 远程区域服务发现实现RemoteRegionRegistry 与客户端实现方式基本一致，不在描述 客户端，服务端，远程区域服务端交互","categories":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"Eureka","slug":"Eureka","permalink":"https://guofazhan.github.io/tags/Eureka/"}]},{"title":"Eureka之远程通讯模块","slug":"Eureka之远程通讯模块","date":"2018-08-25T01:10:00.000Z","updated":"2018-08-24T09:15:02.964Z","comments":true,"path":"2018/08/25/Eureka之远程通讯模块/","link":"","permalink":"https://guofazhan.github.io/2018/08/25/Eureka之远程通讯模块/","excerpt":"Eureka 架构为C-S模式 同时支持S 集群 ，不可避免的在client-server、server-server之间是需要远程通讯的，上面已经知道，Eureka 提供是http协议rest api，下面通过源码源码分析学习下eureka 提供的远程通讯模块 提供远程通讯模块的包路径1com.netflix.discovery.shared.transport 通讯模块对外的核心接口矩阵 EurekaHttpClient 通讯请求接口，负责发送http请求 EurekaHttpClientFactory EurekaHttpClient创建工厂接口，负责创建高等级的client TransportClientFactory EurekaHttpClient创建工厂接口，负责创建低等级的client EurekaTransportConfig 通讯相关配置获取接口，负责在配置文件中读取通讯模块的配置信息 备注： EurekaHttpClientFactory与TransportClientFactory同样都是创建client工厂，不过两个的职责不一样，client按功能划分为两大类，下面详细介绍。","text":"Eureka 架构为C-S模式 同时支持S 集群 ，不可避免的在client-server、server-server之间是需要远程通讯的，上面已经知道，Eureka 提供是http协议rest api，下面通过源码源码分析学习下eureka 提供的远程通讯模块 提供远程通讯模块的包路径1com.netflix.discovery.shared.transport 通讯模块对外的核心接口矩阵 EurekaHttpClient 通讯请求接口，负责发送http请求 EurekaHttpClientFactory EurekaHttpClient创建工厂接口，负责创建高等级的client TransportClientFactory EurekaHttpClient创建工厂接口，负责创建低等级的client EurekaTransportConfig 通讯相关配置获取接口，负责在配置文件中读取通讯模块的配置信息 备注： EurekaHttpClientFactory与TransportClientFactory同样都是创建client工厂，不过两个的职责不一样，client按功能划分为两大类，下面详细介绍。 EurekaHttpClient 通过上图可以明确的看出EurekaHttpClient接口实现为两大类: 实现http通讯的lowlevel实现； 使用装饰器模式实现特定功能的top level实现 。 low level实现： Eureka 根据http client 实现了两个AbstractJerseyEurekaHttpClient与AbstractJersey2EurekaHttpClient的low level 实现。从上面可以看出，如果Jersey1与Jersey2都不满足我们的自己的需求的话，我也可以根据自己需要的httpClient实现替代类，例如实现以OKhttp作为底层通讯的OkHttpEurekaHttpClient 或实现以netty作为底层通讯的NettyEurekaHttpClient， top level实现 ： 通过装饰器模式eueka 内置了 响应指标采集功能的装饰器、失败重试功能装饰器等，同时我们也可以扩展。 备注： HttpReplicationClient是eureka 专为server端集群节点通讯提供的通讯接口。其本质low level EurekaHttpClient接口方法 方法 描述 register(InstanceInfo info) 服务注册 cancel(String appName, String id) 服务下线 sendHeartBeat 服务续约 statusUpdate 服务状态更新 deleteStatusOverride getApplications(String… regions) 获取服务注册列表 getDelta(String… regions) 获取增量列表 getVip(String vipAddress, String… regions) 根据vip获取列表 getSecureVip(String secureVipAddress, String… regions) 根据svip获取列表 getApplication(String appName) 根据集群ID获取服务集群列表 getInstance(String appName, String id) 根据集群ID与服务ID获取服务 getInstance(String id) 根据服务ID获取服务 HttpReplicationClient接口方法 (server 节点数据同步特有) 方法 描述 statusUpdate(String asgName, ASGStatus newStatus) 状态更新同步 submitBatchUpdates(ReplicationList replicationList) 批量执行更新同步任务 EurekaTransportConfig通讯配置新获取1234567891011121314151617181920212223/** * eureka 远程通讯客户端配置默认实现 * @author David Liu */public class DefaultEurekaTransportConfig implements EurekaTransportConfig &#123; private static final String SUB_NAMESPACE = TRANSPORT_CONFIG_SUB_NAMESPACE + \".\"; private final String namespace; private final DynamicPropertyFactory configInstance; public DefaultEurekaTransportConfig(String parentNamespace, DynamicPropertyFactory configInstance) &#123; this.namespace = parentNamespace == null ? SUB_NAMESPACE : (parentNamespace.endsWith(\".\") ? parentNamespace + SUB_NAMESPACE : parentNamespace + \".\" + SUB_NAMESPACE); this.configInstance = configInstance; &#125; @Override public int getSessionedClientReconnectIntervalSeconds() &#123; return configInstance.getIntProperty(namespace + SESSION_RECONNECT_INTERVAL_KEY, Values.SESSION_RECONNECT_INTERVAL).get(); &#125; 1.构建函数创建 DynamicPropertyFactory 构建函数 初始化namespace 配置key的前缀 获取配置信息通过DynamicPropertyFactory 动态在配置文件中获取 EurekaHttpClients 工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public final class EurekaHttpClients &#123; private static final Logger logger = LoggerFactory.getLogger(EurekaHttpClients.class); private EurekaHttpClients() &#123; &#125; public static EurekaHttpClientFactory queryClientFactory(ClusterResolver bootstrapResolver, TransportClientFactory transportClientFactory, EurekaClientConfig clientConfig, EurekaTransportConfig transportConfig, InstanceInfo myInstanceInfo, ApplicationsResolver.ApplicationsSource applicationsSource) &#123; ClosableResolver queryResolver = transportConfig.useBootstrapResolverForQuery() ? wrapClosable(bootstrapResolver) : queryClientResolver(bootstrapResolver, transportClientFactory, clientConfig, transportConfig, myInstanceInfo, applicationsSource); return canonicalClientFactory(EurekaClientNames.QUERY, transportConfig, queryResolver, transportClientFactory); &#125; public static EurekaHttpClientFactory registrationClientFactory(ClusterResolver bootstrapResolver, TransportClientFactory transportClientFactory, EurekaTransportConfig transportConfig) &#123; return canonicalClientFactory(EurekaClientNames.REGISTRATION, transportConfig, bootstrapResolver, transportClientFactory); &#125; static EurekaHttpClientFactory canonicalClientFactory(final String name, final EurekaTransportConfig transportConfig, final ClusterResolver&lt;EurekaEndpoint&gt; clusterResolver, final TransportClientFactory transportClientFactory) &#123; return new EurekaHttpClientFactory() &#123; @Override public EurekaHttpClient newClient() &#123; return new SessionedEurekaHttpClient( name, RetryableEurekaHttpClient.createFactory( name, transportConfig, clusterResolver, RedirectingEurekaHttpClient.createFactory(transportClientFactory), ServerStatusEvaluators.legacyEvaluator()), transportConfig.getSessionedClientReconnectIntervalSeconds() * 1000 ); &#125; @Override public void shutdown() &#123; wrapClosable(clusterResolver).shutdown(); &#125; &#125;; &#125; EurekaHttpClients，是创建EurekaHttpClientFactory的工具类 EurekaHttpClient Low Level部分 JerseyEurekaHttpClientFactory 1234567891011121314151617181920212223242526272829public class JerseyEurekaHttpClientFactory implements TransportClientFactory &#123; public static final String HTTP_X_DISCOVERY_ALLOW_REDIRECT = \"X-Discovery-AllowRedirect\"; private final EurekaJerseyClient jerseyClient; private final ApacheHttpClient4 apacheClient; private final ApacheHttpClientConnectionCleaner cleaner; private final Map&lt;String, String&gt; additionalHeaders; private JerseyEurekaHttpClientFactory(EurekaJerseyClient jerseyClient, ApacheHttpClient4 apacheClient, long connectionIdleTimeout, Map&lt;String, String&gt; additionalHeaders) &#123; this.jerseyClient = jerseyClient; this.apacheClient = jerseyClient != null ? jerseyClient.getClient() : apacheClient; this.additionalHeaders = additionalHeaders; this.cleaner = new ApacheHttpClientConnectionCleaner(this.apacheClient, connectionIdleTimeout); &#125; /** * 服务创建JerseyApplicationClient * @param endpoint * @return */ @Override public EurekaHttpClient newClient(EurekaEndpoint endpoint) &#123; return new JerseyApplicationClient(apacheClient, endpoint.getServiceUrl(), additionalHeaders); &#125; JerseyEurekaHttpClientFactory 为TransportClientFactory的Jersey1实现主要负责创建JerseyEurekaHttpClient AbstractJerseyEurekaHttpClient 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public abstract class AbstractJerseyEurekaHttpClient implements EurekaHttpClient &#123; private static final Logger logger = LoggerFactory.getLogger(AbstractJerseyEurekaHttpClient.class); /** * jersey1 http 客户端，负责底层发送http请求 */ protected final Client jerseyClient; /** * server url */ protected final String serviceUrl; protected AbstractJerseyEurekaHttpClient(Client jerseyClient, String serviceUrl) &#123; this.jerseyClient = jerseyClient; this.serviceUrl = serviceUrl; logger.debug(\"Created client for url: &#123;&#125;\", serviceUrl); &#125; /** * 服务注册 * @param info * @return */ @Override public EurekaHttpResponse&lt;Void&gt; register(InstanceInfo info) &#123; String urlPath = \"apps/\" + info.getAppName(); ClientResponse response = null; try &#123; //通过HTTP客户端发送http请求 Builder resourceBuilder = jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder(); addExtraHeaders(resourceBuilder); //构建响应结果 response = resourceBuilder .header(\"Accept-Encoding\", \"gzip\") .type(MediaType.APPLICATION_JSON_TYPE) .accept(MediaType.APPLICATION_JSON) .post(ClientResponse.class, info); return anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build(); &#125; finally &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Jersey HTTP POST &#123;&#125;/&#123;&#125; with instance &#123;&#125;; statusCode=&#123;&#125;\", serviceUrl, urlPath, info.getId(), response == null ? \"N/A\" : response.getStatus()); &#125; if (response != null) &#123; response.close(); &#125; &#125; &#125; 1.通过构建函数 可以看到传入一个jersey1 http 客户端 register方法 实际是通过jersey1HttpClient发送http底层请求 在这里可以看到AbstractJerseyEurekaHttpClient实际上是不做底层通讯的工作的，全部都是交由com.sun.jersey.api.client.Client处理的，这个是在创建工厂创建时设置到AbstractJerseyEurekaHttpClient中的 备注: AbstractJersey2EurekaHttpClient与AbstractJerseyEurekaHttpClient的实现原理基本一样只是底层通讯的client不一致，后边不在描述 EurekaHttpClient Top Level部分 EurekaHttpClientDecorator 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * 抽象Eureka远程通讯客户端装饰器，使用设计模式-装饰器模式 为客户端添加新的功能 * @author Tomasz Bak */public abstract class EurekaHttpClientDecorator implements EurekaHttpClient &#123; /** * 请求类型 */ public enum RequestType &#123; //注册 Register, //下线 Cancel, //心跳 SendHeartBeat, //状态更新 StatusUpdate, DeleteStatusOverride, GetApplications, GetDelta, GetVip, GetSecureVip, GetApplication, GetInstance, GetApplicationInstance &#125; /** * 请求执行接口，负责执行请求 * @param &lt;R&gt; */ public interface RequestExecutor&lt;R&gt; &#123; /** * 执行请求并返回响应信息 * @param delegate 目标的客户端 * @return */ EurekaHttpResponse&lt;R&gt; execute(EurekaHttpClient delegate); /** * 请求的类型 * @return */ RequestType getRequestType(); &#125; /** * 抽象的执行方法，由子装饰器实现，附加其它功能 * @param requestExecutor * @param &lt;R&gt; * @return */ protected abstract &lt;R&gt; EurekaHttpResponse&lt;R&gt; execute(RequestExecutor&lt;R&gt; requestExecutor); @Override public EurekaHttpResponse&lt;Void&gt; register(final InstanceInfo info) &#123; //创建一个注册请求的执行器，并执行 return execute(new RequestExecutor&lt;Void&gt;() &#123; @Override public EurekaHttpResponse&lt;Void&gt; execute(EurekaHttpClient delegate) &#123; return delegate.register(info); &#125; @Override public RequestType getRequestType() &#123; return RequestType.Register; &#125; &#125;); &#125; @Override public EurekaHttpResponse&lt;Void&gt; cancel(final String appName, final String id) &#123; //创建一个下线请求的执行，并执行 return execute(new RequestExecutor&lt;Void&gt;() &#123; @Override public EurekaHttpResponse&lt;Void&gt; execute(EurekaHttpClient delegate) &#123; return delegate.cancel(appName, id); &#125; @Override public RequestType getRequestType() &#123; return RequestType.Cancel; &#125; &#125;); &#125; 基础的包装器 主要完成如下功能 实现EurekaHttpClient接口每个基础方法，都有如下流程 创建一个请求执行接口 通过调用抽象的execute方法将RequestExecutor传入 子类在RequestExecutor执行前或后完成新功能的附加 EurekaHttpClientDecorator实现 实现类 描述 MetricsCollectingEurekaHttpClient 实现请求响应状态指标采集的Eureka远程通讯客户端装饰器，为EurekaHttpClient添加响应状态指标采集向功能 RedirectingEurekaHttpClient 实现请求重定向的Eureka远程通讯客户端装饰器，为EurekaHttpClient添加请求重定向功能 RetryableEurekaHttpClient 实现请求失败重试的Eureka远程通讯客户端装饰器，为EurekaHttpClient添加失败重试功能 SessionedEurekaHttpClient TODO 从以上来看eureka 通讯模块结构和功能还是非常明了清晰，同时后期如果需要扩展，也是非常方便与快捷的","categories":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"Eureka","slug":"Eureka","permalink":"https://guofazhan.github.io/tags/Eureka/"}]},{"title":"Eureka之REST API","slug":"Eureka之REST-API-1","date":"2018-08-23T09:50:00.000Z","updated":"2018-08-23T11:33:14.319Z","comments":true,"path":"2018/08/23/Eureka之REST-API-1/","link":"","permalink":"https://guofazhan.github.io/2018/08/23/Eureka之REST-API-1/","excerpt":"Eureka服务端与客户之间的通讯方式为http，服务端通过提供rest API风格的接口与客户端或其它服务端交互。 交互数据格式 JSON/XML 提供资源服务的包路径 com.netflix.eureka.resources","text":"Eureka服务端与客户之间的通讯方式为http，服务端通过提供rest API风格的接口与客户端或其它服务端交互。 交互数据格式 JSON/XML 提供资源服务的包路径 com.netflix.eureka.resources 提供可使用的REST API接口 /{version}/apps 路径 /{version}/instances 路径 /{version}/status 路径 /{version}/peerreplication 路径 /{version}/vips 路径 /{version}/svips 路径","categories":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"Eureka","slug":"Eureka","permalink":"https://guofazhan.github.io/tags/Eureka/"}]},{"title":"Eureka之服务注册数据模型","slug":"Eureka之服务注册数据模型","date":"2018-08-23T09:43:00.000Z","updated":"2018-08-23T11:33:43.847Z","comments":true,"path":"2018/08/23/Eureka之服务注册数据模型/","link":"","permalink":"https://guofazhan.github.io/2018/08/23/Eureka之服务注册数据模型/","excerpt":"Eureka 作为注册中心，担任着服务节点的注册以及发现，并提供着动态的管理（坏点摘除，服务检测等）。可以说是整个系统的基础设施。 注册列表的数据模型","text":"Eureka 作为注册中心，担任着服务节点的注册以及发现，并提供着动态的管理（坏点摘除，服务检测等）。可以说是整个系统的基础设施。 注册列表的数据模型 1. Applications 注册列表，包含注册到当前注册中心上的所有实例信息，每个注册中心在内存中保持一份数据。在Applications中持有Application的队列 2. Application 注册到注册中心的服务集群信息，Application可以看做为一组对外提供相同服务的集群列表。在Application包含一组提供相同服务的InstanceInfo集合 3. InstanceInfo 注册列表里的单个服务实例信息，代表系统中提供一项服务的某个节点，里面包含节点的基础信息，以及唯一标识instanceId。 4. DataCenterInfo 服务实例所在的数据中心，默认为MyOwn，为InstanceInfo子属性 5. LeaseInfo 服务实例的租约信息，用于对服务做健康检查，续租，过期等服务可用性的管理。为InstanceInfo子属性 通过数据模型图可以清楚的看到Eureka将我们系统中的服务信息抽象成5个对象进行精细化的管理。我们注册进去的服务信息都将实例化成上述对象存储在eureka的服务端内存中，从而对外提供服务的注册以及发现。","categories":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"Eureka","slug":"Eureka","permalink":"https://guofazhan.github.io/tags/Eureka/"}]},{"title":"Eureka之server端集群节点发现，数据同步","slug":"Eureka之server端集群节点发现，数据同步-1","date":"2018-08-23T09:36:00.000Z","updated":"2018-08-23T11:34:19.091Z","comments":true,"path":"2018/08/23/Eureka之server端集群节点发现，数据同步-1/","link":"","permalink":"https://guofazhan.github.io/2018/08/23/Eureka之server端集群节点发现，数据同步-1/","excerpt":"Eureka服务端支持集群部署，通过源码查看集群节点发现以及数据同步功能的实现 提供集群功能的包路径 com.netflix.eureka.cluster 集群节点发现以及动态更新节点功能 Eureka服务端封装了一个集群节点管理的类名称为PeerEurekaNodes 通过名称翻译出来为对等的Eureka节点集合，可以看出这个类是对eureka服务端集群节点抽象，下面通过源码查询eureka是怎么管理与发现节点信息 123456789101112131415161718192021/** * eureka server 集群节点 集合类 帮助管理维护集群节点 * Helper class to manage lifecycle of a collection of &#123;@link PeerEurekaNode&#125;s. * * @author Tomasz Bak */@Singletonpublic class PeerEurekaNodes &#123; /** * 集群节点集合 */ private volatile List&lt;PeerEurekaNode&gt; peerEurekaNodes = Collections.emptyList(); /** * 集群节点URL集合 */ private volatile Set&lt;String&gt; peerEurekaNodeUrls = Collections.emptySet(); /** * 定时任务线程池 */ private ScheduledExecutorService taskExecutor; 通过PeerEurekaNodes类属性可以看到提供了两个集合以及一个执行定时任务的线程池，其它配置属性忽略 peerEurekaNodes 表示集群节点集合 peerEurekaNodeUrls 表示集群节点对应的URL集合 taskExecutor 执行定时任务的线程池","text":"Eureka服务端支持集群部署，通过源码查看集群节点发现以及数据同步功能的实现 提供集群功能的包路径 com.netflix.eureka.cluster 集群节点发现以及动态更新节点功能 Eureka服务端封装了一个集群节点管理的类名称为PeerEurekaNodes 通过名称翻译出来为对等的Eureka节点集合，可以看出这个类是对eureka服务端集群节点抽象，下面通过源码查询eureka是怎么管理与发现节点信息 123456789101112131415161718192021/** * eureka server 集群节点 集合类 帮助管理维护集群节点 * Helper class to manage lifecycle of a collection of &#123;@link PeerEurekaNode&#125;s. * * @author Tomasz Bak */@Singletonpublic class PeerEurekaNodes &#123; /** * 集群节点集合 */ private volatile List&lt;PeerEurekaNode&gt; peerEurekaNodes = Collections.emptyList(); /** * 集群节点URL集合 */ private volatile Set&lt;String&gt; peerEurekaNodeUrls = Collections.emptySet(); /** * 定时任务线程池 */ private ScheduledExecutorService taskExecutor; 通过PeerEurekaNodes类属性可以看到提供了两个集合以及一个执行定时任务的线程池，其它配置属性忽略 peerEurekaNodes 表示集群节点集合 peerEurekaNodeUrls 表示集群节点对应的URL集合 taskExecutor 执行定时任务的线程池 同时 PeerEurekaNodes 类提供start 与shutdown方法，接下来主要看start方法的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 /** * 启动方法，此方法管理集群节点间的通讯 */ public void start() &#123; //初始化定时任务线程池 taskExecutor = Executors.newSingleThreadScheduledExecutor( new ThreadFactory() &#123; @Override public Thread newThread(Runnable r) &#123; Thread thread = new Thread(r, \"Eureka-PeerNodesUpdater\"); thread.setDaemon(true); return thread; &#125; &#125; ); try &#123; updatePeerEurekaNodes(resolvePeerUrls()); //节点更新任务线程 Runnable peersUpdateTask = new Runnable() &#123; @Override public void run() &#123; try &#123; updatePeerEurekaNodes(resolvePeerUrls()); &#125; catch (Throwable e) &#123; logger.error(\"Cannot update the replica Nodes\", e); &#125; &#125; &#125;;// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。// 如果任务的任一执行遇到异常，就会取消后续执行。否则，只能通过执行程序的取消或终止方法来终止该任务。// 参数：// command - 要执行的任务// initialdelay - 首次执行的延迟时间// delay - 一次执行终止和下一次执行开始之间的延迟// unit - initialdelay 和 delay 参数的时间单位 //定时执行节点更新任务线程 taskExecutor.scheduleWithFixedDelay( peersUpdateTask, serverConfig.getPeerEurekaNodesUpdateIntervalMs(), serverConfig.getPeerEurekaNodesUpdateIntervalMs(), TimeUnit.MILLISECONDS ); &#125; catch (Exception e) &#123; throw new IllegalStateException(e); &#125; for (PeerEurekaNode node : peerEurekaNodes) &#123; logger.info(\"Replica node URL: \" + node.getServiceUrl()); &#125; &#125; start 方法主要完成以下几件事 初始化定时任务线程池 首次更新集群节点 updatePeerEurekaNodes方法 创建更新集群节点任务线程 通过定时任务线程池定时执行更新集群节点线程 通过start 可以看出 eureka是通过一个定时线程定时去更新集群的节点信息达到对集群节点的动态发现和感知，在上面我们可以看到更新操作主要由updatePeerEurekaNodes方法完成，下面查看此方法的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647protected void updatePeerEurekaNodes(List&lt;String&gt; newPeerUrls) &#123; if (newPeerUrls.isEmpty()) &#123; logger.warn(\"The replica size seems to be empty. Check the route 53 DNS Registry\"); return; &#125; Set&lt;String&gt; toShutdown = new HashSet&lt;&gt;(peerEurekaNodeUrls); toShutdown.removeAll(newPeerUrls); Set&lt;String&gt; toAdd = new HashSet&lt;&gt;(newPeerUrls); toAdd.removeAll(peerEurekaNodeUrls); //校验新的URL集合与旧有的URL集合是否一致，一致，不需要更新直接返回 if (toShutdown.isEmpty() &amp;&amp; toAdd.isEmpty()) &#123; // No change return; &#125; // Remove peers no long available List&lt;PeerEurekaNode&gt; newNodeList = new ArrayList&lt;&gt;(peerEurekaNodes); //移除旧集合中不可用的节点信息 if (!toShutdown.isEmpty()) &#123; logger.info(\"Removing no longer available peer nodes &#123;&#125;\", toShutdown); int i = 0; while (i &lt; newNodeList.size()) &#123; PeerEurekaNode eurekaNode = newNodeList.get(i); if (toShutdown.contains(eurekaNode.getServiceUrl())) &#123; newNodeList.remove(i); eurekaNode.shutDown(); &#125; else &#123; i++; &#125; &#125; &#125; //添加新增加的节点信息 // Add new peers if (!toAdd.isEmpty()) &#123; logger.info(\"Adding new peer nodes &#123;&#125;\", toAdd); for (String peerUrl : toAdd) &#123; newNodeList.add(createPeerEurekaNode(peerUrl)); &#125; &#125; //重新赋值peerEurekaNodes与peerEurekaNodeUrls this.peerEurekaNodes = newNodeList; this.peerEurekaNodeUrls = new HashSet&lt;&gt;(newPeerUrls);&#125; updatePeerEurekaNodes根据传入的新集群URL集合完成节点的更新 校验传入的URL集合是否需要更新 移除新url集合中没有的旧节点并关闭节点 创建旧节点集合中没有的新URL节点通过createPeerEurekaNode方法 重新赋值节点集合以及URL集合完成节点的更新 updatePeerEurekaNodes传入的新URL集合是通过resolvePeerUrls方法获取，这个方法实际上是解析配置文件中的eureka.serviceUrl前缀的配置获取，并动态监听配置的更新。 创建新的节点是通过createPeerEurekaNode创建，下面查看此方法源码 12345678910111213141516/** * 根据URL创建server新节点信息 * @param peerEurekaNodeUrl * @return */protected PeerEurekaNode createPeerEurekaNode(String peerEurekaNodeUrl) &#123; //创建一个连接远程节点的客户端 HttpReplicationClient replicationClient = JerseyReplicationClient.createReplicationClient(serverConfig, serverCodecs, peerEurekaNodeUrl); //获取新节点host信息 String targetHost = hostFromUrl(peerEurekaNodeUrl); if (targetHost == null) &#123; targetHost = \"host\"; &#125; //创建新节点 return new PeerEurekaNode(registry, targetHost, peerEurekaNodeUrl, replicationClient, serverConfig);&#125; PeerEurekaNode 方法 创建远程通讯客户端replicationClient 用户与此节点间通讯，数据同步等工作 获取要创建的远程节点的host 创建一个表示远程节点实例 PeerEurekaNode PeerEurekaNode 表示一个与当前节点对等的远程节点，当前节点与远程节点的数据同步工作都是在此实例中完成的。 集群节点数据同步 在上面节点发现中知道eureka是通过PeerEurekaNode表示远程对等接点，并将远程通讯客户端replicationClient传入到PeerEurekaNode中，接下来通过查看PeerEurekaNode源码来看eureka集群节点间都有那些数据需要同步以及通讯内容 1234567891011121314151617181920212223242526272829/* For testing */ PeerEurekaNode(PeerAwareInstanceRegistry registry, String targetHost, String serviceUrl, HttpReplicationClient replicationClient, EurekaServerConfig config, int batchSize, long maxBatchingDelayMs, long retrySleepTimeMs, long serverUnavailableSleepTimeMs) &#123; String batcherName = getBatcherName(); //任务处理器 ReplicationTaskProcessor taskProcessor = new ReplicationTaskProcessor(targetHost, replicationClient); //创建一个批量执行的任务调度器 this.batchingDispatcher = TaskDispatchers.createBatchingTaskDispatcher( batcherName, config.getMaxElementsInPeerReplicationPool(), batchSize, config.getMaxThreadsForPeerReplication(), maxBatchingDelayMs, serverUnavailableSleepTimeMs, retrySleepTimeMs, taskProcessor ); //创建一个单任务调度器 this.nonBatchingDispatcher = TaskDispatchers.createNonBatchingTaskDispatcher( targetHost, config.getMaxElementsInStatusReplicationPool(), config.getMaxThreadsForStatusReplication(), maxBatchingDelayMs, serverUnavailableSleepTimeMs, retrySleepTimeMs, taskProcessor );&#125; PeerEurekaNode 完成以下事件 创建数据同步的任务处理器ReplicationTaskProcessor 创建批处理任务调度器 创建单任务处理调度器 说明: eureka将节点间的数据同步工作包装成一个个细微的任务ReplicationTask ，每一个数据操作代表一个任务，将任务发送给任务调度器TaskDispatcher去异步处理。 下来查看PeerEurekaNode都可以创建那些同步任务 register 1234567891011121314151617181920212223/** * 当eureka server注册新服务时，同时创建一个定时任务将新服务同步到集群其它节点 * Sends the registration information of &#123;@link InstanceInfo&#125; receiving by * this node to the peer node represented by this class. * * @param info * the instance information &#123;@link InstanceInfo&#125; of any instance * that is send to this instance. * @throws Exception */public void register(final InstanceInfo info) throws Exception &#123; long expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info); //任务调度器中添加一个请求类型为注册register新服务的同步任务 batchingDispatcher.process( taskId(\"register\", info), new InstanceReplicationTask(targetHost, Action.Register, info, null, true) &#123; public EurekaHttpResponse&lt;Void&gt; execute() &#123; return replicationClient.register(info); &#125; &#125;, expiryTime );&#125; 注册同步任务，当有服务注册到当前节点时，通过注册同步任务将服务信息同步到集群远程节点 cancel 12345678910111213141516171819202122public void cancel(final String appName, final String id) throws Exception &#123; long expiryTime = System.currentTimeMillis() + maxProcessingDelayMs; //任务调度器中添加一个请求类型为取消cancel服务的同步任务 batchingDispatcher.process( taskId(\"cancel\", appName, id), new InstanceReplicationTask(targetHost, Action.Cancel, appName, id) &#123; @Override public EurekaHttpResponse&lt;Void&gt; execute() &#123; return replicationClient.cancel(appName, id); &#125; @Override public void handleFailure(int statusCode, Object responseEntity) throws Throwable &#123; super.handleFailure(statusCode, responseEntity); if (statusCode == 404) &#123; logger.warn(\"&#123;&#125;: missing entry.\", getTaskName()); &#125; &#125; &#125;, expiryTime ); &#125; 取消服务注册任务，当前节点有服务取消注册，将信息同步到集群远程节点 heartbeat 1234567891011121314151617181920212223242526272829303132333435363738public void heartbeat(final String appName, final String id, final InstanceInfo info, final InstanceStatus overriddenStatus, boolean primeConnection) throws Throwable &#123; //当第一次连接时直接发送心跳到远端 if (primeConnection) &#123; // We do not care about the result for priming request. replicationClient.sendHeartBeat(appName, id, info, overriddenStatus); return; &#125; //心跳同步任务 ReplicationTask replicationTask = new InstanceReplicationTask(targetHost, Action.Heartbeat, info, overriddenStatus, false) &#123; @Override public EurekaHttpResponse&lt;InstanceInfo&gt; execute() throws Throwable &#123; return replicationClient.sendHeartBeat(appName, id, info, overriddenStatus); &#125; @Override public void handleFailure(int statusCode, Object responseEntity) throws Throwable &#123; super.handleFailure(statusCode, responseEntity); if (statusCode == 404) &#123; logger.warn(&quot;&#123;&#125;: missing entry.&quot;, getTaskName()); if (info != null) &#123; logger.warn(&quot;&#123;&#125;: cannot find instance id &#123;&#125; and hence replicating the instance with status &#123;&#125;&quot;, getTaskName(), info.getId(), info.getStatus()); register(info); &#125; &#125; else if (config.shouldSyncWhenTimestampDiffers()) &#123; InstanceInfo peerInstanceInfo = (InstanceInfo) responseEntity; if (peerInstanceInfo != null) &#123; syncInstancesIfTimestampDiffers(appName, id, info, peerInstanceInfo); &#125; &#125; &#125; &#125;; long expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info); //任务调度器中添加一个请求类型为heartbeat服务的同步任务 batchingDispatcher.process(taskId(&quot;heartbeat&quot;, info), replicationTask, expiryTime);&#125; 心跳同步任务，当前节点有服务发送心跳续租，将信息同步到集群远程节点 StatusUpdate DeleteStatusOverride 集群节点数据同步任务处理 在PeerEurekaNode的构造函数中可以看到同步任务处理由ReplicationTaskProcessor完成，下面看此类源码 123456789101112131415161718192021222324252627282930313233343536/** * 单个处理ReplicationTask任务 * @param task * @return */ @Override public ProcessingResult process(ReplicationTask task) &#123; try &#123; //调用任务execute方法，完成任务的执行 EurekaHttpResponse&lt;?&gt; httpResponse = task.execute(); int statusCode = httpResponse.getStatusCode(); //判断任务返回结果 Object entity = httpResponse.getEntity(); if (logger.isDebugEnabled()) &#123; logger.debug(\"Replication task &#123;&#125; completed with status &#123;&#125;, (includes entity &#123;&#125;)\", task.getTaskName(), statusCode, entity != null); &#125; if (isSuccess(statusCode)) &#123; task.handleSuccess(); &#125; else if (statusCode == 503) &#123; logger.debug(\"Server busy (503) reply for task &#123;&#125;\", task.getTaskName()); return ProcessingResult.Congestion; &#125; else &#123; task.handleFailure(statusCode, entity); return ProcessingResult.PermanentError; &#125; &#125; catch (Throwable e) &#123; if (isNetworkConnectException(e)) &#123; logNetworkErrorSample(task, e); return ProcessingResult.TransientError; &#125; else &#123; logger.error(peerId + \": \" + task.getTaskName() + \"Not re-trying this exception because it does not seem to be a network exception\", e); return ProcessingResult.PermanentError; &#125; &#125; return ProcessingResult.Success; &#125; 单任务处理 调用任务task的execute完成远程数据同步 分析远程返回结果 12345678910111213141516171819202122232425262728293031323334353637/** * 批量处理ReplicationTask任务 * @param tasks * @return */ @Override public ProcessingResult process(List&lt;ReplicationTask&gt; tasks) &#123; //根据task集合创建ReplicationList ReplicationList list = createReplicationListOf(tasks); try &#123; //调用批量同步接口 将同步集合发送到远端节点同步数据 EurekaHttpResponse&lt;ReplicationListResponse&gt; response = replicationClient.submitBatchUpdates(list); //判断同步返回结果 int statusCode = response.getStatusCode(); if (!isSuccess(statusCode)) &#123; if (statusCode == 503) &#123; logger.warn(\"Server busy (503) HTTP status code received from the peer &#123;&#125;; rescheduling tasks after delay\", peerId); return ProcessingResult.Congestion; &#125; else &#123; // Unexpected error returned from the server. This should ideally never happen. logger.error(\"Batch update failure with HTTP status code &#123;&#125;; discarding &#123;&#125; replication tasks\", statusCode, tasks.size()); return ProcessingResult.PermanentError; &#125; &#125; else &#123; handleBatchResponse(tasks, response.getEntity().getResponseList()); &#125; &#125; catch (Throwable e) &#123; if (isNetworkConnectException(e)) &#123; logNetworkErrorSample(null, e); return ProcessingResult.TransientError; &#125; else &#123; logger.error(\"Not re-trying this exception because it does not seem to be a network exception\", e); return ProcessingResult.PermanentError; &#125; &#125; return ProcessingResult.Success; &#125; 批处理任务，将一组任务一次性发送到远程进行处理 根据task集合创建ReplicationList 调用批量同步接口将同步集合发送到远端节点同步数据 即调用rest API /{version}/peerreplication 分析远程返回结果 eureka 服务端 集群节点发现，数据同步功能主要是由PeerEurekaNodes与PeerEurekaNode类实现,通过源码的跟踪可以清晰看出集群实现的逻辑，方便在实际应用中对问题的定位","categories":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"Eureka","slug":"Eureka","permalink":"https://guofazhan.github.io/tags/Eureka/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-23T06:37:01.950Z","updated":"2018-08-23T06:37:01.951Z","comments":true,"path":"2018/08/23/hello-world/","link":"","permalink":"https://guofazhan.github.io/2018/08/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}