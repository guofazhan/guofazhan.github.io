{"meta":{"title":"Mr.G-博客","subtitle":"博客","description":"学习分享、源码阅读、笔记","author":"Mr.G","url":"https://guofazhan.github.io"},"pages":[{"title":"","date":"2018-08-23T11:32:07.768Z","updated":"2018-08-23T11:32:07.720Z","comments":true,"path":"about/index.html","permalink":"https://guofazhan.github.io/about/index.html","excerpt":"","text":"关于 作者：guofazhan 邮箱：guofazhan@hotmail.com"}],"posts":[{"title":"Eureka之远程通讯模块","slug":"Eureka之远程通讯模块","date":"2018-08-25T01:10:00.000Z","updated":"2018-08-24T09:15:02.964Z","comments":true,"path":"2018/08/25/Eureka之远程通讯模块/","link":"","permalink":"https://guofazhan.github.io/2018/08/25/Eureka之远程通讯模块/","excerpt":"Eureka 架构为C-S模式 同时支持S 集群 ，不可避免的在client-server、server-server之间是需要远程通讯的，上面已经知道，Eureka 提供是http协议rest api，下面通过源码源码分析学习下eureka 提供的远程通讯模块 提供远程通讯模块的包路径1com.netflix.discovery.shared.transport 通讯模块对外的核心接口矩阵 EurekaHttpClient 通讯请求接口，负责发送http请求 EurekaHttpClientFactory EurekaHttpClient创建工厂接口，负责创建高等级的client TransportClientFactory EurekaHttpClient创建工厂接口，负责创建低等级的client EurekaTransportConfig 通讯相关配置获取接口，负责在配置文件中读取通讯模块的配置信息 备注： EurekaHttpClientFactory与TransportClientFactory同样都是创建client工厂，不过两个的职责不一样，client按功能划分为两大类，下面详细介绍。","text":"Eureka 架构为C-S模式 同时支持S 集群 ，不可避免的在client-server、server-server之间是需要远程通讯的，上面已经知道，Eureka 提供是http协议rest api，下面通过源码源码分析学习下eureka 提供的远程通讯模块 提供远程通讯模块的包路径1com.netflix.discovery.shared.transport 通讯模块对外的核心接口矩阵 EurekaHttpClient 通讯请求接口，负责发送http请求 EurekaHttpClientFactory EurekaHttpClient创建工厂接口，负责创建高等级的client TransportClientFactory EurekaHttpClient创建工厂接口，负责创建低等级的client EurekaTransportConfig 通讯相关配置获取接口，负责在配置文件中读取通讯模块的配置信息 备注： EurekaHttpClientFactory与TransportClientFactory同样都是创建client工厂，不过两个的职责不一样，client按功能划分为两大类，下面详细介绍。 EurekaHttpClient 通过上图可以明确的看出EurekaHttpClient接口实现为两大类: 实现http通讯的lowlevel实现； 使用装饰器模式实现特定功能的top level实现 。 low level实现： Eureka 根据http client 实现了两个AbstractJerseyEurekaHttpClient与AbstractJersey2EurekaHttpClient的low level 实现。从上面可以看出，如果Jersey1与Jersey2都不满足我们的自己的需求的话，我也可以根据自己需要的httpClient实现替代类，例如实现以OKhttp作为底层通讯的OkHttpEurekaHttpClient 或实现以netty作为底层通讯的NettyEurekaHttpClient， top level实现 ： 通过装饰器模式eueka 内置了 响应指标采集功能的装饰器、失败重试功能装饰器等，同时我们也可以扩展。 备注： HttpReplicationClient是eureka 专为server端集群节点通讯提供的通讯接口。其本质low level EurekaHttpClient接口方法 方法 描述 register(InstanceInfo info) 服务注册 cancel(String appName, String id) 服务下线 sendHeartBeat 服务续约 statusUpdate 服务状态更新 deleteStatusOverride getApplications(String… regions) 获取服务注册列表 getDelta(String… regions) 获取增量列表 getVip(String vipAddress, String… regions) 根据vip获取列表 getSecureVip(String secureVipAddress, String… regions) 根据svip获取列表 getApplication(String appName) 根据集群ID获取服务集群列表 getInstance(String appName, String id) 根据集群ID与服务ID获取服务 getInstance(String id) 根据服务ID获取服务 HttpReplicationClient接口方法 (server 节点数据同步特有) 方法 描述 statusUpdate(String asgName, ASGStatus newStatus) 状态更新同步 submitBatchUpdates(ReplicationList replicationList) 批量执行更新同步任务 EurekaTransportConfig通讯配置新获取1234567891011121314151617181920212223/** * eureka 远程通讯客户端配置默认实现 * @author David Liu */public class DefaultEurekaTransportConfig implements EurekaTransportConfig &#123; private static final String SUB_NAMESPACE = TRANSPORT_CONFIG_SUB_NAMESPACE + \".\"; private final String namespace; private final DynamicPropertyFactory configInstance; public DefaultEurekaTransportConfig(String parentNamespace, DynamicPropertyFactory configInstance) &#123; this.namespace = parentNamespace == null ? SUB_NAMESPACE : (parentNamespace.endsWith(\".\") ? parentNamespace + SUB_NAMESPACE : parentNamespace + \".\" + SUB_NAMESPACE); this.configInstance = configInstance; &#125; @Override public int getSessionedClientReconnectIntervalSeconds() &#123; return configInstance.getIntProperty(namespace + SESSION_RECONNECT_INTERVAL_KEY, Values.SESSION_RECONNECT_INTERVAL).get(); &#125; 1.构建函数创建 DynamicPropertyFactory 构建函数 初始化namespace 配置key的前缀 获取配置信息通过DynamicPropertyFactory 动态在配置文件中获取 EurekaHttpClients 工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public final class EurekaHttpClients &#123; private static final Logger logger = LoggerFactory.getLogger(EurekaHttpClients.class); private EurekaHttpClients() &#123; &#125; public static EurekaHttpClientFactory queryClientFactory(ClusterResolver bootstrapResolver, TransportClientFactory transportClientFactory, EurekaClientConfig clientConfig, EurekaTransportConfig transportConfig, InstanceInfo myInstanceInfo, ApplicationsResolver.ApplicationsSource applicationsSource) &#123; ClosableResolver queryResolver = transportConfig.useBootstrapResolverForQuery() ? wrapClosable(bootstrapResolver) : queryClientResolver(bootstrapResolver, transportClientFactory, clientConfig, transportConfig, myInstanceInfo, applicationsSource); return canonicalClientFactory(EurekaClientNames.QUERY, transportConfig, queryResolver, transportClientFactory); &#125; public static EurekaHttpClientFactory registrationClientFactory(ClusterResolver bootstrapResolver, TransportClientFactory transportClientFactory, EurekaTransportConfig transportConfig) &#123; return canonicalClientFactory(EurekaClientNames.REGISTRATION, transportConfig, bootstrapResolver, transportClientFactory); &#125; static EurekaHttpClientFactory canonicalClientFactory(final String name, final EurekaTransportConfig transportConfig, final ClusterResolver&lt;EurekaEndpoint&gt; clusterResolver, final TransportClientFactory transportClientFactory) &#123; return new EurekaHttpClientFactory() &#123; @Override public EurekaHttpClient newClient() &#123; return new SessionedEurekaHttpClient( name, RetryableEurekaHttpClient.createFactory( name, transportConfig, clusterResolver, RedirectingEurekaHttpClient.createFactory(transportClientFactory), ServerStatusEvaluators.legacyEvaluator()), transportConfig.getSessionedClientReconnectIntervalSeconds() * 1000 ); &#125; @Override public void shutdown() &#123; wrapClosable(clusterResolver).shutdown(); &#125; &#125;; &#125; EurekaHttpClients，是创建EurekaHttpClientFactory的工具类 EurekaHttpClient Low Level部分 JerseyEurekaHttpClientFactory 1234567891011121314151617181920212223242526272829public class JerseyEurekaHttpClientFactory implements TransportClientFactory &#123; public static final String HTTP_X_DISCOVERY_ALLOW_REDIRECT = \"X-Discovery-AllowRedirect\"; private final EurekaJerseyClient jerseyClient; private final ApacheHttpClient4 apacheClient; private final ApacheHttpClientConnectionCleaner cleaner; private final Map&lt;String, String&gt; additionalHeaders; private JerseyEurekaHttpClientFactory(EurekaJerseyClient jerseyClient, ApacheHttpClient4 apacheClient, long connectionIdleTimeout, Map&lt;String, String&gt; additionalHeaders) &#123; this.jerseyClient = jerseyClient; this.apacheClient = jerseyClient != null ? jerseyClient.getClient() : apacheClient; this.additionalHeaders = additionalHeaders; this.cleaner = new ApacheHttpClientConnectionCleaner(this.apacheClient, connectionIdleTimeout); &#125; /** * 服务创建JerseyApplicationClient * @param endpoint * @return */ @Override public EurekaHttpClient newClient(EurekaEndpoint endpoint) &#123; return new JerseyApplicationClient(apacheClient, endpoint.getServiceUrl(), additionalHeaders); &#125; JerseyEurekaHttpClientFactory 为TransportClientFactory的Jersey1实现主要负责创建JerseyEurekaHttpClient AbstractJerseyEurekaHttpClient 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public abstract class AbstractJerseyEurekaHttpClient implements EurekaHttpClient &#123; private static final Logger logger = LoggerFactory.getLogger(AbstractJerseyEurekaHttpClient.class); /** * jersey1 http 客户端，负责底层发送http请求 */ protected final Client jerseyClient; /** * server url */ protected final String serviceUrl; protected AbstractJerseyEurekaHttpClient(Client jerseyClient, String serviceUrl) &#123; this.jerseyClient = jerseyClient; this.serviceUrl = serviceUrl; logger.debug(\"Created client for url: &#123;&#125;\", serviceUrl); &#125; /** * 服务注册 * @param info * @return */ @Override public EurekaHttpResponse&lt;Void&gt; register(InstanceInfo info) &#123; String urlPath = \"apps/\" + info.getAppName(); ClientResponse response = null; try &#123; //通过HTTP客户端发送http请求 Builder resourceBuilder = jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder(); addExtraHeaders(resourceBuilder); //构建响应结果 response = resourceBuilder .header(\"Accept-Encoding\", \"gzip\") .type(MediaType.APPLICATION_JSON_TYPE) .accept(MediaType.APPLICATION_JSON) .post(ClientResponse.class, info); return anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build(); &#125; finally &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Jersey HTTP POST &#123;&#125;/&#123;&#125; with instance &#123;&#125;; statusCode=&#123;&#125;\", serviceUrl, urlPath, info.getId(), response == null ? \"N/A\" : response.getStatus()); &#125; if (response != null) &#123; response.close(); &#125; &#125; &#125; 1.通过构建函数 可以看到传入一个jersey1 http 客户端 register方法 实际是通过jersey1HttpClient发送http底层请求 在这里可以看到AbstractJerseyEurekaHttpClient实际上是不做底层通讯的工作的，全部都是交由com.sun.jersey.api.client.Client处理的，这个是在创建工厂创建时设置到AbstractJerseyEurekaHttpClient中的 备注: AbstractJersey2EurekaHttpClient与AbstractJerseyEurekaHttpClient的实现原理基本一样只是底层通讯的client不一致，后边不在描述 EurekaHttpClient Top Level部分 EurekaHttpClientDecorator 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * 抽象Eureka远程通讯客户端装饰器，使用设计模式-装饰器模式 为客户端添加新的功能 * @author Tomasz Bak */public abstract class EurekaHttpClientDecorator implements EurekaHttpClient &#123; /** * 请求类型 */ public enum RequestType &#123; //注册 Register, //下线 Cancel, //心跳 SendHeartBeat, //状态更新 StatusUpdate, DeleteStatusOverride, GetApplications, GetDelta, GetVip, GetSecureVip, GetApplication, GetInstance, GetApplicationInstance &#125; /** * 请求执行接口，负责执行请求 * @param &lt;R&gt; */ public interface RequestExecutor&lt;R&gt; &#123; /** * 执行请求并返回响应信息 * @param delegate 目标的客户端 * @return */ EurekaHttpResponse&lt;R&gt; execute(EurekaHttpClient delegate); /** * 请求的类型 * @return */ RequestType getRequestType(); &#125; /** * 抽象的执行方法，由子装饰器实现，附加其它功能 * @param requestExecutor * @param &lt;R&gt; * @return */ protected abstract &lt;R&gt; EurekaHttpResponse&lt;R&gt; execute(RequestExecutor&lt;R&gt; requestExecutor); @Override public EurekaHttpResponse&lt;Void&gt; register(final InstanceInfo info) &#123; //创建一个注册请求的执行器，并执行 return execute(new RequestExecutor&lt;Void&gt;() &#123; @Override public EurekaHttpResponse&lt;Void&gt; execute(EurekaHttpClient delegate) &#123; return delegate.register(info); &#125; @Override public RequestType getRequestType() &#123; return RequestType.Register; &#125; &#125;); &#125; @Override public EurekaHttpResponse&lt;Void&gt; cancel(final String appName, final String id) &#123; //创建一个下线请求的执行，并执行 return execute(new RequestExecutor&lt;Void&gt;() &#123; @Override public EurekaHttpResponse&lt;Void&gt; execute(EurekaHttpClient delegate) &#123; return delegate.cancel(appName, id); &#125; @Override public RequestType getRequestType() &#123; return RequestType.Cancel; &#125; &#125;); &#125; 基础的包装器 主要完成如下功能 实现EurekaHttpClient接口每个基础方法，都有如下流程 创建一个请求执行接口 通过调用抽象的execute方法将RequestExecutor传入 子类在RequestExecutor执行前或后完成新功能的附加 EurekaHttpClientDecorator实现 实现类 描述 MetricsCollectingEurekaHttpClient 实现请求响应状态指标采集的Eureka远程通讯客户端装饰器，为EurekaHttpClient添加响应状态指标采集向功能 RedirectingEurekaHttpClient 实现请求重定向的Eureka远程通讯客户端装饰器，为EurekaHttpClient添加请求重定向功能 RetryableEurekaHttpClient 实现请求失败重试的Eureka远程通讯客户端装饰器，为EurekaHttpClient添加失败重试功能 SessionedEurekaHttpClient TODO 从以上来看eureka 通讯模块结构和功能还是非常明了清晰，同时后期如果需要扩展，也是非常方便与快捷的","categories":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"Eureka","slug":"Eureka","permalink":"https://guofazhan.github.io/tags/Eureka/"}]},{"title":"Eureka之REST API","slug":"Eureka之REST-API-1","date":"2018-08-23T09:50:00.000Z","updated":"2018-08-23T11:33:14.319Z","comments":true,"path":"2018/08/23/Eureka之REST-API-1/","link":"","permalink":"https://guofazhan.github.io/2018/08/23/Eureka之REST-API-1/","excerpt":"Eureka服务端与客户之间的通讯方式为http，服务端通过提供rest API风格的接口与客户端或其它服务端交互。 交互数据格式 JSON/XML 提供资源服务的包路径 com.netflix.eureka.resources","text":"Eureka服务端与客户之间的通讯方式为http，服务端通过提供rest API风格的接口与客户端或其它服务端交互。 交互数据格式 JSON/XML 提供资源服务的包路径 com.netflix.eureka.resources 提供可使用的REST API接口 /{version}/apps 路径 /{version}/instances 路径 /{version}/status 路径 /{version}/peerreplication 路径 /{version}/vips 路径 /{version}/svips 路径","categories":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"Eureka","slug":"Eureka","permalink":"https://guofazhan.github.io/tags/Eureka/"}]},{"title":"Eureka之服务注册数据模型","slug":"Eureka之服务注册数据模型","date":"2018-08-23T09:43:00.000Z","updated":"2018-08-23T11:33:43.847Z","comments":true,"path":"2018/08/23/Eureka之服务注册数据模型/","link":"","permalink":"https://guofazhan.github.io/2018/08/23/Eureka之服务注册数据模型/","excerpt":"Eureka 作为注册中心，担任着服务节点的注册以及发现，并提供着动态的管理（坏点摘除，服务检测等）。可以说是整个系统的基础设施。 注册列表的数据模型","text":"Eureka 作为注册中心，担任着服务节点的注册以及发现，并提供着动态的管理（坏点摘除，服务检测等）。可以说是整个系统的基础设施。 注册列表的数据模型 1. Applications 注册列表，包含注册到当前注册中心上的所有实例信息，每个注册中心在内存中保持一份数据。在Applications中持有Application的队列 2. Application 注册到注册中心的服务集群信息，Application可以看做为一组对外提供相同服务的集群列表。在Application包含一组提供相同服务的InstanceInfo集合 3. InstanceInfo 注册列表里的单个服务实例信息，代表系统中提供一项服务的某个节点，里面包含节点的基础信息，以及唯一标识instanceId。 4. DataCenterInfo 服务实例所在的数据中心，默认为MyOwn，为InstanceInfo子属性 5. LeaseInfo 服务实例的租约信息，用于对服务做健康检查，续租，过期等服务可用性的管理。为InstanceInfo子属性 通过数据模型图可以清楚的看到Eureka将我们系统中的服务信息抽象成5个对象进行精细化的管理。我们注册进去的服务信息都将实例化成上述对象存储在eureka的服务端内存中，从而对外提供服务的注册以及发现。","categories":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"Eureka","slug":"Eureka","permalink":"https://guofazhan.github.io/tags/Eureka/"}]},{"title":"Eureka之server端集群节点发现，数据同步","slug":"Eureka之server端集群节点发现，数据同步-1","date":"2018-08-23T09:36:00.000Z","updated":"2018-08-23T11:34:19.091Z","comments":true,"path":"2018/08/23/Eureka之server端集群节点发现，数据同步-1/","link":"","permalink":"https://guofazhan.github.io/2018/08/23/Eureka之server端集群节点发现，数据同步-1/","excerpt":"Eureka服务端支持集群部署，通过源码查看集群节点发现以及数据同步功能的实现 提供集群功能的包路径 com.netflix.eureka.cluster 集群节点发现以及动态更新节点功能 Eureka服务端封装了一个集群节点管理的类名称为PeerEurekaNodes 通过名称翻译出来为对等的Eureka节点集合，可以看出这个类是对eureka服务端集群节点抽象，下面通过源码查询eureka是怎么管理与发现节点信息 123456789101112131415161718192021/** * eureka server 集群节点 集合类 帮助管理维护集群节点 * Helper class to manage lifecycle of a collection of &#123;@link PeerEurekaNode&#125;s. * * @author Tomasz Bak */@Singletonpublic class PeerEurekaNodes &#123; /** * 集群节点集合 */ private volatile List&lt;PeerEurekaNode&gt; peerEurekaNodes = Collections.emptyList(); /** * 集群节点URL集合 */ private volatile Set&lt;String&gt; peerEurekaNodeUrls = Collections.emptySet(); /** * 定时任务线程池 */ private ScheduledExecutorService taskExecutor; 通过PeerEurekaNodes类属性可以看到提供了两个集合以及一个执行定时任务的线程池，其它配置属性忽略 peerEurekaNodes 表示集群节点集合 peerEurekaNodeUrls 表示集群节点对应的URL集合 taskExecutor 执行定时任务的线程池","text":"Eureka服务端支持集群部署，通过源码查看集群节点发现以及数据同步功能的实现 提供集群功能的包路径 com.netflix.eureka.cluster 集群节点发现以及动态更新节点功能 Eureka服务端封装了一个集群节点管理的类名称为PeerEurekaNodes 通过名称翻译出来为对等的Eureka节点集合，可以看出这个类是对eureka服务端集群节点抽象，下面通过源码查询eureka是怎么管理与发现节点信息 123456789101112131415161718192021/** * eureka server 集群节点 集合类 帮助管理维护集群节点 * Helper class to manage lifecycle of a collection of &#123;@link PeerEurekaNode&#125;s. * * @author Tomasz Bak */@Singletonpublic class PeerEurekaNodes &#123; /** * 集群节点集合 */ private volatile List&lt;PeerEurekaNode&gt; peerEurekaNodes = Collections.emptyList(); /** * 集群节点URL集合 */ private volatile Set&lt;String&gt; peerEurekaNodeUrls = Collections.emptySet(); /** * 定时任务线程池 */ private ScheduledExecutorService taskExecutor; 通过PeerEurekaNodes类属性可以看到提供了两个集合以及一个执行定时任务的线程池，其它配置属性忽略 peerEurekaNodes 表示集群节点集合 peerEurekaNodeUrls 表示集群节点对应的URL集合 taskExecutor 执行定时任务的线程池 同时 PeerEurekaNodes 类提供start 与shutdown方法，接下来主要看start方法的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 /** * 启动方法，此方法管理集群节点间的通讯 */ public void start() &#123; //初始化定时任务线程池 taskExecutor = Executors.newSingleThreadScheduledExecutor( new ThreadFactory() &#123; @Override public Thread newThread(Runnable r) &#123; Thread thread = new Thread(r, \"Eureka-PeerNodesUpdater\"); thread.setDaemon(true); return thread; &#125; &#125; ); try &#123; updatePeerEurekaNodes(resolvePeerUrls()); //节点更新任务线程 Runnable peersUpdateTask = new Runnable() &#123; @Override public void run() &#123; try &#123; updatePeerEurekaNodes(resolvePeerUrls()); &#125; catch (Throwable e) &#123; logger.error(\"Cannot update the replica Nodes\", e); &#125; &#125; &#125;;// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。// 如果任务的任一执行遇到异常，就会取消后续执行。否则，只能通过执行程序的取消或终止方法来终止该任务。// 参数：// command - 要执行的任务// initialdelay - 首次执行的延迟时间// delay - 一次执行终止和下一次执行开始之间的延迟// unit - initialdelay 和 delay 参数的时间单位 //定时执行节点更新任务线程 taskExecutor.scheduleWithFixedDelay( peersUpdateTask, serverConfig.getPeerEurekaNodesUpdateIntervalMs(), serverConfig.getPeerEurekaNodesUpdateIntervalMs(), TimeUnit.MILLISECONDS ); &#125; catch (Exception e) &#123; throw new IllegalStateException(e); &#125; for (PeerEurekaNode node : peerEurekaNodes) &#123; logger.info(\"Replica node URL: \" + node.getServiceUrl()); &#125; &#125; start 方法主要完成以下几件事 初始化定时任务线程池 首次更新集群节点 updatePeerEurekaNodes方法 创建更新集群节点任务线程 通过定时任务线程池定时执行更新集群节点线程 通过start 可以看出 eureka是通过一个定时线程定时去更新集群的节点信息达到对集群节点的动态发现和感知，在上面我们可以看到更新操作主要由updatePeerEurekaNodes方法完成，下面查看此方法的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647protected void updatePeerEurekaNodes(List&lt;String&gt; newPeerUrls) &#123; if (newPeerUrls.isEmpty()) &#123; logger.warn(\"The replica size seems to be empty. Check the route 53 DNS Registry\"); return; &#125; Set&lt;String&gt; toShutdown = new HashSet&lt;&gt;(peerEurekaNodeUrls); toShutdown.removeAll(newPeerUrls); Set&lt;String&gt; toAdd = new HashSet&lt;&gt;(newPeerUrls); toAdd.removeAll(peerEurekaNodeUrls); //校验新的URL集合与旧有的URL集合是否一致，一致，不需要更新直接返回 if (toShutdown.isEmpty() &amp;&amp; toAdd.isEmpty()) &#123; // No change return; &#125; // Remove peers no long available List&lt;PeerEurekaNode&gt; newNodeList = new ArrayList&lt;&gt;(peerEurekaNodes); //移除旧集合中不可用的节点信息 if (!toShutdown.isEmpty()) &#123; logger.info(\"Removing no longer available peer nodes &#123;&#125;\", toShutdown); int i = 0; while (i &lt; newNodeList.size()) &#123; PeerEurekaNode eurekaNode = newNodeList.get(i); if (toShutdown.contains(eurekaNode.getServiceUrl())) &#123; newNodeList.remove(i); eurekaNode.shutDown(); &#125; else &#123; i++; &#125; &#125; &#125; //添加新增加的节点信息 // Add new peers if (!toAdd.isEmpty()) &#123; logger.info(\"Adding new peer nodes &#123;&#125;\", toAdd); for (String peerUrl : toAdd) &#123; newNodeList.add(createPeerEurekaNode(peerUrl)); &#125; &#125; //重新赋值peerEurekaNodes与peerEurekaNodeUrls this.peerEurekaNodes = newNodeList; this.peerEurekaNodeUrls = new HashSet&lt;&gt;(newPeerUrls);&#125; updatePeerEurekaNodes根据传入的新集群URL集合完成节点的更新 校验传入的URL集合是否需要更新 移除新url集合中没有的旧节点并关闭节点 创建旧节点集合中没有的新URL节点通过createPeerEurekaNode方法 重新赋值节点集合以及URL集合完成节点的更新 updatePeerEurekaNodes传入的新URL集合是通过resolvePeerUrls方法获取，这个方法实际上是解析配置文件中的eureka.serviceUrl前缀的配置获取，并动态监听配置的更新。 创建新的节点是通过createPeerEurekaNode创建，下面查看此方法源码 12345678910111213141516/** * 根据URL创建server新节点信息 * @param peerEurekaNodeUrl * @return */protected PeerEurekaNode createPeerEurekaNode(String peerEurekaNodeUrl) &#123; //创建一个连接远程节点的客户端 HttpReplicationClient replicationClient = JerseyReplicationClient.createReplicationClient(serverConfig, serverCodecs, peerEurekaNodeUrl); //获取新节点host信息 String targetHost = hostFromUrl(peerEurekaNodeUrl); if (targetHost == null) &#123; targetHost = \"host\"; &#125; //创建新节点 return new PeerEurekaNode(registry, targetHost, peerEurekaNodeUrl, replicationClient, serverConfig);&#125; PeerEurekaNode 方法 创建远程通讯客户端replicationClient 用户与此节点间通讯，数据同步等工作 获取要创建的远程节点的host 创建一个表示远程节点实例 PeerEurekaNode PeerEurekaNode 表示一个与当前节点对等的远程节点，当前节点与远程节点的数据同步工作都是在此实例中完成的。 集群节点数据同步 在上面节点发现中知道eureka是通过PeerEurekaNode表示远程对等接点，并将远程通讯客户端replicationClient传入到PeerEurekaNode中，接下来通过查看PeerEurekaNode源码来看eureka集群节点间都有那些数据需要同步以及通讯内容 1234567891011121314151617181920212223242526272829/* For testing */ PeerEurekaNode(PeerAwareInstanceRegistry registry, String targetHost, String serviceUrl, HttpReplicationClient replicationClient, EurekaServerConfig config, int batchSize, long maxBatchingDelayMs, long retrySleepTimeMs, long serverUnavailableSleepTimeMs) &#123; String batcherName = getBatcherName(); //任务处理器 ReplicationTaskProcessor taskProcessor = new ReplicationTaskProcessor(targetHost, replicationClient); //创建一个批量执行的任务调度器 this.batchingDispatcher = TaskDispatchers.createBatchingTaskDispatcher( batcherName, config.getMaxElementsInPeerReplicationPool(), batchSize, config.getMaxThreadsForPeerReplication(), maxBatchingDelayMs, serverUnavailableSleepTimeMs, retrySleepTimeMs, taskProcessor ); //创建一个单任务调度器 this.nonBatchingDispatcher = TaskDispatchers.createNonBatchingTaskDispatcher( targetHost, config.getMaxElementsInStatusReplicationPool(), config.getMaxThreadsForStatusReplication(), maxBatchingDelayMs, serverUnavailableSleepTimeMs, retrySleepTimeMs, taskProcessor );&#125; PeerEurekaNode 完成以下事件 创建数据同步的任务处理器ReplicationTaskProcessor 创建批处理任务调度器 创建单任务处理调度器 说明: eureka将节点间的数据同步工作包装成一个个细微的任务ReplicationTask ，每一个数据操作代表一个任务，将任务发送给任务调度器TaskDispatcher去异步处理。 下来查看PeerEurekaNode都可以创建那些同步任务 register 1234567891011121314151617181920212223/** * 当eureka server注册新服务时，同时创建一个定时任务将新服务同步到集群其它节点 * Sends the registration information of &#123;@link InstanceInfo&#125; receiving by * this node to the peer node represented by this class. * * @param info * the instance information &#123;@link InstanceInfo&#125; of any instance * that is send to this instance. * @throws Exception */public void register(final InstanceInfo info) throws Exception &#123; long expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info); //任务调度器中添加一个请求类型为注册register新服务的同步任务 batchingDispatcher.process( taskId(\"register\", info), new InstanceReplicationTask(targetHost, Action.Register, info, null, true) &#123; public EurekaHttpResponse&lt;Void&gt; execute() &#123; return replicationClient.register(info); &#125; &#125;, expiryTime );&#125; 注册同步任务，当有服务注册到当前节点时，通过注册同步任务将服务信息同步到集群远程节点 cancel 12345678910111213141516171819202122public void cancel(final String appName, final String id) throws Exception &#123; long expiryTime = System.currentTimeMillis() + maxProcessingDelayMs; //任务调度器中添加一个请求类型为取消cancel服务的同步任务 batchingDispatcher.process( taskId(\"cancel\", appName, id), new InstanceReplicationTask(targetHost, Action.Cancel, appName, id) &#123; @Override public EurekaHttpResponse&lt;Void&gt; execute() &#123; return replicationClient.cancel(appName, id); &#125; @Override public void handleFailure(int statusCode, Object responseEntity) throws Throwable &#123; super.handleFailure(statusCode, responseEntity); if (statusCode == 404) &#123; logger.warn(\"&#123;&#125;: missing entry.\", getTaskName()); &#125; &#125; &#125;, expiryTime ); &#125; 取消服务注册任务，当前节点有服务取消注册，将信息同步到集群远程节点 heartbeat 1234567891011121314151617181920212223242526272829303132333435363738public void heartbeat(final String appName, final String id, final InstanceInfo info, final InstanceStatus overriddenStatus, boolean primeConnection) throws Throwable &#123; //当第一次连接时直接发送心跳到远端 if (primeConnection) &#123; // We do not care about the result for priming request. replicationClient.sendHeartBeat(appName, id, info, overriddenStatus); return; &#125; //心跳同步任务 ReplicationTask replicationTask = new InstanceReplicationTask(targetHost, Action.Heartbeat, info, overriddenStatus, false) &#123; @Override public EurekaHttpResponse&lt;InstanceInfo&gt; execute() throws Throwable &#123; return replicationClient.sendHeartBeat(appName, id, info, overriddenStatus); &#125; @Override public void handleFailure(int statusCode, Object responseEntity) throws Throwable &#123; super.handleFailure(statusCode, responseEntity); if (statusCode == 404) &#123; logger.warn(&quot;&#123;&#125;: missing entry.&quot;, getTaskName()); if (info != null) &#123; logger.warn(&quot;&#123;&#125;: cannot find instance id &#123;&#125; and hence replicating the instance with status &#123;&#125;&quot;, getTaskName(), info.getId(), info.getStatus()); register(info); &#125; &#125; else if (config.shouldSyncWhenTimestampDiffers()) &#123; InstanceInfo peerInstanceInfo = (InstanceInfo) responseEntity; if (peerInstanceInfo != null) &#123; syncInstancesIfTimestampDiffers(appName, id, info, peerInstanceInfo); &#125; &#125; &#125; &#125;; long expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info); //任务调度器中添加一个请求类型为heartbeat服务的同步任务 batchingDispatcher.process(taskId(&quot;heartbeat&quot;, info), replicationTask, expiryTime);&#125; 心跳同步任务，当前节点有服务发送心跳续租，将信息同步到集群远程节点 StatusUpdate DeleteStatusOverride 集群节点数据同步任务处理 在PeerEurekaNode的构造函数中可以看到同步任务处理由ReplicationTaskProcessor完成，下面看此类源码 123456789101112131415161718192021222324252627282930313233343536/** * 单个处理ReplicationTask任务 * @param task * @return */ @Override public ProcessingResult process(ReplicationTask task) &#123; try &#123; //调用任务execute方法，完成任务的执行 EurekaHttpResponse&lt;?&gt; httpResponse = task.execute(); int statusCode = httpResponse.getStatusCode(); //判断任务返回结果 Object entity = httpResponse.getEntity(); if (logger.isDebugEnabled()) &#123; logger.debug(\"Replication task &#123;&#125; completed with status &#123;&#125;, (includes entity &#123;&#125;)\", task.getTaskName(), statusCode, entity != null); &#125; if (isSuccess(statusCode)) &#123; task.handleSuccess(); &#125; else if (statusCode == 503) &#123; logger.debug(\"Server busy (503) reply for task &#123;&#125;\", task.getTaskName()); return ProcessingResult.Congestion; &#125; else &#123; task.handleFailure(statusCode, entity); return ProcessingResult.PermanentError; &#125; &#125; catch (Throwable e) &#123; if (isNetworkConnectException(e)) &#123; logNetworkErrorSample(task, e); return ProcessingResult.TransientError; &#125; else &#123; logger.error(peerId + \": \" + task.getTaskName() + \"Not re-trying this exception because it does not seem to be a network exception\", e); return ProcessingResult.PermanentError; &#125; &#125; return ProcessingResult.Success; &#125; 单任务处理 调用任务task的execute完成远程数据同步 分析远程返回结果 12345678910111213141516171819202122232425262728293031323334353637/** * 批量处理ReplicationTask任务 * @param tasks * @return */ @Override public ProcessingResult process(List&lt;ReplicationTask&gt; tasks) &#123; //根据task集合创建ReplicationList ReplicationList list = createReplicationListOf(tasks); try &#123; //调用批量同步接口 将同步集合发送到远端节点同步数据 EurekaHttpResponse&lt;ReplicationListResponse&gt; response = replicationClient.submitBatchUpdates(list); //判断同步返回结果 int statusCode = response.getStatusCode(); if (!isSuccess(statusCode)) &#123; if (statusCode == 503) &#123; logger.warn(\"Server busy (503) HTTP status code received from the peer &#123;&#125;; rescheduling tasks after delay\", peerId); return ProcessingResult.Congestion; &#125; else &#123; // Unexpected error returned from the server. This should ideally never happen. logger.error(\"Batch update failure with HTTP status code &#123;&#125;; discarding &#123;&#125; replication tasks\", statusCode, tasks.size()); return ProcessingResult.PermanentError; &#125; &#125; else &#123; handleBatchResponse(tasks, response.getEntity().getResponseList()); &#125; &#125; catch (Throwable e) &#123; if (isNetworkConnectException(e)) &#123; logNetworkErrorSample(null, e); return ProcessingResult.TransientError; &#125; else &#123; logger.error(\"Not re-trying this exception because it does not seem to be a network exception\", e); return ProcessingResult.PermanentError; &#125; &#125; return ProcessingResult.Success; &#125; 批处理任务，将一组任务一次性发送到远程进行处理 根据task集合创建ReplicationList 调用批量同步接口将同步集合发送到远端节点同步数据 即调用rest API /{version}/peerreplication 分析远程返回结果 eureka 服务端 集群节点发现，数据同步功能主要是由PeerEurekaNodes与PeerEurekaNode类实现,通过源码的跟踪可以清晰看出集群实现的逻辑，方便在实际应用中对问题的定位","categories":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"Eureka","slug":"Eureka","permalink":"https://guofazhan.github.io/tags/Eureka/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-23T06:37:01.950Z","updated":"2018-08-23T06:37:01.951Z","comments":true,"path":"2018/08/23/hello-world/","link":"","permalink":"https://guofazhan.github.io/2018/08/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}