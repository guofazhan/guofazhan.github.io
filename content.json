{"meta":{"title":"Mr.G-博客","subtitle":"博客","description":"学习分享、源码阅读、笔记","author":"Mr.G","url":"https://guofazhan.github.io"},"pages":[{"title":"","date":"2018-08-23T11:32:07.768Z","updated":"2018-08-23T11:32:07.720Z","comments":true,"path":"about/index.html","permalink":"https://guofazhan.github.io/about/index.html","excerpt":"","text":"关于 作者：guofazhan 邮箱：guofazhan@hotmail.com"}],"posts":[{"title":"Eureka之REST API","slug":"Eureka之REST-API-1","date":"2018-08-23T09:50:00.000Z","updated":"2018-08-23T11:33:14.319Z","comments":true,"path":"2018/08/23/Eureka之REST-API-1/","link":"","permalink":"https://guofazhan.github.io/2018/08/23/Eureka之REST-API-1/","excerpt":"Eureka服务端与客户之间的通讯方式为http，服务端通过提供rest API风格的接口与客户端或其它服务端交互。 交互数据格式 JSON/XML 提供资源服务的包路径 com.netflix.eureka.resources","text":"Eureka服务端与客户之间的通讯方式为http，服务端通过提供rest API风格的接口与客户端或其它服务端交互。 交互数据格式 JSON/XML 提供资源服务的包路径 com.netflix.eureka.resources 提供可使用的REST API接口 /{version}/apps 路径 /{version}/instances 路径 /{version}/status 路径 /{version}/peerreplication 路径 /{version}/vips 路径 /{version}/svips 路径","categories":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"Eureka","slug":"Eureka","permalink":"https://guofazhan.github.io/tags/Eureka/"}]},{"title":"Eureka之服务注册数据模型","slug":"Eureka之服务注册数据模型","date":"2018-08-23T09:43:00.000Z","updated":"2018-08-23T11:33:43.847Z","comments":true,"path":"2018/08/23/Eureka之服务注册数据模型/","link":"","permalink":"https://guofazhan.github.io/2018/08/23/Eureka之服务注册数据模型/","excerpt":"Eureka 作为注册中心，担任着服务节点的注册以及发现，并提供着动态的管理（坏点摘除，服务检测等）。可以说是整个系统的基础设施。 注册列表的数据模型","text":"Eureka 作为注册中心，担任着服务节点的注册以及发现，并提供着动态的管理（坏点摘除，服务检测等）。可以说是整个系统的基础设施。 注册列表的数据模型 1. Applications 注册列表，包含注册到当前注册中心上的所有实例信息，每个注册中心在内存中保持一份数据。在Applications中持有Application的队列 2. Application 注册到注册中心的服务集群信息，Application可以看做为一组对外提供相同服务的集群列表。在Application包含一组提供相同服务的InstanceInfo集合 3. InstanceInfo 注册列表里的单个服务实例信息，代表系统中提供一项服务的某个节点，里面包含节点的基础信息，以及唯一标识instanceId。 4. DataCenterInfo 服务实例所在的数据中心，默认为MyOwn，为InstanceInfo子属性 5. LeaseInfo 服务实例的租约信息，用于对服务做健康检查，续租，过期等服务可用性的管理。为InstanceInfo子属性 通过数据模型图可以清楚的看到Eureka将我们系统中的服务信息抽象成5个对象进行精细化的管理。我们注册进去的服务信息都将实例化成上述对象存储在eureka的服务端内存中，从而对外提供服务的注册以及发现。","categories":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"Eureka","slug":"Eureka","permalink":"https://guofazhan.github.io/tags/Eureka/"}]},{"title":"Eureka之server端集群节点发现，数据同步","slug":"Eureka之server端集群节点发现，数据同步-1","date":"2018-08-23T09:36:00.000Z","updated":"2018-08-23T11:34:19.091Z","comments":true,"path":"2018/08/23/Eureka之server端集群节点发现，数据同步-1/","link":"","permalink":"https://guofazhan.github.io/2018/08/23/Eureka之server端集群节点发现，数据同步-1/","excerpt":"Eureka服务端支持集群部署，通过源码查看集群节点发现以及数据同步功能的实现 提供集群功能的包路径 com.netflix.eureka.cluster 集群节点发现以及动态更新节点功能 Eureka服务端封装了一个集群节点管理的类名称为PeerEurekaNodes 通过名称翻译出来为对等的Eureka节点集合，可以看出这个类是对eureka服务端集群节点抽象，下面通过源码查询eureka是怎么管理与发现节点信息 123456789101112131415161718192021/** * eureka server 集群节点 集合类 帮助管理维护集群节点 * Helper class to manage lifecycle of a collection of &#123;@link PeerEurekaNode&#125;s. * * @author Tomasz Bak */@Singletonpublic class PeerEurekaNodes &#123; /** * 集群节点集合 */ private volatile List&lt;PeerEurekaNode&gt; peerEurekaNodes = Collections.emptyList(); /** * 集群节点URL集合 */ private volatile Set&lt;String&gt; peerEurekaNodeUrls = Collections.emptySet(); /** * 定时任务线程池 */ private ScheduledExecutorService taskExecutor; 通过PeerEurekaNodes类属性可以看到提供了两个集合以及一个执行定时任务的线程池，其它配置属性忽略 peerEurekaNodes 表示集群节点集合 peerEurekaNodeUrls 表示集群节点对应的URL集合 taskExecutor 执行定时任务的线程池","text":"Eureka服务端支持集群部署，通过源码查看集群节点发现以及数据同步功能的实现 提供集群功能的包路径 com.netflix.eureka.cluster 集群节点发现以及动态更新节点功能 Eureka服务端封装了一个集群节点管理的类名称为PeerEurekaNodes 通过名称翻译出来为对等的Eureka节点集合，可以看出这个类是对eureka服务端集群节点抽象，下面通过源码查询eureka是怎么管理与发现节点信息 123456789101112131415161718192021/** * eureka server 集群节点 集合类 帮助管理维护集群节点 * Helper class to manage lifecycle of a collection of &#123;@link PeerEurekaNode&#125;s. * * @author Tomasz Bak */@Singletonpublic class PeerEurekaNodes &#123; /** * 集群节点集合 */ private volatile List&lt;PeerEurekaNode&gt; peerEurekaNodes = Collections.emptyList(); /** * 集群节点URL集合 */ private volatile Set&lt;String&gt; peerEurekaNodeUrls = Collections.emptySet(); /** * 定时任务线程池 */ private ScheduledExecutorService taskExecutor; 通过PeerEurekaNodes类属性可以看到提供了两个集合以及一个执行定时任务的线程池，其它配置属性忽略 peerEurekaNodes 表示集群节点集合 peerEurekaNodeUrls 表示集群节点对应的URL集合 taskExecutor 执行定时任务的线程池 同时 PeerEurekaNodes 类提供start 与shutdown方法，接下来主要看start方法的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 /** * 启动方法，此方法管理集群节点间的通讯 */ public void start() &#123; //初始化定时任务线程池 taskExecutor = Executors.newSingleThreadScheduledExecutor( new ThreadFactory() &#123; @Override public Thread newThread(Runnable r) &#123; Thread thread = new Thread(r, \"Eureka-PeerNodesUpdater\"); thread.setDaemon(true); return thread; &#125; &#125; ); try &#123; updatePeerEurekaNodes(resolvePeerUrls()); //节点更新任务线程 Runnable peersUpdateTask = new Runnable() &#123; @Override public void run() &#123; try &#123; updatePeerEurekaNodes(resolvePeerUrls()); &#125; catch (Throwable e) &#123; logger.error(\"Cannot update the replica Nodes\", e); &#125; &#125; &#125;;// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。// 如果任务的任一执行遇到异常，就会取消后续执行。否则，只能通过执行程序的取消或终止方法来终止该任务。// 参数：// command - 要执行的任务// initialdelay - 首次执行的延迟时间// delay - 一次执行终止和下一次执行开始之间的延迟// unit - initialdelay 和 delay 参数的时间单位 //定时执行节点更新任务线程 taskExecutor.scheduleWithFixedDelay( peersUpdateTask, serverConfig.getPeerEurekaNodesUpdateIntervalMs(), serverConfig.getPeerEurekaNodesUpdateIntervalMs(), TimeUnit.MILLISECONDS ); &#125; catch (Exception e) &#123; throw new IllegalStateException(e); &#125; for (PeerEurekaNode node : peerEurekaNodes) &#123; logger.info(\"Replica node URL: \" + node.getServiceUrl()); &#125; &#125; start 方法主要完成以下几件事 初始化定时任务线程池 首次更新集群节点 updatePeerEurekaNodes方法 创建更新集群节点任务线程 通过定时任务线程池定时执行更新集群节点线程 通过start 可以看出 eureka是通过一个定时线程定时去更新集群的节点信息达到对集群节点的动态发现和感知，在上面我们可以看到更新操作主要由updatePeerEurekaNodes方法完成，下面查看此方法的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647protected void updatePeerEurekaNodes(List&lt;String&gt; newPeerUrls) &#123; if (newPeerUrls.isEmpty()) &#123; logger.warn(\"The replica size seems to be empty. Check the route 53 DNS Registry\"); return; &#125; Set&lt;String&gt; toShutdown = new HashSet&lt;&gt;(peerEurekaNodeUrls); toShutdown.removeAll(newPeerUrls); Set&lt;String&gt; toAdd = new HashSet&lt;&gt;(newPeerUrls); toAdd.removeAll(peerEurekaNodeUrls); //校验新的URL集合与旧有的URL集合是否一致，一致，不需要更新直接返回 if (toShutdown.isEmpty() &amp;&amp; toAdd.isEmpty()) &#123; // No change return; &#125; // Remove peers no long available List&lt;PeerEurekaNode&gt; newNodeList = new ArrayList&lt;&gt;(peerEurekaNodes); //移除旧集合中不可用的节点信息 if (!toShutdown.isEmpty()) &#123; logger.info(\"Removing no longer available peer nodes &#123;&#125;\", toShutdown); int i = 0; while (i &lt; newNodeList.size()) &#123; PeerEurekaNode eurekaNode = newNodeList.get(i); if (toShutdown.contains(eurekaNode.getServiceUrl())) &#123; newNodeList.remove(i); eurekaNode.shutDown(); &#125; else &#123; i++; &#125; &#125; &#125; //添加新增加的节点信息 // Add new peers if (!toAdd.isEmpty()) &#123; logger.info(\"Adding new peer nodes &#123;&#125;\", toAdd); for (String peerUrl : toAdd) &#123; newNodeList.add(createPeerEurekaNode(peerUrl)); &#125; &#125; //重新赋值peerEurekaNodes与peerEurekaNodeUrls this.peerEurekaNodes = newNodeList; this.peerEurekaNodeUrls = new HashSet&lt;&gt;(newPeerUrls);&#125; updatePeerEurekaNodes根据传入的新集群URL集合完成节点的更新 校验传入的URL集合是否需要更新 移除新url集合中没有的旧节点并关闭节点 创建旧节点集合中没有的新URL节点通过createPeerEurekaNode方法 重新赋值节点集合以及URL集合完成节点的更新 updatePeerEurekaNodes传入的新URL集合是通过resolvePeerUrls方法获取，这个方法实际上是解析配置文件中的eureka.serviceUrl前缀的配置获取，并动态监听配置的更新。 创建新的节点是通过createPeerEurekaNode创建，下面查看此方法源码 12345678910111213141516/** * 根据URL创建server新节点信息 * @param peerEurekaNodeUrl * @return */protected PeerEurekaNode createPeerEurekaNode(String peerEurekaNodeUrl) &#123; //创建一个连接远程节点的客户端 HttpReplicationClient replicationClient = JerseyReplicationClient.createReplicationClient(serverConfig, serverCodecs, peerEurekaNodeUrl); //获取新节点host信息 String targetHost = hostFromUrl(peerEurekaNodeUrl); if (targetHost == null) &#123; targetHost = \"host\"; &#125; //创建新节点 return new PeerEurekaNode(registry, targetHost, peerEurekaNodeUrl, replicationClient, serverConfig);&#125; PeerEurekaNode 方法 创建远程通讯客户端replicationClient 用户与此节点间通讯，数据同步等工作 获取要创建的远程节点的host 创建一个表示远程节点实例 PeerEurekaNode PeerEurekaNode 表示一个与当前节点对等的远程节点，当前节点与远程节点的数据同步工作都是在此实例中完成的。 集群节点数据同步 在上面节点发现中知道eureka是通过PeerEurekaNode表示远程对等接点，并将远程通讯客户端replicationClient传入到PeerEurekaNode中，接下来通过查看PeerEurekaNode源码来看eureka集群节点间都有那些数据需要同步以及通讯内容 1234567891011121314151617181920212223242526272829/* For testing */ PeerEurekaNode(PeerAwareInstanceRegistry registry, String targetHost, String serviceUrl, HttpReplicationClient replicationClient, EurekaServerConfig config, int batchSize, long maxBatchingDelayMs, long retrySleepTimeMs, long serverUnavailableSleepTimeMs) &#123; String batcherName = getBatcherName(); //任务处理器 ReplicationTaskProcessor taskProcessor = new ReplicationTaskProcessor(targetHost, replicationClient); //创建一个批量执行的任务调度器 this.batchingDispatcher = TaskDispatchers.createBatchingTaskDispatcher( batcherName, config.getMaxElementsInPeerReplicationPool(), batchSize, config.getMaxThreadsForPeerReplication(), maxBatchingDelayMs, serverUnavailableSleepTimeMs, retrySleepTimeMs, taskProcessor ); //创建一个单任务调度器 this.nonBatchingDispatcher = TaskDispatchers.createNonBatchingTaskDispatcher( targetHost, config.getMaxElementsInStatusReplicationPool(), config.getMaxThreadsForStatusReplication(), maxBatchingDelayMs, serverUnavailableSleepTimeMs, retrySleepTimeMs, taskProcessor );&#125; PeerEurekaNode 完成以下事件 创建数据同步的任务处理器ReplicationTaskProcessor 创建批处理任务调度器 创建单任务处理调度器 说明: eureka将节点间的数据同步工作包装成一个个细微的任务ReplicationTask ，每一个数据操作代表一个任务，将任务发送给任务调度器TaskDispatcher去异步处理。 下来查看PeerEurekaNode都可以创建那些同步任务 register 1234567891011121314151617181920212223/** * 当eureka server注册新服务时，同时创建一个定时任务将新服务同步到集群其它节点 * Sends the registration information of &#123;@link InstanceInfo&#125; receiving by * this node to the peer node represented by this class. * * @param info * the instance information &#123;@link InstanceInfo&#125; of any instance * that is send to this instance. * @throws Exception */public void register(final InstanceInfo info) throws Exception &#123; long expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info); //任务调度器中添加一个请求类型为注册register新服务的同步任务 batchingDispatcher.process( taskId(\"register\", info), new InstanceReplicationTask(targetHost, Action.Register, info, null, true) &#123; public EurekaHttpResponse&lt;Void&gt; execute() &#123; return replicationClient.register(info); &#125; &#125;, expiryTime );&#125; 注册同步任务，当有服务注册到当前节点时，通过注册同步任务将服务信息同步到集群远程节点 cancel 12345678910111213141516171819202122public void cancel(final String appName, final String id) throws Exception &#123; long expiryTime = System.currentTimeMillis() + maxProcessingDelayMs; //任务调度器中添加一个请求类型为取消cancel服务的同步任务 batchingDispatcher.process( taskId(\"cancel\", appName, id), new InstanceReplicationTask(targetHost, Action.Cancel, appName, id) &#123; @Override public EurekaHttpResponse&lt;Void&gt; execute() &#123; return replicationClient.cancel(appName, id); &#125; @Override public void handleFailure(int statusCode, Object responseEntity) throws Throwable &#123; super.handleFailure(statusCode, responseEntity); if (statusCode == 404) &#123; logger.warn(\"&#123;&#125;: missing entry.\", getTaskName()); &#125; &#125; &#125;, expiryTime ); &#125; 取消服务注册任务，当前节点有服务取消注册，将信息同步到集群远程节点 heartbeat 1234567891011121314151617181920212223242526272829303132333435363738public void heartbeat(final String appName, final String id, final InstanceInfo info, final InstanceStatus overriddenStatus, boolean primeConnection) throws Throwable &#123; //当第一次连接时直接发送心跳到远端 if (primeConnection) &#123; // We do not care about the result for priming request. replicationClient.sendHeartBeat(appName, id, info, overriddenStatus); return; &#125; //心跳同步任务 ReplicationTask replicationTask = new InstanceReplicationTask(targetHost, Action.Heartbeat, info, overriddenStatus, false) &#123; @Override public EurekaHttpResponse&lt;InstanceInfo&gt; execute() throws Throwable &#123; return replicationClient.sendHeartBeat(appName, id, info, overriddenStatus); &#125; @Override public void handleFailure(int statusCode, Object responseEntity) throws Throwable &#123; super.handleFailure(statusCode, responseEntity); if (statusCode == 404) &#123; logger.warn(&quot;&#123;&#125;: missing entry.&quot;, getTaskName()); if (info != null) &#123; logger.warn(&quot;&#123;&#125;: cannot find instance id &#123;&#125; and hence replicating the instance with status &#123;&#125;&quot;, getTaskName(), info.getId(), info.getStatus()); register(info); &#125; &#125; else if (config.shouldSyncWhenTimestampDiffers()) &#123; InstanceInfo peerInstanceInfo = (InstanceInfo) responseEntity; if (peerInstanceInfo != null) &#123; syncInstancesIfTimestampDiffers(appName, id, info, peerInstanceInfo); &#125; &#125; &#125; &#125;; long expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info); //任务调度器中添加一个请求类型为heartbeat服务的同步任务 batchingDispatcher.process(taskId(&quot;heartbeat&quot;, info), replicationTask, expiryTime);&#125; 心跳同步任务，当前节点有服务发送心跳续租，将信息同步到集群远程节点 StatusUpdate DeleteStatusOverride 集群节点数据同步任务处理 在PeerEurekaNode的构造函数中可以看到同步任务处理由ReplicationTaskProcessor完成，下面看此类源码 123456789101112131415161718192021222324252627282930313233343536/** * 单个处理ReplicationTask任务 * @param task * @return */ @Override public ProcessingResult process(ReplicationTask task) &#123; try &#123; //调用任务execute方法，完成任务的执行 EurekaHttpResponse&lt;?&gt; httpResponse = task.execute(); int statusCode = httpResponse.getStatusCode(); //判断任务返回结果 Object entity = httpResponse.getEntity(); if (logger.isDebugEnabled()) &#123; logger.debug(\"Replication task &#123;&#125; completed with status &#123;&#125;, (includes entity &#123;&#125;)\", task.getTaskName(), statusCode, entity != null); &#125; if (isSuccess(statusCode)) &#123; task.handleSuccess(); &#125; else if (statusCode == 503) &#123; logger.debug(\"Server busy (503) reply for task &#123;&#125;\", task.getTaskName()); return ProcessingResult.Congestion; &#125; else &#123; task.handleFailure(statusCode, entity); return ProcessingResult.PermanentError; &#125; &#125; catch (Throwable e) &#123; if (isNetworkConnectException(e)) &#123; logNetworkErrorSample(task, e); return ProcessingResult.TransientError; &#125; else &#123; logger.error(peerId + \": \" + task.getTaskName() + \"Not re-trying this exception because it does not seem to be a network exception\", e); return ProcessingResult.PermanentError; &#125; &#125; return ProcessingResult.Success; &#125; 单任务处理 调用任务task的execute完成远程数据同步 分析远程返回结果 12345678910111213141516171819202122232425262728293031323334353637/** * 批量处理ReplicationTask任务 * @param tasks * @return */ @Override public ProcessingResult process(List&lt;ReplicationTask&gt; tasks) &#123; //根据task集合创建ReplicationList ReplicationList list = createReplicationListOf(tasks); try &#123; //调用批量同步接口 将同步集合发送到远端节点同步数据 EurekaHttpResponse&lt;ReplicationListResponse&gt; response = replicationClient.submitBatchUpdates(list); //判断同步返回结果 int statusCode = response.getStatusCode(); if (!isSuccess(statusCode)) &#123; if (statusCode == 503) &#123; logger.warn(\"Server busy (503) HTTP status code received from the peer &#123;&#125;; rescheduling tasks after delay\", peerId); return ProcessingResult.Congestion; &#125; else &#123; // Unexpected error returned from the server. This should ideally never happen. logger.error(\"Batch update failure with HTTP status code &#123;&#125;; discarding &#123;&#125; replication tasks\", statusCode, tasks.size()); return ProcessingResult.PermanentError; &#125; &#125; else &#123; handleBatchResponse(tasks, response.getEntity().getResponseList()); &#125; &#125; catch (Throwable e) &#123; if (isNetworkConnectException(e)) &#123; logNetworkErrorSample(null, e); return ProcessingResult.TransientError; &#125; else &#123; logger.error(\"Not re-trying this exception because it does not seem to be a network exception\", e); return ProcessingResult.PermanentError; &#125; &#125; return ProcessingResult.Success; &#125; 批处理任务，将一组任务一次性发送到远程进行处理 根据task集合创建ReplicationList 调用批量同步接口将同步集合发送到远端节点同步数据 即调用rest API /{version}/peerreplication 分析远程返回结果 eureka 服务端 集群节点发现，数据同步功能主要是由PeerEurekaNodes与PeerEurekaNode类实现,通过源码的跟踪可以清晰看出集群实现的逻辑，方便在实际应用中对问题的定位","categories":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://guofazhan.github.io/tags/微服务/"},{"name":"Eureka","slug":"Eureka","permalink":"https://guofazhan.github.io/tags/Eureka/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-23T06:37:01.950Z","updated":"2018-08-23T06:37:01.951Z","comments":true,"path":"2018/08/23/hello-world/","link":"","permalink":"https://guofazhan.github.io/2018/08/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}