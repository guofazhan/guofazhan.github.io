<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>zuul之过滤器Filter管理</title>
      <link href="/2018/11/23/zuul%E4%B9%8B%E8%BF%87%E6%BB%A4%E5%99%A8Filter%E7%AE%A1%E7%90%86/"/>
      <url>/2018/11/23/zuul%E4%B9%8B%E8%BF%87%E6%BB%A4%E5%99%A8Filter%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li><a href="https://guofazhan.github.io/2018/11/23/zuul%E4%B9%8B%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/">zuul之请求处理流程</a></li><li><a href="https://guofazhan.github.io/2018/11/23/zuul%E4%B9%8B%E5%8A%A8%E6%80%81%E8%BF%87%E6%BB%A4%E5%99%A8Filter%E7%B1%BB%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8A%A0%E8%BD%BD/">zuul之动态过滤器Filter类文件管理加载</a></li><li><a href="https://guofazhan.github.io/2018/11/23/zuul%E4%B9%8B%E8%BF%87%E6%BB%A4%E5%99%A8Filter%E7%AE%A1%E7%90%86/">zuul之过滤器Filter管理</a></li></ul><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><p>zuul通过FilterLoader类负责filter的管理，是ZUUL的核心类之一。它编译、从文件加载，并检查源代码是否更改。它还包含按filterType的ZuulFilters。此类再如下两处使用：</p><ol><li><a href="https://www.jianshu.com/p/f892839eb24d" target="_blank" rel="noopener">zuul之请求处理流程</a>:FilterProcessor 通过FilterLoader加载给定类型的过滤器列表</li><li><a href="https://www.jianshu.com/p/a9ce9349828e" target="_blank" rel="noopener">zuul之动态过滤器Filter类文件管理加载</a>:调用processGroovyFiles方法遍历filter列表通过FilterLoader类处理加载Filter<a id="more"></a></li></ol></blockquote><h4 id="FilterLoader"><a href="#FilterLoader" class="headerlink" title="FilterLoader"></a>FilterLoader</h4><ul><li>根据过滤器类型获取过滤器列表<blockquote><p>FilterLoader 中缓存了所有过滤器的集合，可以根据过滤器的类型获取对应的过滤器列表</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ZuulFilter&gt; <span class="title">getFiltersByType</span><span class="params">(String filterType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//在缓存中获取当前类型的过滤器列表</span></span><br><span class="line">        List&lt;ZuulFilter&gt; list = hashFiltersByType.get(filterType);</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;ZuulFilter&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//通过filterRegistry获取所有过滤器</span></span><br><span class="line">        Collection&lt;ZuulFilter&gt; filters = filterRegistry.getAllFilters();</span><br><span class="line">        <span class="comment">//遍历筛选过滤器获取给定的列表</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;ZuulFilter&gt; iterator = filters.iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">            ZuulFilter filter = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (filter.filterType().equals(filterType)) &#123;</span><br><span class="line">                list.add(filter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排序过滤器列表</span></span><br><span class="line">        Collections.sort(list); <span class="comment">// sort by priority</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加到缓存中</span></span><br><span class="line">        hashFiltersByType.putIfAbsent(filterType, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>getFiltersByType</p><ul><li>在缓存中查找给定的类型列表</li><li>当前缓存为空时，通过全部过滤器列表缓存遍历组装给定类型的列表并缓存返回</li></ul></blockquote><ul><li>通过过滤器源码加载编译过滤器并缓存</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putFilter</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">// 获取类文件的全名</span></span><br><span class="line">    String sName = file.getAbsolutePath() + file.getName();</span><br><span class="line">    <span class="comment">//校验类文件是否修改过，根据类文件的最后修改时间判断</span></span><br><span class="line">    <span class="keyword">if</span> (filterClassLastModified.get(sName) != <span class="keyword">null</span> &amp;&amp; (file.lastModified() != filterClassLastModified.get(sName))) &#123;</span><br><span class="line">    <span class="comment">// 类文件修改过时，删除全局缓存中当前过滤器的信息</span></span><br><span class="line">        LOG.debug(<span class="string">"reloading filter "</span> + sName);</span><br><span class="line">        filterRegistry.remove(sName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在全局缓存中判断是否存在当前过滤器</span></span><br><span class="line">    ZuulFilter filter = filterRegistry.get(sName);</span><br><span class="line">    <span class="keyword">if</span> (filter == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//缓存中无当前要加载的过滤器时，编译当前类文件</span></span><br><span class="line">        Class clazz = COMPILER.compile(file);</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isAbstract(clazz.getModifiers())) &#123;</span><br><span class="line">           <span class="comment">// 反射创建通过class创建过滤器对象</span></span><br><span class="line">            filter = (ZuulFilter) FILTER_FACTORY.newInstance(clazz);</span><br><span class="line">            <span class="comment">//缓存当前过滤器对象</span></span><br><span class="line">            List&lt;ZuulFilter&gt; list = hashFiltersByType.get(filter.filterType());</span><br><span class="line">            <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">                hashFiltersByType.remove(filter.filterType()); <span class="comment">//rebuild this list</span></span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//全局缓存当前过滤器对象 filterRegistry.put(file.getAbsolutePath() + file.getName(), filter);</span></span><br><span class="line">            filterClassLastModified.put(sName, file.lastModified());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>putFilter<br>校验给定的类文件是否变更过，变更过，删除旧缓存信息，编译新源文件并反射创建对象缓存到系统的全局缓存中</p></blockquote><hr><blockquote><p>FilterLoader主要完成了上述两个功能，一个为请求进来获取过滤器列表服务，一个为动态加载变更过滤器服务。至此 zuul的核心功能已经通过源码学习分析完毕</p></blockquote>]]></content>
      
      
    </entry>
    
    <entry>
      <title>zuul之动态过滤器Filter类文件管理加载</title>
      <link href="/2018/11/23/zuul%E4%B9%8B%E5%8A%A8%E6%80%81%E8%BF%87%E6%BB%A4%E5%99%A8Filter%E7%B1%BB%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8A%A0%E8%BD%BD/"/>
      <url>/2018/11/23/zuul%E4%B9%8B%E5%8A%A8%E6%80%81%E8%BF%87%E6%BB%A4%E5%99%A8Filter%E7%B1%BB%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8A%A0%E8%BD%BD/</url>
      <content type="html"><![CDATA[<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li><a href="https://guofazhan.github.io/2018/11/23/zuul%E4%B9%8B%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/">zuul之请求处理流程</a></li><li><a href="https://guofazhan.github.io/2018/11/23/zuul%E4%B9%8B%E5%8A%A8%E6%80%81%E8%BF%87%E6%BB%A4%E5%99%A8Filter%E7%B1%BB%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8A%A0%E8%BD%BD/">zuul之动态过滤器Filter类文件管理加载</a></li><li><a href="https://guofazhan.github.io/2018/11/23/zuul%E4%B9%8B%E8%BF%87%E6%BB%A4%E5%99%A8Filter%E7%AE%A1%E7%90%86/">zuul之过滤器Filter管理</a></li></ul><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><p>zuul 支持过滤器动态修改动态加载功能，目前支持动态Filter由Groovy编写。动态管理Groovy编写的Filter类文件变更以及动态编译等功能。<br><a id="more"></a></p></blockquote><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><blockquote><p>实现原理是监控存放Filter文件的目录，定期扫描这些目录，如果发现有新Filter源码文件或者Filter源码文件有改动，则对文件进行编译加载</p></blockquote><h4 id="Filter类文件动态管理"><a href="#Filter类文件动态管理" class="headerlink" title="Filter类文件动态管理"></a>Filter类文件动态管理</h4><blockquote><p>通过原理知道zuul通过定期扫描Filter文件存放的目录来校验是否有新的文件或有改动的文件，对这些文件进行加载，源码是通过FilterFileManager实现此功能的。FilterFileManager管理目录轮询的变化和新的Groovy过滤器。轮询间隔和目录在类的初始化中指定，并且轮询器将检查,更改和添加。</p></blockquote><hr><blockquote><p>FilterFileManager 功能如下:</p><ul><li>开启一个线程，开始轮询(startPoller)</li><li>每次轮询，处理目录内的所有*.groovy文件，即调用FilterLoader.getInstance().putFilter(file)</li></ul></blockquote><ul><li>轮询部分<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启轮询线程</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">startPoller</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建轮询线程</span></span><br><span class="line">     poller = <span class="keyword">new</span> Thread(<span class="string">"GroovyFilterFileManagerPoller"</span>) &#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">while</span> (bRunning) &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//定时休眠 sleep(pollingIntervalSeconds * 1000);</span></span><br><span class="line">                    <span class="comment">//扫描目录监听目录变化</span></span><br><span class="line">                     manageFiles();</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     poller.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">     <span class="comment">//开启轮询线程</span></span><br><span class="line">     poller.start();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><ul><li>startPoller 开启轮询线程定时调用manageFiles方法执行扫描目录，监听目录变化</li><li>startPoller方法在FilterFileManager初始化时（init）调用一次</li></ul></blockquote><ul><li>目录扫描以及检测</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目录扫描检测主入口方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manageFiles</span><span class="params">()</span> <span class="keyword">throws</span> Exception, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">   <span class="comment">// 1. 通过getFiles方法获取到目录的所有Filter文件</span></span><br><span class="line">    List&lt;File&gt; aFiles = getFiles();</span><br><span class="line">    <span class="comment">//2. 通过processGroovyFiles方法处理所有Filter文件</span></span><br><span class="line">    processGroovyFiles(aFiles);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载所有动态Filter文件</span></span><br><span class="line"><span class="function">List&lt;File&gt; <span class="title">getFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;File&gt; list = <span class="keyword">new</span> ArrayList&lt;File&gt;();</span><br><span class="line">    <span class="comment">//遍历配置的动态Filter文件存放目录，加载目录文件</span></span><br><span class="line">    <span class="keyword">for</span> (String sDirectory : aDirectories) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sDirectory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            File directory = getDirectory(sDirectory);</span><br><span class="line">            File[] aFiles = directory.listFiles(FILENAME_FILTER);</span><br><span class="line">            <span class="keyword">if</span> (aFiles != <span class="keyword">null</span>) &#123;</span><br><span class="line">                list.addAll(Arrays.asList(aFiles));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理所有动态Filter文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processGroovyFiles</span><span class="params">(List&lt;File&gt; aFiles)</span> <span class="keyword">throws</span> Exception, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">    <span class="comment">//遍历动态Filter列表</span></span><br><span class="line">    <span class="keyword">for</span> (File file : aFiles) &#123;</span><br><span class="line">        <span class="comment">//通过FilterLoader类来加载处理Filter</span></span><br><span class="line">        FilterLoader.getInstance().putFilter(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>manageFiles方法完成两件事</p><ol><li>调用getFiles方法加载所有预制目录中的动态Filter文件</li><li>调用processGroovyFiles方法遍历filter列表通过FilterLoader类处理加载Filter</li></ol></blockquote><h4 id="Filter类文件动态编译"><a href="#Filter类文件动态编译" class="headerlink" title="Filter类文件动态编译"></a>Filter类文件动态编译</h4><blockquote><p>zuul 动态加载filter文件，并通过编译器将文件编译成class<br>目前zuul通过定义DynamicCodeCompiler接口以及Groovy编译的实现类GroovyCompiler来完成Groovy编写的filter的动态编译</p></blockquote><ul><li>DynamicCodeCompiler</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DynamicCodeCompiler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过源码字符串以及filter 名称编译class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Class <span class="title">compile</span><span class="params">(String sCode, String sName)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 通过源码文件编译class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Class <span class="title">compile</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DynamicCodeCompiler 动态代码编译器接口<br>定义两个方法根据不同的参数返回编译好的class</p></blockquote><ul><li>GroovyCompiler</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroovyCompiler</span> <span class="keyword">implements</span> <span class="title">DynamicCodeCompiler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(GroovyCompiler.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compiles Groovy code and returns the Class of the compiles code.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">compile</span><span class="params">(String sCode, String sName)</span> </span>&#123;</span><br><span class="line">        GroovyClassLoader loader = getGroovyClassLoader();</span><br><span class="line">        LOG.warn(<span class="string">"Compiling filter: "</span> + sName);</span><br><span class="line">        Class groovyClass = loader.parseClass(sCode, sName);</span><br><span class="line">        <span class="keyword">return</span> groovyClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取GroovyClassLoader</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a new GroovyClassLoader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">GroovyClassLoader <span class="title">getGroovyClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GroovyClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编译groovy class从文件中</span></span><br><span class="line"><span class="comment">     * Compiles groovy class from a file</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> java.io.IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">compile</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        GroovyClassLoader loader = getGroovyClassLoader();</span><br><span class="line">        Class groovyClass = loader.parseClass(file);</span><br><span class="line">        <span class="keyword">return</span> groovyClass;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GroovyCompiler 为groovy编写的Filter的动态编译实现类。</p></blockquote><hr><blockquote><p>zuul 默认支持groovy编写的Filter，这给在不停服的情况下动态变更业务规则提供了可靠的保障</p></blockquote>]]></content>
      
      
    </entry>
    
    <entry>
      <title>zuul之请求处理流程</title>
      <link href="/2018/11/23/zuul%E4%B9%8B%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/11/23/zuul%E4%B9%8B%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li><a href="https://guofazhan.github.io/2018/11/23/zuul%E4%B9%8B%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/">zuul之请求处理流程</a></li><li><a href="https://guofazhan.github.io/2018/11/23/zuul%E4%B9%8B%E5%8A%A8%E6%80%81%E8%BF%87%E6%BB%A4%E5%99%A8Filter%E7%B1%BB%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8A%A0%E8%BD%BD/">zuul之动态过滤器Filter类文件管理加载</a></li><li><a href="https://guofazhan.github.io/2018/11/23/zuul%E4%B9%8B%E8%BF%87%E6%BB%A4%E5%99%A8Filter%E7%AE%A1%E7%90%86/">zuul之过滤器Filter管理</a></li></ul><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><p>zuul 是netflix开源的一个API Gateway 服务器, 本质上是一个web servlet应用，下面通过源码分析zuul的请求处理流程<br><a id="more"></a></p></blockquote><h5 id="Zuul请求的生命周期"><a href="#Zuul请求的生命周期" class="headerlink" title="Zuul请求的生命周期"></a>Zuul请求的生命周期</h5><blockquote><p>如图，该图详细描述了各种类型的过滤器的执行顺序</p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/zuul.png?raw=true" alt="image"></p><blockquote><p>通过上图可以看到zuul通过拦截servlet应用http请求后进入zuul定义的过滤器链表进行处理路由；</p></blockquote><blockquote><p>一般我们开发web应用需要在请求进来前进行统一处理,通常有两种方式</p><ol><li>定义一个servlet Filter来在请求进来前拦截处理，例如会话校验，请求header校验等</li><li>定义一个统一servlet，所有请求进来都走此servlet，一般mvc框架通过此方式实现，例如springMvc的DispatcherServlet</li></ol></blockquote><blockquote><p>zuul也不例外，zuul分别实现了这两种拦截方式: ZuulServletFilter与ZuulServlet。</p></blockquote><h4 id="ZuulServletFilter"><a href="#ZuulServletFilter" class="headerlink" title="ZuulServletFilter"></a>ZuulServletFilter</h4><blockquote><p>所在包:com.netflix.zuul.filters</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulServletFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//zuul核心运行器</span></span><br><span class="line">    <span class="keyword">private</span> ZuulRunner zuulRunner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String bufferReqsStr = filterConfig.getInitParameter(<span class="string">"buffer-requests"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> bufferReqs = bufferReqsStr != <span class="keyword">null</span> &amp;&amp; bufferReqsStr.equals(<span class="string">"true"</span>) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建</span></span><br><span class="line">        zuulRunner = <span class="keyword">new</span> ZuulRunner(bufferReqs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//初始化当前请求zuul的上下问环境信息</span></span><br><span class="line">            init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);</span><br><span class="line">            <span class="comment">//执行前置过滤器列表</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                preRouting();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">                <span class="comment">//执行错误过滤器列表</span></span><br><span class="line">                <span class="comment">//执行后置路由过滤器列表</span></span><br><span class="line">                error(e);</span><br><span class="line">                postRouting();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//判断响应是否已经发送，发送完成时不需要执行下面路由列表流程</span></span><br><span class="line">            <span class="comment">// Only forward onto to the chain if a zuul response is not being sent</span></span><br><span class="line">            <span class="keyword">if</span> (!RequestContext.getCurrentContext().sendZuulResponse()) &#123;</span><br><span class="line">                filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//执行路由中过滤器列表</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                routing();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">                <span class="comment">//执行错误过滤器列表</span></span><br><span class="line">                <span class="comment">//执行后置路由过滤器列表</span></span><br><span class="line">                error(e);</span><br><span class="line">                postRouting();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行后置路由过滤器列表</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                postRouting();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">                <span class="comment">//执行错误过滤器列表</span></span><br><span class="line">                error(e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">//执行错误过滤器列表</span></span><br><span class="line">            error(<span class="keyword">new</span> ZuulException(e, <span class="number">500</span>, <span class="string">"UNCAUGHT_EXCEPTION_FROM_FILTER_"</span> + e.getClass().getName()));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            RequestContext.getCurrentContext().unset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postRouting</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        <span class="comment">//zuul核心运行器执行后置过滤器列表</span></span><br><span class="line">        zuulRunner.postRoute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">routing</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        zuulRunner.route();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preRouting</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        zuulRunner.preRoute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(HttpServletRequest servletRequest, HttpServletResponse servletResponse)</span> </span>&#123;</span><br><span class="line">        zuulRunner.init(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(ZuulException e)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//设置异常的上下文环境中</span></span><br><span class="line">        RequestContext.getCurrentContext().setThrowable(e);</span><br><span class="line">        zuulRunner.error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ZuulServlet"><a href="#ZuulServlet" class="headerlink" title="ZuulServlet"></a>ZuulServlet</h4><blockquote><p>所在包：com.netflix.zuul.http</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3374242278843351500L</span>;</span><br><span class="line">    <span class="keyword">private</span> ZuulRunner zuulRunner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(config);</span><br><span class="line"></span><br><span class="line">        String bufferReqsStr = config.getInitParameter(<span class="string">"buffer-requests"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> bufferReqs = bufferReqsStr != <span class="keyword">null</span> &amp;&amp; bufferReqsStr.equals(<span class="string">"true"</span>) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        zuulRunner = <span class="keyword">new</span> ZuulRunner(bufferReqs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Marks this request as having passed through the "Zuul engine", as opposed to servlets</span></span><br><span class="line">            <span class="comment">// explicitly bound in web.xml, for which requests will not have the same data attached</span></span><br><span class="line">            RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">            context.setZuulEngineRan();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                preRoute();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">                error(e);</span><br><span class="line">                postRoute();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                route();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">                error(e);</span><br><span class="line">                postRoute();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                postRoute();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">                error(e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            error(<span class="keyword">new</span> ZuulException(e, <span class="number">500</span>, <span class="string">"UNHANDLED_EXCEPTION_"</span> + e.getClass().getName()));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            RequestContext.getCurrentContext().unset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * executes "post" ZuulFilters</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ZuulException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postRoute</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        zuulRunner.postRoute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * executes "route" filters</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ZuulException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">route</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        zuulRunner.route();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * executes "pre" filters</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ZuulException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preRoute</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        zuulRunner.preRoute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initializes request</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletResponse</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(HttpServletRequest servletRequest, HttpServletResponse servletResponse)</span> </span>&#123;</span><br><span class="line">        zuulRunner.init(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sets error context info and executes "error" filters</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(ZuulException e)</span> </span>&#123;</span><br><span class="line">        RequestContext.getCurrentContext().setThrowable(e);</span><br><span class="line">        zuulRunner.error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ZuulServlet与ZuulServletFilter完成了相同的功能</p><ol><li>初始化时创建ZuulRunner</li><li>请求进入调用ZuulRunner.init初始化当前请求的上下文环境</li><li>按规则执行zuul的过滤器列表:</li></ol><ul><li>正常情况 :preRoute()-&gt;route()-&gt;postRoute()</li><li>preRoute异常：preRoute()-&gt;error()-&gt;postRoute()</li><li>route异常：route()-&gt;error()-&gt;postRoute()</li><li>postRoute异常：postRoute()-&gt;error()</li></ul></blockquote><h4 id="ZuulRunner"><a href="#ZuulRunner" class="headerlink" title="ZuulRunner"></a>ZuulRunner</h4><blockquote><p>ZuulRunner将servlet请求和响应初始化到请求上下文中，并封装过滤器处理器调用preRoute()、Router（）、postRoute（）和Error（）方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> bufferRequests;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &lt;code&gt;ZuulRunner&lt;/code&gt; instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZuulRunner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bufferRequests = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bufferRequests - whether to wrap the ServletRequest in HttpServletRequestWrapper and buffer the body.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZuulRunner</span><span class="params">(<span class="keyword">boolean</span> bufferRequests)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bufferRequests = bufferRequests;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sets HttpServlet request and HttpResponse</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletResponse</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(HttpServletRequest servletRequest, HttpServletResponse servletResponse)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        <span class="keyword">if</span> (bufferRequests) &#123;</span><br><span class="line">            ctx.setRequest(<span class="keyword">new</span> HttpServletRequestWrapper(servletRequest));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.setRequest(servletRequest);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx.setResponse(<span class="keyword">new</span> HttpServletResponseWrapper(servletResponse));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * executes "post" filterType  ZuulFilters</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ZuulException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postRoute</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        FilterProcessor.getInstance().postRoute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * executes "route" filterType  ZuulFilters</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ZuulException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">route</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        FilterProcessor.getInstance().route();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * executes "pre" filterType  ZuulFilters</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ZuulException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRoute</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        FilterProcessor.getInstance().preRoute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * executes "error" filterType  ZuulFilters</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterProcessor.getInstance().error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ZuulRunner 是提供给请求的核心处理类，主要完成下面事件</p><ol><li>初始化request，response到上下问环境</li><li>将 FilterProcessor的过滤器调用暴露出去</li></ol></blockquote><h4 id="FilterProcessor"><a href="#FilterProcessor" class="headerlink" title="FilterProcessor"></a>FilterProcessor</h4><blockquote><p>FilterProcessor是执行过滤器的核心类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> FilterProcessor INSTANCE = <span class="keyword">new</span> FilterProcessor();</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(FilterProcessor.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FilterUsageNotifier usageNotifier;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FilterProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        usageNotifier = <span class="keyword">new</span> BasicFilterUsageNotifier();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the singleton FilterProcessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FilterProcessor <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sets a singleton processor in case of a need to override default behavior</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> processor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setProcessor</span><span class="params">(FilterProcessor processor)</span> </span>&#123;</span><br><span class="line">        INSTANCE = processor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Override the default filter usage notification impl.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> notifier</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFilterUsageNotifier</span><span class="params">(FilterUsageNotifier notifier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.usageNotifier = notifier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按顺序执行类型为post的过滤器列表（后置过滤器）</span></span><br><span class="line"><span class="comment">     * runs "post" filters which are called after "route" filters. ZuulExceptions from ZuulFilters are thrown.</span></span><br><span class="line"><span class="comment">     * Any other Throwables are caught and a ZuulException is thrown out with a 500 status code</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ZuulException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postRoute</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runFilters(<span class="string">"post"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZuulException(e, <span class="number">500</span>, <span class="string">"UNCAUGHT_EXCEPTION_IN_POST_FILTER_"</span> + e.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按顺序执行类型为error的过滤器列表（错误过滤器）</span></span><br><span class="line"><span class="comment">     * runs all "error" filters. These are called only if an exception occurs. Exceptions from this are swallowed and logged so as not to bubble up.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runFilters(<span class="string">"error"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按顺序执行类型为route的过滤器列表（路由过滤器）</span></span><br><span class="line"><span class="comment">     * Runs all "route" filters. These filters route calls to an origin.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ZuulException if an exception occurs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">route</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runFilters(<span class="string">"route"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZuulException(e, <span class="number">500</span>, <span class="string">"UNCAUGHT_EXCEPTION_IN_ROUTE_FILTER_"</span> + e.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按顺序执行类型为pre的过滤器列表（前置过滤器）</span></span><br><span class="line"><span class="comment">     * runs all "pre" filters. These filters are run before routing to the orgin.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ZuulException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRoute</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runFilters(<span class="string">"pre"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZuulException(e, <span class="number">500</span>, <span class="string">"UNCAUGHT_EXCEPTION_IN_PRE_FILTER_"</span> + e.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按顺序执行给定类型的过滤器列表</span></span><br><span class="line"><span class="comment">     * 通过FilterLoader加载所有给定类型type的过滤器</span></span><br><span class="line"><span class="comment">     * 循环遍历过滤器列表依次执行</span></span><br><span class="line"><span class="comment">     * runs all filters of the filterType sType/ Use this method within filters to run custom filters by type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sType the filterType.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable throws up an arbitrary exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">runFilters</span><span class="params">(String sType)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (RequestContext.getCurrentContext().debugRouting()) &#123;</span><br><span class="line">            Debug.addRoutingDebug(<span class="string">"Invoking &#123;"</span> + sType + <span class="string">"&#125; type filters"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> bResult = <span class="keyword">false</span>;</span><br><span class="line">        List&lt;ZuulFilter&gt; list = FilterLoader.getInstance().getFiltersByType(sType);</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                ZuulFilter zuulFilter = list.get(i);</span><br><span class="line">                Object result = processZuulFilter(zuulFilter);</span><br><span class="line">                <span class="keyword">if</span> (result != <span class="keyword">null</span> &amp;&amp; result <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">                    bResult |= ((Boolean) result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Processes an individual ZuulFilter. This method adds Debug information. Any uncaught Thowables are caught by this method and converted to a ZuulException with a 500 status code.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the return value for that filter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ZuulException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">processZuulFilter</span><span class="params">(ZuulFilter filter)</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line"></span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        <span class="keyword">boolean</span> bDebug = ctx.debugRouting();</span><br><span class="line">        <span class="keyword">final</span> String metricPrefix = <span class="string">"zuul.filter-"</span>;</span><br><span class="line">        <span class="keyword">long</span> execTime = <span class="number">0</span>;</span><br><span class="line">        String filterName = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> ltime = System.currentTimeMillis();</span><br><span class="line">            filterName = filter.getClass().getSimpleName();</span><br><span class="line">            </span><br><span class="line">            RequestContext copy = <span class="keyword">null</span>;</span><br><span class="line">            Object o = <span class="keyword">null</span>;</span><br><span class="line">            Throwable t = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bDebug) &#123;</span><br><span class="line">                Debug.addRoutingDebug(<span class="string">"Filter "</span> + filter.filterType() + <span class="string">" "</span> + filter.filterOrder() + <span class="string">" "</span> + filterName);</span><br><span class="line">                copy = ctx.copy();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ZuulFilterResult result = filter.runFilter();</span><br><span class="line">            ExecutionStatus s = result.getStatus();</span><br><span class="line">            execTime = System.currentTimeMillis() - ltime;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">                <span class="keyword">case</span> FAILED:</span><br><span class="line">                    t = result.getException();</span><br><span class="line">                    ctx.addFilterExecutionSummary(filterName, ExecutionStatus.FAILED.name(), execTime);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> SUCCESS:</span><br><span class="line">                    o = result.getResult();</span><br><span class="line">                    ctx.addFilterExecutionSummary(filterName, ExecutionStatus.SUCCESS.name(), execTime);</span><br><span class="line">                    <span class="keyword">if</span> (bDebug) &#123;</span><br><span class="line">                        Debug.addRoutingDebug(<span class="string">"Filter &#123;"</span> + filterName + <span class="string">" TYPE:"</span> + filter.filterType() + <span class="string">" ORDER:"</span> + filter.filterOrder() + <span class="string">"&#125; Execution time = "</span> + execTime + <span class="string">"ms"</span>);</span><br><span class="line">                        Debug.compareContextState(filterName, copy);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="keyword">throw</span> t;</span><br><span class="line"></span><br><span class="line">            usageNotifier.notify(filter, s);</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bDebug) &#123;</span><br><span class="line">                Debug.addRoutingDebug(<span class="string">"Running Filter failed "</span> + filterName + <span class="string">" type:"</span> + filter.filterType() + <span class="string">" order:"</span> + filter.filterOrder() + <span class="string">" "</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            usageNotifier.notify(filter, ExecutionStatus.FAILED);</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ZuulException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (ZuulException) e;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ZuulException ex = <span class="keyword">new</span> ZuulException(e, <span class="string">"Filter threw Exception"</span>, <span class="number">500</span>, filter.filterType() + <span class="string">":"</span> + filterName);</span><br><span class="line">                ctx.addFilterExecutionSummary(filterName, ExecutionStatus.FAILED.name(), execTime);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Publishes a counter metric for each filter on each use.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicFilterUsageNotifier</span> <span class="keyword">implements</span> <span class="title">FilterUsageNotifier</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String METRIC_PREFIX = <span class="string">"zuul.filter-"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(ZuulFilter filter, ExecutionStatus status)</span> </span>&#123;</span><br><span class="line">            DynamicCounter.increment(METRIC_PREFIX + filter.getClass().getSimpleName(), <span class="string">"status"</span>, status.name(), <span class="string">"filtertype"</span>, filter.filterType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>FilterProcessor 通过FilterLoader加载给定类型的过滤器列表，然后按顺序依次执行过滤器，根据过滤器的类型包含如下方法：</p><ul><li>preRoute：按顺序执行类型为pre的过滤器列表（前置过滤器）</li><li>route:按顺序执行类型为route的过滤器列表（路由过滤器）</li><li>postRoute:按顺序执行类型为post的过滤器列表（后置过滤器）</li><li>error:按顺序执行类型为error的过滤器列表（错误过滤器）</li></ul></blockquote><blockquote><p>到此，zuul拦截servlet应用http请求后通过过滤器列表进行处理路由的整个流程以及代码都查看完毕，对后期我们根据业务改造还是自定义过滤器有很大的指导意义。</p></blockquote><hr><p><strong>备注</strong> 过滤器分类：</p><blockquote><ul><li>pre：前置过滤器</li><li>route：路由过滤器</li><li>post：后置过滤器</li><li>error：错误过滤器</li></ul></blockquote>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Hystrix之信号量隔离熔断</title>
      <link href="/2018/09/11/Hystrix%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9A%94%E7%A6%BB%E7%86%94%E6%96%AD/"/>
      <url>/2018/09/11/Hystrix%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9A%94%E7%A6%BB%E7%86%94%E6%96%AD/</url>
      <content type="html"><![CDATA[<blockquote><p>Hystrix 是spring cloud默认集成的熔断组件，用于保护系统的流量过载。Hystrix支持两种方式的隔离熔断操作。线程池、信号量；下面主要通过源码学习Hystrix是怎么实现信号量的熔断隔离。<br><a id="more"></a></p></blockquote><h5 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h5><p>Hystrix 信号量模型以及实现主要在com.netflix.hystrix.AbstractCommand以及其内部类中，下面看下Semaphore的模型接口以及实现</p><ul><li>TryableSemaphore</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 信号量接口</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">/* package */</span><span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">TryableSemaphore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 获取信号量，当获取到时返回true，否则返回false</span></span><br><span class="line"><span class="comment">        * Use like this:</span></span><br><span class="line"><span class="comment">        * &lt;p&gt;</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">        * if (s.tryAcquire()) &#123;</span></span><br><span class="line"><span class="comment">        * try &#123;</span></span><br><span class="line"><span class="comment">        * // do work that is protected by 's'</span></span><br><span class="line"><span class="comment">        * &#125; finally &#123;</span></span><br><span class="line"><span class="comment">        * s.release();</span></span><br><span class="line"><span class="comment">        * &#125;</span></span><br><span class="line"><span class="comment">        * &#125;</span></span><br><span class="line"><span class="comment">        * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 当tryAcquire获取到信号量时，使用完成后调用此方法释放信号量，使信号量计数器复原</span></span><br><span class="line"><span class="comment">        * ONLY call release if tryAcquire returned true.</span></span><br><span class="line"><span class="comment">        * &lt;p&gt;</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">        * if (s.tryAcquire()) &#123;</span></span><br><span class="line"><span class="comment">        * try &#123;</span></span><br><span class="line"><span class="comment">        * // do work that is protected by 's'</span></span><br><span class="line"><span class="comment">        * &#125; finally &#123;</span></span><br><span class="line"><span class="comment">        * s.release();</span></span><br><span class="line"><span class="comment">        * &#125;</span></span><br><span class="line"><span class="comment">        * &#125;</span></span><br><span class="line"><span class="comment">        * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 获取当前信号的计数器的大小</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getNumberOfPermitsUsed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>TryableSemaphore接口提供信号量的获取以及释放操作。</p><ul><li>tryAcquire: 获取信号量，获取到时返回true，获取失败返回false</li><li>release ：tryAcquire返回true时，通过此方法释放持有的信号量，复原信号量计数器</li><li>getNumberOfPermitsUsed:获取已使用的信号量数</li></ul></blockquote><ul><li>TryableSemaphoreNoOp</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空操作信号量实现，此类调用tryAcquire永远返回true，始终可以获取信号量，不做最大信号量限制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* package */</span><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TryableSemaphoreNoOp</span> <span class="keyword">implements</span> <span class="title">TryableSemaphore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TryableSemaphore DEFAULT = <span class="keyword">new</span> TryableSemaphoreNoOp();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberOfPermitsUsed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>TryableSemaphoreNoOp类为不限制信号量的实现，当hystrix.command.default.execution.isolation.strategy!=SEMAPHORE是默认使用TryableSemaphoreNoOp标识，任何时候都可以通过信号量的检测。</p></blockquote><ul><li>TryableSemaphoreActual</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  信号量，仅支持tryAcquire，无阻塞功能，信号量大小可动态配置</span></span><br><span class="line"><span class="comment">   * Semaphore that only supports tryAcquire and never blocks and that supports a dynamic permit count.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * Using AtomicInteger increment/decrement instead of java.util.concurrent.Semaphore since we don't need blocking and need a custom implementation to get the dynamic permit count and since</span></span><br><span class="line"><span class="comment">   * AtomicInteger achieves the same behavior and performance without the more complex implementation of the actual Semaphore class using AbstractQueueSynchronizer.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">/* package */</span><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TryableSemaphoreActual</span> <span class="keyword">implements</span> <span class="title">TryableSemaphore</span> </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 许可通过的最大信号量数值，可在配置中配置</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">final</span> HystrixProperty&lt;Integer&gt; numberOfPermits;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 信号量计数器，线程安全</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">TryableSemaphoreActual</span><span class="params">(HystrixProperty&lt;Integer&gt; numberOfPermits)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.numberOfPermits = numberOfPermits;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">//信号量加一并返回新的总数</span></span><br><span class="line">          <span class="keyword">int</span> currentCount = count.incrementAndGet();</span><br><span class="line">          <span class="comment">//对比计数总数与最大许可的数值</span></span><br><span class="line">          <span class="keyword">if</span> (currentCount &gt; numberOfPermits.get()) &#123;</span><br><span class="line">              <span class="comment">//计数总数大于最大许可，返回false，标识无信号量可用</span></span><br><span class="line">              <span class="comment">//信号量减一，复原计数器</span></span><br><span class="line">              count.decrementAndGet();</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 释放持有的信号量</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">//信号量减一</span></span><br><span class="line">          count.decrementAndGet();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 获取信号量已使用的值</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberOfPermitsUsed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> count.get();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>TryableSemaphoreActual类最大信号量可配置，通过hystrix.command.default.fallback.isolation.semaphore.maxConcurrentRequests配置。</p><ul><li>tryAcquire： 对已使用的信号量+1；比较计数器与最大许可，判断是否有可用的信号量，有返回true，无返回false；</li></ul></blockquote><h5 id="Semaphore实例创建"><a href="#Semaphore实例创建" class="headerlink" title="Semaphore实例创建"></a>Semaphore实例创建</h5><ul><li>AbstractCommand 方法中缓存有信号量map如下:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* each circuit has a semaphore to restrict concurrent fallback execution */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, TryableSemaphore&gt; fallbackSemaphorePerCircuit = <span class="keyword">new</span> ConcurrentHashMap&lt;String, TryableSemaphore&gt;();</span><br><span class="line">    <span class="comment">/* END FALLBACK Semaphore */</span></span><br></pre></td></tr></table></figure><ul><li>查询command命令的Semaphore实例根据commandkey</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TryableSemaphore <span class="title">getExecutionSemaphore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//校验是否配置以信号量隔离</span></span><br><span class="line">    <span class="keyword">if</span> (properties.executionIsolationStrategy().get() == ExecutionIsolationStrategy.SEMAPHORE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executionSemaphoreOverride == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//缓存中获取当前命令的信号量信息</span></span><br><span class="line">            TryableSemaphore _s = executionSemaphorePerCircuit.get(commandKey.name());</span><br><span class="line">            <span class="keyword">if</span> (_s == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建当前命令的信号量实例，并保存在缓存中</span></span><br><span class="line">                <span class="comment">// we didn't find one cache so setup</span></span><br><span class="line">                 executionSemaphorePerCircuit.putIfAbsent(commandKey.name(), <span class="keyword">new</span> TryableSemaphoreActual(properties.executionIsolationSemaphoreMaxConcurrentRequests()));</span><br><span class="line">                <span class="comment">// assign whatever got set (this or another thread)</span></span><br><span class="line">                <span class="keyword">return</span> executionSemaphorePerCircuit.get(commandKey.name());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> _s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> executionSemaphoreOverride;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//返回空实现</span></span><br><span class="line">        <span class="comment">// return NoOp implementation since we're not using SEMAPHORE isolation</span></span><br><span class="line">        <span class="keyword">return</span> TryableSemaphoreNoOp.DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Semaphore在command中使用"><a href="#Semaphore在command中使用" class="headerlink" title="Semaphore在command中使用"></a>Semaphore在command中使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">applyHystrixSemantics</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// mark that we're starting execution on the ExecutionHook</span></span><br><span class="line">       <span class="comment">// if this hook throws an exception, then a fast-fail occurs with no fallback.  No state is left inconsistent</span></span><br><span class="line">       executionHook.onStart(_cmd);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* determine if we're allowed to execute */</span></span><br><span class="line">       <span class="keyword">if</span> (circuitBreaker.attemptExecution()) &#123;</span><br><span class="line">           <span class="comment">//获取当前命令的信号量信息</span></span><br><span class="line">           <span class="keyword">final</span> TryableSemaphore executionSemaphore = getExecutionSemaphore();</span><br><span class="line">           <span class="comment">//信号量是否需要释放标识</span></span><br><span class="line">           <span class="keyword">final</span> AtomicBoolean semaphoreHasBeenReleased = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">           <span class="comment">//信号量释放action</span></span><br><span class="line">           <span class="keyword">final</span> Action0 singleSemaphoreRelease = <span class="keyword">new</span> Action0() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">if</span> (semaphoreHasBeenReleased.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                       executionSemaphore.release();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">final</span> Action1&lt;Throwable&gt; markExceptionThrown = <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                   eventNotifier.markEvent(HystrixEventType.EXCEPTION_THROWN, commandKey);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//信号量获取</span></span><br><span class="line">           <span class="keyword">if</span> (executionSemaphore.tryAcquire()) &#123;</span><br><span class="line">               <span class="comment">//获取成功，执行命令具体操作，并将信号量释放action添加到流式操作中</span></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">/* used to track userThreadExecutionTime */</span></span><br><span class="line">                   executionResult = executionResult.setInvocationStartTime(System.currentTimeMillis());</span><br><span class="line">                   <span class="keyword">return</span> executeCommandAndObserve(_cmd)</span><br><span class="line">                           .doOnError(markExceptionThrown)</span><br><span class="line">                           .doOnTerminate(singleSemaphoreRelease)</span><br><span class="line">                           .doOnUnsubscribe(singleSemaphoreRelease);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                   <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//获取失败熔断进入Fallback</span></span><br><span class="line">               <span class="keyword">return</span> handleSemaphoreRejectionViaFallback();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> handleShortCircuitViaFallback();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>applyHystrixSemantics 核心流程：</p><ol><li>获取TryableSemaphore</li><li>调用TryableSemaphore.tryAcquire()</li><li>调用TryableSemaphore.release()</li></ol></blockquote><blockquote><p>Hystrix使用了rxJava响应式编码，所以这里的代码组织结构有点难以理解，弄懂rxJava的原理，其实也是很好看懂的。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Hystrix </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring-Cloud-Gateway之配置路由过滤器</title>
      <link href="/2018/09/04/Spring-Cloud-Gateway%E4%B9%8B%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2018/09/04/Spring-Cloud-Gateway%E4%B9%8B%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>上篇我们阅读了过滤器整个结构以及加载使用流程，接下来我们阅读下Spring-Cloud-Gateway对配置中的过滤器创建流程。</p><hr><ol><li>加载GatewayFilter</li></ol><p>在路由定位器中以及看到了通过路由定义转换路由方法，其中包含了通过过滤器定义(FilterDefinition)转换过滤器(GatewayFilter)的部分,在RouteDefinitionRouteLocator类中源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 加载过滤器，根据过滤器的定义加载</span><br><span class="line"> * @param id</span><br><span class="line"> * @param filterDefinitions</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">private List&lt;GatewayFilter&gt; loadGatewayFilters(String id, List&lt;FilterDefinition&gt; filterDefinitions) &#123;</span><br><span class="line">//遍历过滤器定义，将过滤器定义转换成对应的过滤器</span><br><span class="line">List&lt;GatewayFilter&gt; filters = filterDefinitions.stream()</span><br><span class="line">.map(definition -&gt; &#123;</span><br><span class="line">//通过过滤器定义名称获取过滤器创建工厂</span><br><span class="line">GatewayFilterFactory factory = this.gatewayFilterFactories.get(definition.getName());</span><br><span class="line">if (factory == null) &#123;</span><br><span class="line">                       throw new IllegalArgumentException(&quot;Unable to find GatewayFilterFactory with name &quot; + definition.getName());</span><br><span class="line">&#125;</span><br><span class="line">//获取参数</span><br><span class="line">Map&lt;String, String&gt; args = definition.getArgs();</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;RouteDefinition &quot; + id + &quot; applying filter &quot; + args + &quot; to &quot; + definition.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//根据args组装配置信息</span><br><span class="line">                   Map&lt;String, Object&gt; properties = factory.shortcutType().normalize(args, factory, this.parser, this.beanFactory);</span><br><span class="line">//构建过滤器创建配置信息</span><br><span class="line">                   Object configuration = factory.newConfig();</span><br><span class="line">                   ConfigurationUtils.bind(configuration, properties,</span><br><span class="line">                           factory.shortcutFieldPrefix(), definition.getName(), validator);</span><br><span class="line"></span><br><span class="line">                   //通过过滤器工厂创建GatewayFilter</span><br><span class="line">                   GatewayFilter gatewayFilter = factory.apply(configuration);</span><br><span class="line">                   if (this.publisher != null) &#123;</span><br><span class="line">                   //发布事件</span><br><span class="line">                       this.publisher.publishEvent(new FilterArgsEvent(this, id, properties));</span><br><span class="line">                   &#125;</span><br><span class="line">                   return gatewayFilter;</span><br><span class="line">&#125;)</span><br><span class="line">.collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">ArrayList&lt;GatewayFilter&gt; ordered = new ArrayList&lt;&gt;(filters.size());</span><br><span class="line">//包装过滤器使其所有过滤器继承Ordered属性，可进行排序</span><br><span class="line">for (int i = 0; i &lt; filters.size(); i++) &#123;</span><br><span class="line">GatewayFilter gatewayFilter = filters.get(i);</span><br><span class="line">if (gatewayFilter instanceof Ordered) &#123;</span><br><span class="line">ordered.add(gatewayFilter);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">ordered.add(new OrderedGatewayFilter(gatewayFilter, i + 1));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return ordered;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取RouteDefinition中的过滤器集合</span><br><span class="line"> * @param routeDefinition</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private List&lt;GatewayFilter&gt; getFilters(RouteDefinition routeDefinition) &#123;</span><br><span class="line">List&lt;GatewayFilter&gt; filters = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">//校验gatewayProperties是否含义默认的过滤器集合</span><br><span class="line">//TODO: support option to apply defaults after route specific filters?</span><br><span class="line">if (!this.gatewayProperties.getDefaultFilters().isEmpty()) &#123;</span><br><span class="line">//加载全局配置的默认过滤器集合</span><br><span class="line">filters.addAll(loadGatewayFilters(&quot;defaultFilters&quot;,</span><br><span class="line">this.gatewayProperties.getDefaultFilters()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!routeDefinition.getFilters().isEmpty()) &#123;</span><br><span class="line">//加载路由定义中的过滤器集合</span><br><span class="line">filters.addAll(loadGatewayFilters(routeDefinition.getId(), routeDefinition.getFilters()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//排序</span><br><span class="line">AnnotationAwareOrderComparator.sort(filters);</span><br><span class="line">return filters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>getFilters方法 合并配置中的全局过滤器与路由自身配置的过滤器，并对其排序（全局配置过滤器信息通过gatewayProperties.getDefaultFilters()获取）</li></ul></blockquote><blockquote><ul><li>loadGatewayFilters 依次遍历路由定义下的FilterDefinition并将其通过对应的GatewayFilterFactory转换为GatewayFilter对象。</li></ul></blockquote><ol start="2"><li>GatewayFilterFactory配置过滤器创建工厂创建GatewayFilter对象<blockquote><p>Spring-Cloud-Gateway默认内置很多GatewayFilterFactory实现类，用于创建作用不同的网关过滤器，下面通过图展示各个工厂类创建的过滤器的作用。</p></blockquote></li></ol><p><img src="https://raw.githubusercontent.com/guofazhan/image/master/GatewayFilterFactory.png" alt="image"></p><ul><li>AddResponseHeaderGatewayFilterFactory 创建解析</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * 响应header添加数据过滤器</span><br><span class="line"> * 用户在response header中添加配置数据</span><br><span class="line"> * @author Spencer Gibb</span><br><span class="line"> */</span><br><span class="line">public class AddResponseHeaderGatewayFilterFactory extends AbstractNameValueGatewayFilterFactory &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public GatewayFilter apply(NameValueConfig config) &#123;</span><br><span class="line">return (exchange, chain) -&gt; &#123;</span><br><span class="line">//获取Response并将配置的数据添加到header中</span><br><span class="line">exchange.getResponse().getHeaders().add(config.getName(), config.getValue());</span><br><span class="line"></span><br><span class="line">return chain.filter(exchange);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      default-filters:</span><br><span class="line">      - AddResponseHeader=X-Response-Default-Foo, Default-Bar</span><br></pre></td></tr></table></figure><blockquote><ol><li>AddResponseHeader=X-Response-Default-Foo, Default-Bar 会被解析成FilterDefinition对象 （name =AddResponseHeader ，args= [X-Response-Default-Foo,Default-Bar]）</li><li>通FilterDefinition的Name找到AddResponseHeaderGatewayFilterFactory工厂</li><li>通过FilterDefinition 的args 创建Config对象（name=X-Response-Default-Foo,value=Default-Bar）</li><li>通过 AddResponseHeaderGatewayFilterFactory工厂的apply方法传入config创建GatewayFilter对象。</li></ol></blockquote>]]></content>
      
      <categories>
          
          <category> Spring-Cloud-Gateway </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 网关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring-Cloud-Gateway之RoutePredicate</title>
      <link href="/2018/09/04/Spring-Cloud-Gateway%E4%B9%8BRoutePredicate/"/>
      <url>/2018/09/04/Spring-Cloud-Gateway%E4%B9%8BRoutePredicate/</url>
      <content type="html"><![CDATA[<p>Spring-Cloud-Gateway路由选择是通过Predicate函数式接口进行判断当前路由是否满足给定条件。下来阅读Spring-Cloud-Gateway路由的Predicate构建流程以及选择路由的源码</p><hr><a id="more"></a><p>首先看下JDK8中Predicate接口定义</p><blockquote><p>Predicate<t> 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。可以用于接口请求参数校验、判断新老数据是否有变化需要进行更新操作。add–与、or–或、negate–非</t></p><ul><li>boolean test(T t); 判断</li><li>Predicate<t> and(Predicate&lt;? super T&gt; other) 接收一个Predicate类型，也就是将传入的条件和当前条件以并且(AND)的关系组合</t></li><li>Predicate<t> or(Predicate&lt;? super T&gt; other)接收一个Predicate类型，也就是将传入的条件和当前条件以或(OR)的关系组合 </t></li></ul></blockquote><hr><ol><li>加载路由中的Predicate<blockquote><p>在路由定位器中以及看到了通过路由定义转换路由方法，其中包含了通过谓语定义(PredicateDefinition)转换谓语(Predicate)的部分,在RouteDefinitionRouteLocator类中源码如下：</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回组合的谓词</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> routeDefinition</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Predicate&lt;ServerWebExchange&gt; <span class="title">combinePredicates</span><span class="params">(RouteDefinition routeDefinition)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取RouteDefinition中的PredicateDefinition集合</span></span><br><span class="line">List&lt;PredicateDefinition&gt; predicates = routeDefinition.getPredicates();</span><br><span class="line"></span><br><span class="line">Predicate&lt;ServerWebExchange&gt; predicate = lookup(routeDefinition, predicates.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (PredicateDefinition andPredicate : predicates.subList(<span class="number">1</span>, predicates.size())) &#123;</span><br><span class="line">Predicate&lt;ServerWebExchange&gt; found = lookup(routeDefinition, andPredicate);</span><br><span class="line"><span class="comment">//返回一个组合的谓词，表示该谓词与另一个谓词的短路逻辑AND</span></span><br><span class="line">predicate = predicate.and(found);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> predicate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个谓语定义（PredicateDefinition）转换的谓语</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> route</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> Predicate&lt;ServerWebExchange&gt; <span class="title">lookup</span><span class="params">(RouteDefinition route, PredicateDefinition predicate)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取谓语创建工厂</span></span><br><span class="line">RoutePredicateFactory&lt;Object&gt; factory = <span class="keyword">this</span>.predicates.get(predicate.getName());</span><br><span class="line"><span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to find RoutePredicateFactory with name "</span> + predicate.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取参数</span></span><br><span class="line">Map&lt;String, String&gt; args = predicate.getArgs();</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"RouteDefinition "</span> + route.getId() + <span class="string">" applying "</span></span><br><span class="line">+ args + <span class="string">" to "</span> + predicate.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组装参数</span></span><br><span class="line">       Map&lt;String, Object&gt; properties = factory.shortcutType().normalize(args, factory, <span class="keyword">this</span>.parser, <span class="keyword">this</span>.beanFactory);</span><br><span class="line">       <span class="comment">//构建创建谓语的配置信息</span></span><br><span class="line">Object config = factory.newConfig();</span><br><span class="line">       ConfigurationUtils.bind(config, properties,</span><br><span class="line">               factory.shortcutFieldPrefix(), predicate.getName(), validator);</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.publisher != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.publisher.publishEvent(<span class="keyword">new</span> PredicateArgsEvent(<span class="keyword">this</span>, route.getId(), properties));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//通过谓语工厂构建谓语</span></span><br><span class="line">       <span class="keyword">return</span> factory.apply(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>获取路由定义（routeDefinition）所有的谓语定位（PredicateDefinition）</li><li>以此根据谓语定义（PredicateDefinition）查找谓语对于的创建工厂（RoutePredicateFactory） 创建谓语</li><li>通过 Predicate<t>接口 and方法合并谓语集合返回一个新的复合谓语</t></li></ol></blockquote><ol start="2"><li>使用路由Predicate判断路由是否可用<blockquote><p>在Spring-Cloud-Gateway之请求处理流程里我们已经了解在handlerMapping中通过路由定位器获取所有路由，并过滤掉谓语判断失败的路由，最终获取满足条件的路由，下面再看下过滤的具体逻辑。</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Mono&lt;Route&gt; <span class="title">lookupRoute</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line"><span class="comment">//通过路由定位器获取路由信息</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.routeLocator.getRoutes()</span><br><span class="line">.filter(route -&gt; &#123;</span><br><span class="line">exchange.getAttributes().put(GATEWAY_PREDICATE_ROUTE_ATTR, route.getId());</span><br><span class="line"><span class="comment">//返回通过谓语过滤的路由信息</span></span><br><span class="line"><span class="keyword">return</span> route.getPredicate().test(exchange);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>通过routeLocator的getRoutes方法获取所有路由</li><li>在所有路由中通过filter方法匹配Predicate.test匹配的路由信息</li></ol></blockquote><hr><p>通过上面1，2两步我们看到了整个路由的条件创建以及使用的地方以及流程，Spring-Cloud-Gateway通过Predicate接口完成简单条件组合以及判断。</p><blockquote><p>接下来看通过RoutePredicateFactory创建PredicateSpring-Cloud-Gateway预制了很多RoutePredicateFactory使其可以通过简单的配置就可以创建出理想的Predicate</p></blockquote><p>RoutePredicateFactory类图如下：<br><img src="https://raw.githubusercontent.com/guofazhan/image/master/RoutePredicateFactoryUML.png" alt="image"><br>RoutePredicateFactory子类功能分类图：<br><img src="https://raw.githubusercontent.com/guofazhan/image/master/PredicateFactory.png" alt="image"></p><hr><ul><li>MethodRoutePredicateFactory</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求方式（GET,POST,DEL,PUT）校验匹配创建工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spencer Gibb</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodRoutePredicateFactory</span> <span class="keyword">extends</span> <span class="title">AbstractRoutePredicateFactory</span>&lt;<span class="title">MethodRoutePredicateFactory</span>.<span class="title">Config</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String METHOD_KEY = <span class="string">"method"</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Predicate&lt;ServerWebExchange&gt; <span class="title">apply</span><span class="params">(Config config)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> exchange -&gt; &#123;</span><br><span class="line"><span class="comment">//获取当前请求的HttpMethod</span></span><br><span class="line">HttpMethod requestMethod = exchange.getRequest().getMethod();</span><br><span class="line"><span class="comment">//校验请求HttpMethod与配置是否一致</span></span><br><span class="line"><span class="keyword">return</span> requestMethod == config.getMethod();</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * http 请求Method</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> HttpMethod method;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpMethod <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> method;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethod</span><span class="params">(HttpMethod method)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.method = method;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 配置列子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      # =====================================</span><br><span class="line">      - id: method_route</span><br><span class="line">        uri: http:<span class="comment">//example.org</span></span><br><span class="line">        predicates:</span><br><span class="line">        - Method=GET</span><br></pre></td></tr></table></figure><blockquote><ol><li>Method=GET 会被解析成PredicateDefinition对象 （name =Method ，args= GET）</li><li>通过PredicateDefinition的Name找到MethodRoutePredicateFactory工厂</li><li>通过 PredicateDefinition 的args 创建Config对象（HttpMethod=GET）</li><li>通过 MethodRoutePredicateFactory工厂的apply方法传入config创建Predicate对象。</li></ol></blockquote><blockquote><p>在此只对MethodRoutePredicateFactory做了描述和说明，其它的谓语工程基本与此一致。此时Spring-Cloud-Gateway的RoutePredicate所有逻辑代码都已经阅读完毕，对阅读过程做文档记录以便加深印象，后期翻阅</p></blockquote>]]></content>
      
      <categories>
          
          <category> Spring-Cloud-Gateway </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 网关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring-Cloud-Gateway初始化</title>
      <link href="/2018/09/04/Spring-Cloud-Gateway%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2018/09/04/Spring-Cloud-Gateway%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>Spring-Cloud项目使用EnableAutoConfiguration注解自动<br>初始化配置信息，Spring-Cloud-Gateway同样，Spring-Cloud-Gateway下的spring.factories如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">//依赖包的校验配置</span><br><span class="line">org.springframework.cloud.gateway.config.GatewayClassPathWarningAutoConfiguration,\</span><br><span class="line">//网关的核心配置</span><br><span class="line">org.springframework.cloud.gateway.config.GatewayAutoConfiguration,\</span><br><span class="line">//负载均衡相关依赖配置信息</span><br><span class="line">org.springframework.cloud.gateway.config.GatewayLoadBalancerClientAutoConfiguration,\</span><br><span class="line">//流控的依赖配置信息</span><br><span class="line">org.springframework.cloud.gateway.config.GatewayRedisAutoConfiguration,\</span><br><span class="line">//注册中心相关的依赖配置</span><br><span class="line">org.springframework.cloud.gateway.discovery.GatewayDiscoveryClientAutoConfiguration</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="析配置功能"><a href="#析配置功能" class="headerlink" title="析配置功能"></a>析配置功能</h4><blockquote><p>  分析配置功能前先了解下springboot常用的注解的含义</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行顺序</span><br><span class="line">@AutoConfigureAfter：在指定的配置类初始化后再加载</span><br><span class="line">@AutoConfigureBefore：在指定的配置类初始化前加载</span><br><span class="line">@AutoConfigureOrder：数越小越先初始化</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">条件配置</span><br><span class="line">@ConditionalOnClass ： classpath中存在该类时起效</span><br><span class="line">@ConditionalOnMissingClass ： classpath中不存在该类时起效</span><br><span class="line">@ConditionalOnBean ： DI容器中存在该类型Bean时起效</span><br><span class="line">@ConditionalOnMissingBean ： DI容器中不存在该类型Bean时起效</span><br><span class="line">@ConditionalOnSingleCandidate ： DI容器中该类型Bean只有一个或@Primary的只有一个时起效</span><br><span class="line">@ConditionalOnExpression ： SpEL表达式结果为true时</span><br><span class="line">@ConditionalOnProperty ： 参数设置或者值一致时起效</span><br><span class="line">@ConditionalOnResource ： 指定的文件存在时起效</span><br><span class="line">@ConditionalOnJndi ： 指定的JNDI存在时起效</span><br><span class="line">@ConditionalOnJava ： 指定的Java版本存在时起效</span><br><span class="line">@ConditionalOnWebApplication ： Web应用环境下起效</span><br><span class="line">@ConditionalOnNotWebApplication ： 非Web应用环境下起效</span><br></pre></td></tr></table></figure><hr><ol><li>GatewayClassPathWarningAutoConfiguration配置<blockquote><p>GatewayClassPathWarningAutoConfiguration配置用于检查项目是否正确导入 spring-boot-starter-webflux 依赖，而不是错误导入 spring-boot-starter-web 依赖，同时 GatewayClassPathWarningAutoConfiguration配置在EnableAutoConfiguration配置加载前加载<br>接下来我看代码如何实现</p></blockquote></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">//执行顺序注解</span><br><span class="line">//当前注解标识需要在GatewayAutoConfiguration前加载此配置</span><br><span class="line">@AutoConfigureBefore(GatewayAutoConfiguration.class)</span><br><span class="line">public class GatewayClassPathWarningAutoConfiguration &#123;</span><br><span class="line">@Configuration</span><br><span class="line">//条件判断注解</span><br><span class="line">//classpath中存在org.springframework.web.servlet.DispatcherServlet时起效，标识项目导入了spring-boot-starter-web包</span><br><span class="line">@ConditionalOnClass(name = &quot;org.springframework.web.servlet.DispatcherServlet&quot;)</span><br><span class="line">protected static class SpringMvcFoundOnClasspathConfiguration &#123;</span><br><span class="line"></span><br><span class="line">public SpringMvcFoundOnClasspathConfiguration() &#123;</span><br><span class="line">   //当前项目导入了spring-boot-starter-web依赖时，打印警告日志</span><br><span class="line">log.warn(BORDER+&quot;Spring MVC found on classpath, which is incompatible with Spring Cloud Gateway at this time. &quot;+</span><br><span class="line">&quot;Please remove spring-boot-starter-web dependency.&quot;+BORDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@Configuration</span><br><span class="line">//条件判断注解</span><br><span class="line">//classpath中不存在org.springframework.web.reactive.DispatcherHandler时起效，标识项目未导入了spring-boot-starter-webflux包</span><br><span class="line">@ConditionalOnMissingClass(&quot;org.springframework.web.reactive.DispatcherHandler&quot;)</span><br><span class="line">protected static class WebfluxMissingFromClasspathConfiguration &#123;</span><br><span class="line">public WebfluxMissingFromClasspathConfiguration() &#123;</span><br><span class="line">  //当前项目未导入了boot-starter-webflux依赖时，打印警告日志</span><br><span class="line">log.warn(BORDER+&quot;Spring Webflux is missing from the classpath, which is required for Spring Cloud Gateway at this time. &quot;+</span><br><span class="line">&quot;Please add spring-boot-starter-webflux dependency.&quot;+BORDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>GatewayLoadBalancerClientAutoConfiguration<blockquote><p>GatewayLoadBalancerClientAutoConfiguration配置作用是初始化 LoadBalancerClientFilter 路由的负载均衡拦截器</p></blockquote></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">//条件判断注解</span><br><span class="line">//classpath中存在LoadBalancerClient和RibbonAutoConfiguration和DispatcherHandler时此配置起效</span><br><span class="line">@ConditionalOnClass(&#123;LoadBalancerClient.class, RibbonAutoConfiguration.class, DispatcherHandler.class&#125;)</span><br><span class="line">//执行顺序注解</span><br><span class="line">@AutoConfigureAfter(RibbonAutoConfiguration.class)</span><br><span class="line">public class GatewayLoadBalancerClientAutoConfiguration &#123;</span><br><span class="line">// GlobalFilter beans</span><br><span class="line">@Bean</span><br><span class="line">//条件判断注解</span><br><span class="line">//DI容器中存在LoadBalancerClient类型Bean时起效</span><br><span class="line">@ConditionalOnBean(LoadBalancerClient.class)</span><br><span class="line">public LoadBalancerClientFilter loadBalancerClientFilter(LoadBalancerClient client) &#123;</span><br><span class="line">return new LoadBalancerClientFilter(client);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>GatewayRedisAutoConfiguration<blockquote><p>GatewayRedisAutoConfiguration 配置作用是初始化初始化 RedisRateLimiter  限流功能的RequestRateLimiterGatewayFilterFactory 基于 RedisRateLimiter 实现网关的限流功能，<strong>代码略</strong></p></blockquote></li><li>GatewayAutoConfiguration<blockquote><p>GatewayAutoConfiguration配置是Spring Cloud Gateway 核心配置类，初始化如下 ： </p><ul><li>NettyConfiguration 底层通信netty配置</li><li>GlobalFilter  （AdaptCachedBodyGlobalFilter，RouteToRequestUrlFilter，ForwardRoutingFilter，ForwardPathFilter，WebsocketRoutingFilter，WeightCalculatorWebFilter等）</li><li>FilteringWebHandler</li><li>GatewayProperties</li><li>PrefixPathGatewayFilterFactory</li><li>RoutePredicateFactory</li><li>RouteDefinitionLocator</li><li>RouteLocator</li><li>RoutePredicateHandlerMapping 查找匹配到 Route并进行处理</li><li>GatewayWebfluxEndpoint 管理网关的 HTTP API </li></ul></blockquote></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">//条件注解</span><br><span class="line">//通过 spring.cloud.gateway.enabled配置网关的开启与关闭</span><br><span class="line">//matchIfMissing = true =&gt; 网关默认开启。</span><br><span class="line">@ConditionalOnProperty(name = &quot;spring.cloud.gateway.enabled&quot;, matchIfMissing = true)</span><br><span class="line">@EnableConfigurationProperties</span><br><span class="line">@AutoConfigureBefore(HttpHandlerAutoConfiguration.class)</span><br><span class="line">@AutoConfigureAfter(&#123;GatewayLoadBalancerClientAutoConfiguration.class, GatewayClassPathWarningAutoConfiguration.class&#125;)</span><br><span class="line">@ConditionalOnClass(DispatcherHandler.class)</span><br><span class="line">public class GatewayAutoConfiguration &#123;</span><br><span class="line">   @Configuration</span><br><span class="line">   //当classpath中存在HttpClient起效</span><br><span class="line">@ConditionalOnClass(HttpClient.class)</span><br><span class="line">protected static class NettyConfiguration &#123;</span><br><span class="line">    .....略</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//加载配置beans</span><br><span class="line">// ConfigurationProperty beans</span><br><span class="line">@Bean</span><br><span class="line">public GatewayProperties gatewayProperties() &#123;</span><br><span class="line">return new GatewayProperties();</span><br><span class="line">&#125;</span><br><span class="line">@Bean</span><br><span class="line">public SecureHeadersProperties secureHeadersProperties() &#123;</span><br><span class="line">return new SecureHeadersProperties();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// GlobalFilter beans</span><br><span class="line">    //加载全局的拦截器</span><br><span class="line">@Bean</span><br><span class="line">public AdaptCachedBodyGlobalFilter adaptCachedBodyGlobalFilter() &#123;</span><br><span class="line">return new AdaptCachedBodyGlobalFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public RouteToRequestUrlFilter routeToRequestUrlFilter() &#123;</span><br><span class="line">return new RouteToRequestUrlFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">@ConditionalOnBean(DispatcherHandler.class)</span><br><span class="line">public ForwardRoutingFilter forwardRoutingFilter(DispatcherHandler dispatcherHandler) &#123;</span><br><span class="line">return new ForwardRoutingFilter(dispatcherHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public ForwardPathFilter forwardPathFilter() &#123;</span><br><span class="line">return new ForwardPathFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public WebSocketService webSocketService() &#123;</span><br><span class="line">return new HandshakeWebSocketService();</span><br><span class="line">&#125;</span><br><span class="line">@Bean</span><br><span class="line">public WebsocketRoutingFilter websocketRoutingFilter(WebSocketClient webSocketClient,</span><br><span class="line">return new WebsocketRoutingFilter(webSocketClient, webSocketService, headersFilters);</span><br><span class="line">&#125;</span><br><span class="line">@Bean</span><br><span class="line">public WeightCalculatorWebFilter weightCalculatorWebFilter(Validator validator) &#123;</span><br><span class="line">return new WeightCalculatorWebFilter(validator);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>GatewayDiscoveryClientAutoConfiguration<blockquote><p>GatewayDiscoveryClientAutoConfiguration配置的作用是初始化配置路由中的注册发现服务信息</p></blockquote></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">//同4</span><br><span class="line">@ConditionalOnProperty(name = &quot;spring.cloud.gateway.enabled&quot;, matchIfMissing = true)</span><br><span class="line">@AutoConfigureBefore(GatewayAutoConfiguration.class)</span><br><span class="line">@ConditionalOnClass(&#123;DispatcherHandler.class, DiscoveryClient.class&#125;)</span><br><span class="line">@EnableConfigurationProperties</span><br><span class="line">public class GatewayDiscoveryClientAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">//当classpath中存在DiscoveryClient起效</span><br><span class="line">@ConditionalOnBean(DiscoveryClient.class)</span><br><span class="line">//通过spring.cloud.gateway.discovery.locator.enabled配置注册中心查找的开启与关闭</span><br><span class="line">@ConditionalOnProperty(name = &quot;spring.cloud.gateway.discovery.locator.enabled&quot;)</span><br><span class="line">public DiscoveryClientRouteDefinitionLocator discoveryClientRouteDefinitionLocator(</span><br><span class="line">DiscoveryClient discoveryClient, DiscoveryLocatorProperties properties) &#123;</span><br><span class="line">return new DiscoveryClientRouteDefinitionLocator(discoveryClient, properties);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过自动加载初始化上述五个配置实例Spring-Cloud-Gateway就完成自身的信息加载和初始化工作，而对于使用者来说是无感知的</strong></p>]]></content>
      
      <categories>
          
          <category> Spring-Cloud-Gateway </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 网关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Eureka Server之注册服务实例租约信息管理LeaseManager</title>
      <link href="/2018/09/04/Eureka-Server%E4%B9%8B%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E7%A7%9F%E7%BA%A6%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86LeaseManager/"/>
      <url>/2018/09/04/Eureka-Server%E4%B9%8B%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E7%A7%9F%E7%BA%A6%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86LeaseManager/</url>
      <content type="html"><![CDATA[<blockquote><p>Eureka 注册中心服务端对注册进来的服务信息提供了一个基于时间的可用性管理(租约Lease)。通过此来管理注册服务的有效性<br><a id="more"></a></p></blockquote><h4 id="提供租约管理的包路径"><a href="#提供租约管理的包路径" class="headerlink" title="提供租约管理的包路径"></a>提供租约管理的包路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.netflix.eureka.lease</span><br></pre></td></tr></table></figure><h4 id="描述注册服务基于时间可用性"><a href="#描述注册服务基于时间可用性" class="headerlink" title="描述注册服务基于时间可用性"></a>描述注册服务基于时间可用性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例租约包装类，描述实例基于时间的可用性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lease</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例针对租约变化的动作类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">enum</span> Action &#123;</span><br><span class="line">        <span class="comment">//实例注册</span></span><br><span class="line">        Register,</span><br><span class="line">        <span class="comment">//实例取消</span></span><br><span class="line">        Cancel,</span><br><span class="line">        <span class="comment">//实例刷新</span></span><br><span class="line">        Renew</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的租约有效时长 90s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_DURATION_IN_SECS = <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例信息，此处默认为 InstanceInfo</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T holder;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消注册时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> evictionTimestamp;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> registrationTimestamp;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> serviceUpTimestamp;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最后更新时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// Make it volatile so that the expiration task would see this quicker</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastUpdateTimestamp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 租约的有效时长</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> durationInSecs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lease</span><span class="params">(T r, <span class="keyword">int</span> durationInSecs)</span> </span>&#123;</span><br><span class="line">        holder = r;</span><br><span class="line">        registrationTimestamp = System.currentTimeMillis();</span><br><span class="line">        lastUpdateTimestamp = registrationTimestamp;</span><br><span class="line">        duration = (durationInSecs * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>在Lease类中可以看到是使用了装饰模式对注册实例进行了包装，提供了基于时间可用性的新功能。</p><ul><li>enum Action  定义了租约时间变更的动作类型，此处包含注册，下线，刷新（心跳发送刷新租约信息）等三个动作</li><li>evictionTimestamp：服务下线时间</li><li>registrationTimestamp: 服务注册时间</li><li>lastUpdateTimestamp: 最后更新时间</li><li>duration : 租约的有效时长默认90s</li></ul></blockquote><blockquote><p>Lease类对实例InstanceInfo进行功能扩展的方法：</p></blockquote><ol><li><p>renew</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 刷新租约的时间信息，租约续订更新最后更新时间为当前时间+租约有效时长</span></span><br><span class="line"><span class="comment"> * Renew the lease, use renewal duration if it was specified by the</span></span><br><span class="line"><span class="comment"> * associated &#123;<span class="doctag">@link</span> T&#125; during registration, otherwise default duration is</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #DEFAULT_DURATION_IN_SECS&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">renew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lastUpdateTimestamp = System.currentTimeMillis() + duration;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>cancel</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册列表剔除当前服务，更新租约的时间信息</span></span><br><span class="line"><span class="comment"> * Cancels the lease by updating the eviction time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evictionTimestamp &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        evictionTimestamp = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>serviceUp</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务上线时间</span></span><br><span class="line"><span class="comment"> * Mark the service as up. This will only take affect the first time called,</span></span><br><span class="line"><span class="comment"> * subsequent calls will be ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (serviceUpTimestamp == <span class="number">0</span>) &#123;</span><br><span class="line">        serviceUpTimestamp = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>isExpired</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测租约是否过期</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">(<span class="keyword">long</span> additionalLeaseMs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//剔除服务时间&gt;0或当前时间&gt;（最后更新时间+租约有效时长+时间偏差）时 表示租约已失效</span></span><br><span class="line">    <span class="keyword">return</span> (evictionTimestamp &gt; <span class="number">0</span> || System.currentTimeMillis() &gt; (lastUpdateTimestamp + duration + additionalLeaseMs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>renew:针对动作Renew</li><li>cancel:针对动作cancel</li><li>serviceUp:针对动作Register</li><li>isExpired: 用于校验当前实例的租约是否有效，对外提供服务可用性的检测</li></ol></blockquote><h4 id="注册服务基于时间可用性管理"><a href="#注册服务基于时间可用性管理" class="headerlink" title="注册服务基于时间可用性管理"></a>注册服务基于时间可用性管理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例租约管理接口，根据租约更新的动作类型操作实例的租约信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LeaseManager</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册实例，更新实例租约信息</span></span><br><span class="line"><span class="comment">     * Assign a new &#123;<span class="doctag">@link</span> Lease&#125; to the passed in &#123;<span class="doctag">@link</span> T&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(T r, <span class="keyword">int</span> leaseDuration, <span class="keyword">boolean</span> isReplication)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 剔除实例时，更新实例租约信息</span></span><br><span class="line"><span class="comment">     * Cancel the &#123;<span class="doctag">@link</span> Lease&#125; associated w/ the passed in &lt;code&gt;appName&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * and &lt;code&gt;id&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 刷新实例时更新实例租约信息</span></span><br><span class="line"><span class="comment">     * Renew the &#123;<span class="doctag">@link</span> Lease&#125; associated w/ the passed in &lt;code&gt;appName&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * and &lt;code&gt;id&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 剔除已过期的租约实例信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">evict</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>LeaseManager接口用于提供服务实例基于时间可控性的管理（租约管理），提供以下功能：</p><ol><li>register ： 服务注册进来设置租约的serviceUp</li><li>cancel : 服务下线，设置实例租约的cancel</li><li>renew ： 服务报活（心跳检测）设置租约的renew</li><li>evict : 遍历注册表通过实例租约isExpired方法校验是否过期，过期强制服务下线操作</li></ol></blockquote><blockquote><p>其中 1-3 是Eureka 客户端发起操作，4,为服务端定时任务轮询服务注册表，主动剔除过期实例。</p></blockquote><blockquote><p>LeaseManager默认实现类 AbstractInstanceRegistry</p></blockquote><ol><li>register</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册实例，更新实例租约信息</span></span><br><span class="line"><span class="comment">     * Registers a new instance with a given duration.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(InstanceInfo registrant, <span class="keyword">int</span> leaseDuration, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            read.lock();</span><br><span class="line">            <span class="comment">//注册表中查询当前注册服务的集群列表信息</span></span><br><span class="line">            Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(registrant.getAppName());</span><br><span class="line">            REGISTER.increment(isReplication);</span><br><span class="line">            <span class="keyword">if</span> (gMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//集群不存在时，创建一个新的空集群并添加到注册表</span></span><br><span class="line">                <span class="keyword">final</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt; gNewMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt;();</span><br><span class="line">                gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap);</span><br><span class="line">                <span class="keyword">if</span> (gMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    gMap = gNewMap;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在集群列表中根据服务ID查询实例信息</span></span><br><span class="line">            Lease&lt;InstanceInfo&gt; existingLease = gMap.get(registrant.getId());</span><br><span class="line">            <span class="comment">// Retain the last dirty timestamp without overwriting it, if there is already a lease</span></span><br><span class="line">            <span class="keyword">if</span> (existingLease != <span class="keyword">null</span> &amp;&amp; (existingLease.getHolder() != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="comment">//服务实例信息已存在与集群中</span></span><br><span class="line">                <span class="comment">//根据传入实例与已存在实例的LastDirtyTimestamp判断使用具体实例</span></span><br><span class="line">                Long existingLastDirtyTimestamp = existingLease.getHolder().getLastDirtyTimestamp();</span><br><span class="line">                Long registrationLastDirtyTimestamp = registrant.getLastDirtyTimestamp();</span><br><span class="line">                logger.debug(<span class="string">"Existing lease found (existing=&#123;&#125;, provided=&#123;&#125;"</span>, existingLastDirtyTimestamp, registrationLastDirtyTimestamp);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is a &gt; instead of a &gt;= because if the timestamps are equal, we still take the remote transmitted</span></span><br><span class="line">                <span class="comment">// InstanceInfo instead of the server local copy.</span></span><br><span class="line">                <span class="keyword">if</span> (existingLastDirtyTimestamp &gt; registrationLastDirtyTimestamp) &#123;</span><br><span class="line">                    registrant = existingLease.getHolder();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//服务实例信息不存在与集群中</span></span><br><span class="line">                <span class="comment">// The lease does not exist and hence it is a new registration</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// Since the client wants to cancel it, reduce the threshold</span></span><br><span class="line">                        <span class="comment">// (1</span></span><br><span class="line">                        <span class="comment">// for 30 seconds, 2 for a minute)</span></span><br><span class="line">                        <span class="keyword">this</span>.expectedNumberOfRenewsPerMin = <span class="keyword">this</span>.expectedNumberOfRenewsPerMin + <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">this</span>.numberOfRenewsPerMinThreshold =</span><br><span class="line">                                (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                logger.debug(<span class="string">"No previous lease information found; it is new registration"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据服务实例信息构建新的租约实例信息</span></span><br><span class="line">            Lease&lt;InstanceInfo&gt; lease = <span class="keyword">new</span> Lease&lt;InstanceInfo&gt;(registrant, leaseDuration);</span><br><span class="line">            <span class="keyword">if</span> (existingLease != <span class="keyword">null</span>) &#123;</span><br><span class="line">                lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//添加服务实例到集群列表</span></span><br><span class="line">            gMap.put(registrant.getId(), lease);</span><br><span class="line">            <span class="keyword">synchronized</span> (recentRegisteredQueue) &#123;</span><br><span class="line">                <span class="comment">//新注册队列中添加当前注册的信息</span></span><br><span class="line">                recentRegisteredQueue.add(<span class="keyword">new</span> Pair&lt;Long, String&gt;(</span><br><span class="line">                        System.currentTimeMillis(),</span><br><span class="line">                        registrant.getAppName() + <span class="string">"("</span> + registrant.getId() + <span class="string">")"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断重载状态</span></span><br><span class="line">            <span class="comment">// This is where the initial state transfer of overridden status happens</span></span><br><span class="line">            <span class="keyword">if</span> (!InstanceStatus.UNKNOWN.equals(registrant.getOverriddenStatus())) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Found overridden status &#123;&#125; for instance &#123;&#125;. Checking to see if needs to be add to the "</span></span><br><span class="line">                                + <span class="string">"overrides"</span>, registrant.getOverriddenStatus(), registrant.getId());</span><br><span class="line">                <span class="keyword">if</span> (!overriddenInstanceStatusMap.containsKey(registrant.getId())) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Not found overridden id &#123;&#125; and hence adding it"</span>, registrant.getId());</span><br><span class="line">                    <span class="comment">//将当前服务实例的重载状态添加到重载状态MAP集合中</span></span><br><span class="line">                    overriddenInstanceStatusMap.put(registrant.getId(), registrant.getOverriddenStatus());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取当前实例的重载状态</span></span><br><span class="line">            InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(registrant.getId());</span><br><span class="line">            <span class="keyword">if</span> (overriddenStatusFromMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.info(<span class="string">"Storing overridden status &#123;&#125; from map"</span>, overriddenStatusFromMap);</span><br><span class="line">                <span class="comment">//设置服务的重载状态</span></span><br><span class="line">                registrant.setOverriddenStatus(overriddenStatusFromMap);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//基于状态规则重新设置状态</span></span><br><span class="line">            <span class="comment">// Set the status based on the overridden status rules</span></span><br><span class="line">            InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(registrant, existingLease, isReplication);</span><br><span class="line">            registrant.setStatusWithoutDirty(overriddenInstanceStatus);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断服务注册状态，当状态为UP 更新租约信息</span></span><br><span class="line">            <span class="comment">// If the lease is registered with UP status, set lease service up timestamp</span></span><br><span class="line">            <span class="keyword">if</span> (InstanceStatus.UP.equals(registrant.getStatus())) &#123;</span><br><span class="line">                lease.serviceUp();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置服务实例的动作类型为ADD</span></span><br><span class="line">            registrant.setActionType(ActionType.ADDED);</span><br><span class="line">            <span class="comment">//将服务添加到最近的改变队列</span></span><br><span class="line">            recentlyChangedQueue.add(<span class="keyword">new</span> RecentlyChangedItem(lease));</span><br><span class="line">            <span class="comment">//设置服务最后更新时间</span></span><br><span class="line">            registrant.setLastUpdatedTimestamp();</span><br><span class="line">            <span class="comment">//校验缓存信息</span></span><br><span class="line">            invalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress());</span><br><span class="line">            logger.info(<span class="string">"Registered instance &#123;&#125;/&#123;&#125; with status &#123;&#125; (replication=&#123;&#125;)"</span>,</span><br><span class="line">                    registrant.getAppName(), registrant.getId(), registrant.getStatus(), isReplication);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            read.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>cancel</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据集群ID ，服务实例ID剔除集群中服务信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">internalCancel</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           read.lock();</span><br><span class="line">           CANCEL.increment(isReplication);</span><br><span class="line">           <span class="comment">//注册表中获取集群信息列表</span></span><br><span class="line">           Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</span><br><span class="line">           Lease&lt;InstanceInfo&gt; leaseToCancel = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//在就集群列表中根据服务ID移除服务</span></span><br><span class="line">               leaseToCancel = gMap.remove(id);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">synchronized</span> (recentCanceledQueue) &#123;</span><br><span class="line">               <span class="comment">//添加最近下线队列，将当前的下线信息</span></span><br><span class="line">               recentCanceledQueue.add(<span class="keyword">new</span> Pair&lt;Long, String&gt;(System.currentTimeMillis(), appName + <span class="string">"("</span> + id + <span class="string">")"</span>));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//重载实例状态map集合中移除当前的实例的重载状态</span></span><br><span class="line">           InstanceStatus instanceStatus = overriddenInstanceStatusMap.remove(id);</span><br><span class="line">           <span class="keyword">if</span> (instanceStatus != <span class="keyword">null</span>) &#123;</span><br><span class="line">               logger.debug(<span class="string">"Removed instance id &#123;&#125; from the overridden map which has value &#123;&#125;"</span>, id, instanceStatus.name());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (leaseToCancel == <span class="keyword">null</span>) &#123;</span><br><span class="line">               CANCEL_NOT_FOUND.increment(isReplication);</span><br><span class="line">               logger.warn(<span class="string">"DS: Registry: cancel failed because Lease is not registered for: &#123;&#125;/&#123;&#125;"</span>, appName, id);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//调用租约实例的下线方法，变更租约信息</span></span><br><span class="line">               leaseToCancel.cancel();</span><br><span class="line">               <span class="comment">//获取实例信息</span></span><br><span class="line">               InstanceInfo instanceInfo = leaseToCancel.getHolder();</span><br><span class="line">               String vip = <span class="keyword">null</span>;</span><br><span class="line">               String svip = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> (instanceInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">//设置实例操作类型为DELETED</span></span><br><span class="line">                   instanceInfo.setActionType(ActionType.DELETED);</span><br><span class="line">                   <span class="comment">//最近变更队列中添加当前实例信息</span></span><br><span class="line">                   recentlyChangedQueue.add(<span class="keyword">new</span> RecentlyChangedItem(leaseToCancel));</span><br><span class="line">                   <span class="comment">//更新实例的最后更新时间</span></span><br><span class="line">                   instanceInfo.setLastUpdatedTimestamp();</span><br><span class="line">                   vip = instanceInfo.getVIPAddress();</span><br><span class="line">                   svip = instanceInfo.getSecureVipAddress();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//校验缓存信息</span></span><br><span class="line">               invalidateCache(appName, vip, svip);</span><br><span class="line">               logger.info(<span class="string">"Cancelled instance &#123;&#125;/&#123;&#125; (replication=&#123;&#125;)"</span>, appName, id, isReplication);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           read.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>renew</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 刷新实例时更新实例租约信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">        RENEW.increment(isReplication);</span><br><span class="line">        <span class="comment">//获取集群列表</span></span><br><span class="line">        Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</span><br><span class="line">        Lease&lt;InstanceInfo&gt; leaseToRenew = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//集群列表中查询实例信息</span></span><br><span class="line">            leaseToRenew = gMap.get(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leaseToRenew == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RENEW_NOT_FOUND.increment(isReplication);</span><br><span class="line">            logger.warn(<span class="string">"DS: Registry: lease doesn't exist, registering resource: &#123;&#125; - &#123;&#125;"</span>, appName, id);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获取实例信息</span></span><br><span class="line">            InstanceInfo instanceInfo = leaseToRenew.getHolder();</span><br><span class="line">            <span class="keyword">if</span> (instanceInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// touchASGCache(instanceInfo.getASGName());</span></span><br><span class="line">                <span class="comment">//基于状态规则重新设置状态</span></span><br><span class="line">                InstanceStatus overriddenInstanceStatus = <span class="keyword">this</span>.getOverriddenInstanceStatus(</span><br><span class="line">                        instanceInfo, leaseToRenew, isReplication);</span><br><span class="line">                <span class="keyword">if</span> (overriddenInstanceStatus == InstanceStatus.UNKNOWN) &#123;</span><br><span class="line">                    RENEW_NOT_FOUND.increment(isReplication);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) &#123;</span><br><span class="line">                    Object[] args = &#123;</span><br><span class="line">                            instanceInfo.getStatus().name(),</span><br><span class="line">                            instanceInfo.getOverriddenStatus().name(),</span><br><span class="line">                            instanceInfo.getId()</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">//设置实例状态</span></span><br><span class="line">                    instanceInfo.setStatusWithoutDirty(overriddenInstanceStatus);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            renewsLastMin.increment();</span><br><span class="line">            <span class="comment">//租约刷新</span></span><br><span class="line">            leaseToRenew.renew();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>evict</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 剔除已过期的租约实例信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> additionalLeaseMs</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">(<span class="keyword">long</span> additionalLeaseMs)</span> </span>&#123;</span><br><span class="line">       logger.debug(<span class="string">"Running the evict task"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!isLeaseExpirationEnabled()) &#123;</span><br><span class="line">           logger.debug(<span class="string">"DS: lease expiration is currently disabled."</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// We collect first all expired items, to evict them in random order. For large eviction sets,</span></span><br><span class="line">       <span class="comment">// if we do not that, we might wipe out whole apps before self preservation kicks in. By randomizing it,</span></span><br><span class="line">       <span class="comment">// the impact should be evenly distributed across all applications.</span></span><br><span class="line">       List&lt;Lease&lt;InstanceInfo&gt;&gt; expiredLeases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="comment">//在注册表中查询租约过期的实例列表</span></span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; groupEntry : registry.entrySet()) &#123;</span><br><span class="line">           Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseMap = groupEntry.getValue();</span><br><span class="line">           <span class="keyword">if</span> (leaseMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseEntry : leaseMap.entrySet()) &#123;</span><br><span class="line">                   Lease&lt;InstanceInfo&gt; lease = leaseEntry.getValue();</span><br><span class="line">                   <span class="comment">//lease.isExpired() 判断租约是否过期</span></span><br><span class="line">                   <span class="keyword">if</span> (lease.isExpired(additionalLeaseMs) &amp;&amp; lease.getHolder() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       expiredLeases.add(lease);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// To compensate for GC pauses or drifting local time, we need to use current registry size as a base for</span></span><br><span class="line">       <span class="comment">// triggering self-preservation. Without that we would wipe out full registry.</span></span><br><span class="line">       <span class="comment">//获取本地注册表的大小</span></span><br><span class="line">       <span class="keyword">int</span> registrySize = (<span class="keyword">int</span>) getLocalRegistrySize();</span><br><span class="line">       <span class="comment">//注册表阈值，由registrySize * 配置百分比参数RenewalPercentThreshold</span></span><br><span class="line">       <span class="keyword">int</span> registrySizeThreshold = (<span class="keyword">int</span>) (registrySize * serverConfig.getRenewalPercentThreshold());</span><br><span class="line">       <span class="comment">//剔除租约过期的数量 由于RenewalPercentThreshold取值在0-1之间，当为1时，evictionLimit为0</span></span><br><span class="line">       <span class="comment">// 即toEvict为0，每次时不会进行对过期的租约服务下线操作，同时 evictionLimit &lt; expiredLeases.size() 时，</span></span><br><span class="line">       <span class="comment">// 每次操作不会将全部的过期租约实例下线</span></span><br><span class="line">       <span class="keyword">int</span> evictionLimit = registrySize - registrySizeThreshold;</span><br><span class="line">       <span class="comment">//在租约过期列表大小与每次剔除配置大小中取小值作为本地要剔除的服务实例数</span></span><br><span class="line">       <span class="keyword">int</span> toEvict = Math.min(expiredLeases.size(), evictionLimit);</span><br><span class="line">       <span class="keyword">if</span> (toEvict &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           logger.info(<span class="string">"Evicting &#123;&#125; items (expired=&#123;&#125;, evictionLimit=&#123;&#125;)"</span>, toEvict, expiredLeases.size(), evictionLimit);</span><br><span class="line">           Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">           <span class="comment">//遍历剔除服务</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; toEvict; i++) &#123;</span><br><span class="line">               <span class="comment">// Pick a random item (Knuth shuffle algorithm)</span></span><br><span class="line">               <span class="keyword">int</span> next = i + random.nextInt(expiredLeases.size() - i);</span><br><span class="line">               Collections.swap(expiredLeases, i, next);</span><br><span class="line">               Lease&lt;InstanceInfo&gt; lease = expiredLeases.get(i);</span><br><span class="line"></span><br><span class="line">               String appName = lease.getHolder().getAppName();</span><br><span class="line">               String id = lease.getHolder().getId();</span><br><span class="line">               EXPIRED.increment();</span><br><span class="line">               logger.warn(<span class="string">"DS: Registry: expired lease for &#123;&#125;/&#123;&#125;"</span>, appName, id);</span><br><span class="line">               <span class="comment">//调用下线服务方法</span></span><br><span class="line">               internalCancel(appName, id, <span class="keyword">false</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>AbstractInstanceRegistry类中保存这服务注册表信息，1-3方法为客户端主动发起请求到server端的resources模块，resource接受到客户端的请求，根据请求类型调用<br>AbstractInstanceRegistry中的1-3方法。</p></blockquote><blockquote><p>4 方法为服务端定时清除注册表中的租约过期实例；在AbstractInstanceRegistry类中如下实现：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      renewsLastMin.start();</span><br><span class="line">      <span class="keyword">if</span> (evictionTaskRef.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          evictionTaskRef.get().cancel();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//创建清除过期租约任务</span></span><br><span class="line">      evictionTaskRef.set(<span class="keyword">new</span> EvictionTask());</span><br><span class="line">      <span class="comment">//启动定时清除注册表中过期租约信息定时任务</span></span><br><span class="line">      evictionTimer.schedule(evictionTaskRef.get(),</span><br><span class="line">              serverConfig.getEvictionIntervalTimerInMs(),</span><br><span class="line">              serverConfig.getEvictionIntervalTimerInMs());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>postInit 初始化定时任务信息，执行定时清除租约过期任务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvictionTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong lastExecutionNanosRef = <span class="keyword">new</span> AtomicLong(<span class="number">0l</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> compensationTimeMs = getCompensationTimeMs();</span><br><span class="line">             </span><br><span class="line">                <span class="comment">// 执行租约管理方法evict</span></span><br><span class="line">                evict(compensationTimeMs);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                logger.error(<span class="string">"Could not run the evict task"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><blockquote><p>EvictionTask任务run方法中，执行租约管理的evict方法检测注册表中的过期租约实例，并对其进行下线操作。</p></blockquote><blockquote><p>至此，Eureka赋予了服务注册实例InstanceInfo的基于时间的可用性，并对实例提供了基于时间的可用性的管理。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring-Cloud-Gateway之GatewayProperties初始化加载</title>
      <link href="/2018/09/03/Spring-Cloud-Gateway%E4%B9%8BGatewayProperties%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8A%A0%E8%BD%BD/"/>
      <url>/2018/09/03/Spring-Cloud-Gateway%E4%B9%8BGatewayProperties%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8A%A0%E8%BD%BD/</url>
      <content type="html"><![CDATA[<p>在Spring-Cloud-Gateway初始化时我们在GatewayAutoConfiguration配置中看到了有初始化加载GatewayProperties实例的配置，接下来学习下GatewayProperties都加载了哪些信息</p><hr><a id="more"></a><p>GatewayAutoConfiguration中我看到加载GatewayProperties如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   //加载配置beans</span><br><span class="line">// ConfigurationProperty beans</span><br><span class="line">@Bean</span><br><span class="line">public GatewayProperties gatewayProperties() &#123;</span><br><span class="line">return new GatewayProperties();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GatewayProperties的代码如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 网关配置信息加载</span><br><span class="line"> * 从appliccation.yml中解析前缀为spring.cloud.gateway的配置</span><br><span class="line"> * @author Spencer Gibb</span><br><span class="line"> */</span><br><span class="line">@ConfigurationProperties(&quot;spring.cloud.gateway&quot;)</span><br><span class="line">@Validated</span><br><span class="line">public class GatewayProperties &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 路由定义列表</span><br><span class="line"> * 加载配置key=spring.cloud.gateway.routes 列表</span><br><span class="line"> * List of Routes</span><br><span class="line"> */</span><br><span class="line">@NotNull</span><br><span class="line">@Valid</span><br><span class="line">private List&lt;RouteDefinition&gt; routes = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 默认的过滤器定义列表</span><br><span class="line"> * 加载配置 key = spring.cloud.gateway.default-filters 列表</span><br><span class="line"> * List of filter definitions that are applied to every route.</span><br><span class="line"> */</span><br><span class="line">private List&lt;FilterDefinition&gt; defaultFilters = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 网媒体类型列表</span><br><span class="line"> * 加载配置 key = spring.cloud.gateway.streamingMediaTypes 列表</span><br><span class="line"> * 默认包含&#123;text/event-stream,application/stream+json&#125;</span><br><span class="line"> */</span><br><span class="line">private List&lt;MediaType&gt; streamingMediaTypes = Arrays.asList(MediaType.TEXT_EVENT_STREAM,</span><br><span class="line">MediaType.APPLICATION_STREAM_JSON);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由GatewayProperties代码可以看出其包含如下配置信息</p><blockquote><ul><li>spring.cloud.gateway.routes:网关路由定义配置，列表形式</li><li>spring.cloud.gateway.default-filters: 网关默认过滤器定义配置，列表形式</li><li>spring.cloud.gateway.streamingMediaTypes:网关网络媒体类型，列表形式</li></ul></blockquote><p>同时，我们看到代码中的routes其实RouteDefinition集合，defaultFilters是FilterDefinition集合，在Spring-Cloud-Gateway之route数据模型我们已经分析了这两个数据模型所有的字段含义以及类型了。通过数据模型以及代码可以看出配置中可以包含的具体信息。</p><hr><ul><li>spring.cloud.gateway.routes<blockquote><ul><li>id:路由ID 编号，唯一</li><li>uri:  路由指向的URI</li><li>order: 顺序</li><li>predicates:谓语数组，列表形式</li></ul></blockquote></li></ul><hr><ul><li>spring.cloud.gateway.default-filters<blockquote><ul><li>name:过滤器定义名称</li><li>args:  参数</li></ul></blockquote></li></ul><hr><p>接下来看下Spring-Cloud-Gateway给的样例工程（spring-cloud-gateway-sample）中的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      default-filters:</span><br><span class="line">      - PrefixPath=/httpbin</span><br><span class="line">      - AddResponseHeader=X-Response-Default-Foo, Default-Bar</span><br><span class="line">      routes:</span><br><span class="line">      - id: websocket_test</span><br><span class="line">        uri: ws://localhost:9000</span><br><span class="line">        order: 9000</span><br><span class="line">        predicates:</span><br><span class="line">        - Path=/echo</span><br><span class="line">      - id: default_path_to_httpbin</span><br><span class="line">        uri: $&#123;test.uri&#125;</span><br><span class="line">        order: 10000</span><br><span class="line">        predicates:</span><br><span class="line">        - Path=/**</span><br></pre></td></tr></table></figure><ul><li>备注<blockquote><p> default-filters下配置PrefixPath=/httpbin字符串，可以查看FilterDefinition中构造函数，它接收一个text字符串解析字符传并创建实例信息。同样predicates配置与其一致。<br>字符传格式：name=param1,param2,param3…..。</p></blockquote></li></ul><p>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public FilterDefinition(String text) &#123;</span><br><span class="line">int eqIdx = text.indexOf(&quot;=&quot;);</span><br><span class="line">if (eqIdx &lt;= 0) &#123;</span><br><span class="line">setName(text);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">setName(text.substring(0, eqIdx));</span><br><span class="line"></span><br><span class="line">String[] args = tokenizeToStringArray(text.substring(eqIdx+1), &quot;,&quot;);</span><br><span class="line"></span><br><span class="line">for (int i=0; i &lt; args.length; i++) &#123;</span><br><span class="line">this.args.put(NameUtils.generateName(i), args[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的配置可以很容易的知道最终加载出来GatewayProperties实例中都包含哪些信息。</p><blockquote><p>弄懂了配置的具体加载以及初始化会加深对网关整体流程的理解，合理的使用配置文件定义我们自己的需求，快速的根据配置定位，了解服务的详细情况</p></blockquote>]]></content>
      
      <categories>
          
          <category> Spring-Cloud-Gateway </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 网关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring-Cloud-Gateway之route数据模型</title>
      <link href="/2018/09/03/Spring-Cloud-Gateway%E4%B9%8Broute%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/09/03/Spring-Cloud-Gateway%E4%B9%8Broute%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>网关服务核心是将进入的请求正确合理的路由到下层具体的服务进行业务处理，由此可见网关服务的核心就是路由信息的构建。下面学习和阅读下Spring-Cloud-Gateway的route数据模型</p><a id="more"></a><hr><p>首先查看Route模型的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Route implements Ordered &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 路由编号</span><br><span class="line"> * ID 编号，唯一</span><br><span class="line"> */</span><br><span class="line">private final String id;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 路由向的 URI</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">private final URI uri;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 顺序</span><br><span class="line"> * 当请求匹配到多个路由时，使用顺序小的</span><br><span class="line"> */</span><br><span class="line">private final int order;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 谓语数组</span><br><span class="line"> * 请求通过 predicates 判断是否匹配</span><br><span class="line"> */</span><br><span class="line">private final Predicate&lt;ServerWebExchange&gt; predicate;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 过滤器数组</span><br><span class="line"> */</span><br><span class="line">private final List&lt;GatewayFilter&gt; gatewayFilters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由代码可以看到一个路由应该包含如下必要的信息：</p><ul><li>id：路由编号，唯一</li><li>uri:路由向的 URI,对应的具体业务服务的URL</li><li>order:顺序，当请求匹配多个路由时，使用顺序小的</li><li>predicate: 请求匹配路由的断言条件</li><li>gatewayFilters: 当前路由上存在的过滤器，用于对请求做拦截处理</li></ul></blockquote><hr><p>Route模型是通过RouteDefinition（路由定义）模型构建起来的，接下来查看RouteDefinition</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 路由定义实体信息，包含路由的定义信息</span><br><span class="line"> * @author Spencer Gibb</span><br><span class="line"> */</span><br><span class="line">@Validated</span><br><span class="line">public class RouteDefinition &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 路由ID 编号，唯一</span><br><span class="line"> */</span><br><span class="line">@NotEmpty</span><br><span class="line">private String id = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 谓语定义数组</span><br><span class="line"> * predicates 属性，谓语定义数组</span><br><span class="line"> * 请求通过 predicates 判断是否匹配。在 Route 里，PredicateDefinition 转换成 Predicate</span><br><span class="line"> */</span><br><span class="line">@NotEmpty</span><br><span class="line">@Valid</span><br><span class="line">private List&lt;PredicateDefinition&gt; predicates = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *过滤器定义数组</span><br><span class="line"> * filters 属性，过滤器定义数组。</span><br><span class="line"> * 在 Route 里，FilterDefinition 转换成 GatewayFilter</span><br><span class="line"> */</span><br><span class="line">@Valid</span><br><span class="line">private List&lt;FilterDefinition&gt; filters = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 路由指向的URI</span><br><span class="line"> */</span><br><span class="line">@NotNull</span><br><span class="line">private URI uri;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 顺序</span><br><span class="line"> */</span><br><span class="line">private int order = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个模型与上面的Route模型是不是很相似，它是对route的定义以及描述，Spring-Cloud-Gateway最终会通过RouteDefinition来构建起Route实例信息。<br>细看RouteDefinition代码会发现其中包含两个数组分别是PredicateDefinition，FilterDefinition的数组。</p><blockquote><ul><li>PredicateDefinition : 断言条件(谓语)定义，构建 Route 时，PredicateDefinition 转换成 Predicate</li><li>FilterDefinition : 过滤条件的定义，构建Route 时，FilterDefinition 转换成 GatewayFilter</li></ul></blockquote><hr><p>那么我们看下PredicateDefinition与FilterDefinition的代码</p><ul><li>PredicateDefinition<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 谓语定义,在 Route 里，PredicateDefinition将转换成 Predicate</span><br><span class="line"> * @author Spencer Gibb</span><br><span class="line"> */</span><br><span class="line">@Validated</span><br><span class="line">public class PredicateDefinition &#123;</span><br><span class="line">/**</span><br><span class="line"> * 谓语定义名字</span><br><span class="line"> * 通过 name 对应到 org.springframework.cloud.gateway.handler.predicate.RoutePredicateFactory 的实现类。</span><br><span class="line"> * 例如: name=Query 对应到 QueryRoutePredicateFactory</span><br><span class="line"> */</span><br><span class="line">@NotNull</span><br><span class="line">private String name;</span><br><span class="line">/**</span><br><span class="line"> * 参数数组</span><br><span class="line"> * 例如，name=Host / args=&#123;&quot;_genkey_0&quot; : &quot;iocoder.cn&quot;&#125; ，匹配请求的 hostname 为 iocoder.cn</span><br><span class="line"> */</span><br><span class="line">private Map&lt;String, String&gt; args = new LinkedHashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>PredicateDefinition 描述了构建Predicate的必要条件</p><ul><li>name:名称，Spring-Cloud-Gateway会根据name找到Predicate的构建工厂类</li><li>args:参数，构建Predicate的参数</li></ul></blockquote><ul><li>FilterDefinition</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 过滤器定义，在 Route 里，FilterDefinition将转换成 GatewayFilter</span><br><span class="line"> * @author Spencer Gibb</span><br><span class="line"> */</span><br><span class="line">@Validated</span><br><span class="line">public class FilterDefinition &#123;</span><br><span class="line">/**</span><br><span class="line"> * 过滤器定义名字</span><br><span class="line"> * 通过 name 对应到 org.springframework.cloud.gateway.filter.factory.GatewayFilterFactory 的实现类。</span><br><span class="line"> * 例如，name=AddRequestParameter 对应到 AddRequestParameterGatewayFilterFactory</span><br><span class="line"> */</span><br><span class="line">@NotNull</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 参数数组</span><br><span class="line"> * 例如 name=AddRequestParameter / args=&#123;&quot;_genkey_0&quot;: &quot;foo&quot;, &quot;_genkey_1&quot;: &quot;bar&quot;&#125; ，添加请求参数 foo 为 bar</span><br><span class="line"> */</span><br><span class="line">private Map&lt;String, String&gt; args = new LinkedHashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>FilterDefinition 描述了构建GatewayFilter的必要条件</p><ul><li>name:名称，Spring-Cloud-Gateway会根据name找到GatewayFilter的构建工厂类</li><li>args:参数，构建GatewayFilter的参数</li></ul></blockquote><hr><p>通过这些基础的数据模型我可以清晰看到Spring-Cloud-Gateway构建路由的数据流向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">FilterDefinition--&gt;RouteDefinition</span><br><span class="line">PredicateDefinition--&gt;RouteDefinition</span><br><span class="line">RouteDefinition--&gt;Route</span><br></pre></td></tr></table></figure><p>通过数据流向可以帮助我们接下来阅读Route信息的初始化加载以及路由的使用</p>]]></content>
      
      <categories>
          
          <category> Spring-Cloud-Gateway </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 网关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Eureka之服务发现LookupService</title>
      <link href="/2018/08/28/Eureka%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0LookupService/"/>
      <url>/2018/08/28/Eureka%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0LookupService/</url>
      <content type="html"><![CDATA[<blockquote><p>Eureka 注册中心，核心为提供服务注册，以及服务发现功能，下面我们重点讨论下Eureka核心功能之一的服务发现。<br>我们知道Eureka采用的C-S架构，客户端要通过请求服务端获取注册列表，提供给服务使用，服务端要保存客户端发来的注册信息保存下（Eureka采用的是内存存储），并提供给资源服务Resources使用，有关资源服务可见Eureka之REST API<br><a id="more"></a></p></blockquote><h4 id="LookupService体系图"><a href="#LookupService体系图" class="headerlink" title="LookupService体系图"></a>LookupService体系图</h4><p><img src="https://github.com/guofazhan/image/blob/master/LookupService.png?raw=true" alt="image"></p><blockquote><ol><li>InstanceRegistry为Server端对资源服务提供服务发现功能的接口，用来读取服务端本地缓存注册表信息</li><li>EurekaClient 为Client端实现的服务发现接口，用来获取客户端本地缓存中的注册表信息</li><li>RemoteRegionRegistry 为Server用来读取其它区域的服务注册表的接口，并将其它区域的服务注册表缓存到本地，供本地InstanceRegistry使用。</li></ol></blockquote><h4 id="Eureka区域，分区"><a href="#Eureka区域，分区" class="headerlink" title="Eureka区域，分区"></a>Eureka区域，分区</h4><blockquote><p> eureka提供了region和zone两个概念来进行分区，这两个概念均来自于亚马逊的AWS：</p><ol><li>region：可以简单理解为地理上的分区，比如亚洲地区，或者华北地区，再或者北京等等，没有具体大小的限制。根据项目具体的情况，可以自行合理划分region。RemoteRegionRegistry就是其它分区的服务注册信息。</li><li>zone：可以简单理解为region内的具体机房，比如说region划分为北京，然后北京有两个机房，就可以在此region之下划分出zone1,zone2两个zone。</li></ol></blockquote><blockquote><p>RemoteRegionRegistry 根据配置实例化：         </p><ol><li>配置KEY： eureka.remoteRegionUrlsWithName   </li><li>格式： eureka.remoteRegionUrlsWithName=region1;<a href="http://region1host/eureka/v2,region2;http://region2host/eureka/v2" target="_blank" rel="noopener">http://region1host/eureka/v2,region2;http://region2host/eureka/v2</a></li><li>解析: regionName-&gt;remoteRegionURL 根据解析出来的MAP 创建相应的 RemoteRegionRegistry</li></ol></blockquote><blockquote><p><strong><em>备注：</em></strong> 一般中小行项目基本所有服务都部署在同一机房，不存在区域划分这些，即初始化时:RemoteRegionRegistry List为空,具体可参见AbstractInstanceRegistry的initRemoteRegionRegistry方法</p></blockquote><h4 id="LookupService类图以及实现"><a href="#LookupService类图以及实现" class="headerlink" title="LookupService类图以及实现"></a>LookupService类图以及实现</h4><p><img src="https://github.com/guofazhan/image/blob/master/LookupServiceUml.png?raw=true" alt="image"></p><h5 id="服务发现LookupService接口"><a href="#服务发现LookupService接口" class="headerlink" title="服务发现LookupService接口"></a>服务发现LookupService接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务发现接口</span></span><br><span class="line"><span class="comment"> * Lookup service for finding active instances.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Karthik Ranganathan, Greg Kim.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; for backward compatibility</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LookupService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据集群ID获取集群列表</span></span><br><span class="line"><span class="comment">     * Returns the corresponding &#123;<span class="doctag">@link</span> Application&#125; object which is basically a</span></span><br><span class="line"><span class="comment">     * container of all registered &lt;code&gt;appName&lt;/code&gt; &#123;<span class="doctag">@link</span> InstanceInfo&#125;s.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> appName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> Application&#125; or null if we couldn't locate any app of</span></span><br><span class="line"><span class="comment">     *         the requested appName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Application <span class="title">getApplication</span><span class="params">(String appName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取服务注册列表</span></span><br><span class="line"><span class="comment">     * Returns the &#123;<span class="doctag">@link</span> Applications&#125; object which is basically a container of</span></span><br><span class="line"><span class="comment">     * all currently registered &#123;<span class="doctag">@link</span> Application&#125;s.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Applications&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Applications <span class="title">getApplications</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据实例ID获取实例信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;InstanceInfo&gt; <span class="title">getInstancesById</span><span class="params">(String id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 轮询获取集群中的下一个可用的注册服务，起到负载均衡作用，保证每个可用注册服务均衡的被使用，此方法仅提供个Eureka 客户端使用实现，服务端默认为空实现</span></span><br><span class="line"><span class="comment">     * Gets the next possible server to process the requests from the registry</span></span><br><span class="line"><span class="comment">     * information received from eureka.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">InstanceInfo <span class="title">getNextServerFromEureka</span><span class="params">(String virtualHostname, <span class="keyword">boolean</span> secure)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>从接口可以看到提供了四个功能方法如下：</p><ol><li>getApplication:根据集群ID获取集群列表</li><li>getApplications:获取服务注册列表</li><li>getInstancesById:根据实例ID获取实例信息</li><li>getNextServerFromEureka:轮询获取集群中的下一个可用的注册服务，起到负载均衡作用，保证每个可用注册服务均衡的被使用，此方法仅提供个Eureka 客户端使用实现，服务端默认为空实现</li></ol></blockquote><h5 id="服务端实现AbstractInstanceRegistry"><a href="#服务端实现AbstractInstanceRegistry" class="headerlink" title="服务端实现AbstractInstanceRegistry"></a>服务端实现AbstractInstanceRegistry</h5><ol><li>缓存服务注册属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 服务注册表</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; registry</span><br><span class="line">         = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure><ol start="2"><li>其它区域服务发现集合属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 远程区域服务发现注册服务集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Map&lt;String, RemoteRegionRegistry&gt; regionNameVSRemoteRegistry = <span class="keyword">new</span> HashMap&lt;String, RemoteRegionRegistry&gt;();</span><br></pre></td></tr></table></figure><ol start="3"><li>getApplications功能方法实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取服务注册列表信息</span></span><br><span class="line"><span class="comment"> * Get all applications in this instance registry, falling back to other regions if allowed in the Eureka config.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the list of all known applications</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.netflix.discovery.shared.LookupService#getApplications()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Applications <span class="title">getApplications</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//配置参数，是否禁用远程区域的服务注册列表</span></span><br><span class="line">    <span class="keyword">boolean</span> disableTransparentFallback = serverConfig.disableTransparentFallbackToOtherRegion();</span><br><span class="line">    <span class="keyword">if</span> (disableTransparentFallback) &#123;</span><br><span class="line">        <span class="comment">//获取本地服务注册列表</span></span><br><span class="line">        <span class="keyword">return</span> getApplicationsFromLocalRegionOnly();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取服务注册列表在所有区域中，包含本地</span></span><br><span class="line">        <span class="keyword">return</span> getApplicationsFromAllRemoteRegions();  <span class="comment">// Behavior of falling back to remote region can be disabled.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获服务注册列表,在所有区域</span></span><br><span class="line"><span class="comment"> * Returns applications including instances from all remote regions. &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * Same as calling &#123;<span class="doctag">@link</span> #getApplicationsFromMultipleRegions(String[])&#125; with a &lt;code&gt;null&lt;/code&gt; argument.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Applications <span class="title">getApplicationsFromAllRemoteRegions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据区域信息获取服务注册列表，此处区域列表传入所有远程区域列表</span></span><br><span class="line">    <span class="keyword">return</span> getApplicationsFromMultipleRegions(allKnownRemoteRegions);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取本地服务注册列表</span></span><br><span class="line"><span class="comment"> * Returns applications including instances from local region only. &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * Same as calling &#123;<span class="doctag">@link</span> #getApplicationsFromMultipleRegions(String[])&#125; with an empty array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Applications <span class="title">getApplicationsFromLocalRegionOnly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据区域信息获取服务注册列表，此处区域列表传入空值</span></span><br><span class="line">    <span class="keyword">return</span> getApplicationsFromMultipleRegions(EMPTY_STR_ARRAY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据区域信息查询服务注册列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Applications <span class="title">getApplicationsFromMultipleRegions</span><span class="params">(String[] remoteRegions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否根据远程区域查询服务注册列表标识</span></span><br><span class="line">    <span class="keyword">boolean</span> includeRemoteRegion = <span class="keyword">null</span> != remoteRegions &amp;&amp; remoteRegions.length != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    logger.debug(<span class="string">"Fetching applications registry with remote regions: &#123;&#125;, Regions argument &#123;&#125;"</span>,</span><br><span class="line">            includeRemoteRegion, Arrays.toString(remoteRegions));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录统计监控数据</span></span><br><span class="line">    <span class="keyword">if</span> (includeRemoteRegion) &#123;</span><br><span class="line">        GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS.increment();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        GET_ALL_CACHE_MISS.increment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建服务注册列表实例信息</span></span><br><span class="line">    Applications apps = <span class="keyword">new</span> Applications();</span><br><span class="line">    apps.setVersion(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">//加入本地注册信息到服务注册列表实例中</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; entry : registry.entrySet()) &#123;</span><br><span class="line">        Application app = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; stringLeaseEntry : entry.getValue().entrySet()) &#123;</span><br><span class="line">                Lease&lt;InstanceInfo&gt; lease = stringLeaseEntry.getValue();</span><br><span class="line">                <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    app = <span class="keyword">new</span> Application(lease.getHolder().getAppName());</span><br><span class="line">                &#125;</span><br><span class="line">                app.addInstance(decorateInstanceInfo(lease));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            apps.addApplication(app);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否加入远程区域的注册信息</span></span><br><span class="line">    <span class="keyword">if</span> (includeRemoteRegion) &#123;</span><br><span class="line">        <span class="comment">//遍历远程区域，添加远程区域的注册信息到服务注册列表实例</span></span><br><span class="line">        <span class="keyword">for</span> (String remoteRegion : remoteRegions) &#123;</span><br><span class="line">            RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != remoteRegistry) &#123;</span><br><span class="line">                Applications remoteApps = remoteRegistry.getApplications();</span><br><span class="line">                <span class="keyword">for</span> (Application application : remoteApps.getRegisteredApplications()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) &#123;</span><br><span class="line">                        logger.info(<span class="string">"Application &#123;&#125;  fetched from the remote region &#123;&#125;"</span>,</span><br><span class="line">                                application.getName(), remoteRegion);</span><br><span class="line"></span><br><span class="line">                        Application appInstanceTillNow = apps.getRegisteredApplications(application.getName());</span><br><span class="line">                        <span class="keyword">if</span> (appInstanceTillNow == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            appInstanceTillNow = <span class="keyword">new</span> Application(application.getName());</span><br><span class="line">                            apps.addApplication(appInstanceTillNow);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (InstanceInfo instanceInfo : application.getInstances()) &#123;</span><br><span class="line">                            appInstanceTillNow.addInstance(instanceInfo);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        logger.debug(<span class="string">"Application &#123;&#125; not fetched from the remote region &#123;&#125; as there exists a "</span></span><br><span class="line">                                        + <span class="string">"whitelist and this app is not in the whitelist."</span>,</span><br><span class="line">                                application.getName(), remoteRegion);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(<span class="string">"No remote registry available for the remote region &#123;&#125;"</span>, remoteRegion);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置实例的hashCode</span></span><br><span class="line">    apps.setAppsHashCode(apps.getReconcileHashCode());</span><br><span class="line">    <span class="keyword">return</span> apps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>getApplications功能主要由以下方法完成：</p><ol><li>getApplications : 此方法根据配置参数信息，判断是只从本地缓存中获取注册列表(getApplicationsFromLocalRegionOnly)还是从所以区域获取注册列表(getApplicationsFromAllRemoteRegions)，参数信息：disableTransparentFallback</li><li>getApplicationsFromLocalRegionOnly :获取本地缓存中的注册表信息，调用getApplicationsFromMultipleRegions传入空区域集合</li><li>getApplicationsFromAllRemoteRegions : 从所有区域查找注册表信息，传入全部区域集合。</li><li>getApplicationsFromMultipleRegions ：根据传入区域信息查询注册表信息</li></ol></blockquote><blockquote><p> getApplicationsFromMultipleRegions完成如下功能:</p><ol><li>构建空注册表实例：Applications</li><li>添加本地缓存的注册信息到Applications</li><li>判断是否查找其它区域</li><li>遍历其它区域RemoteRegionRegistry获取Applications</li><li>添加其它区域中注册的信息到Applications（剔除重复的）</li><li>设置apps的hashCode 用于增量更新</li></ol></blockquote><ol start="4"><li>getApplications功能方法实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据服务集群ID，查询服务集群列表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> appName the application name of the application</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the application</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.netflix.discovery.shared.LookupService#getApplication(java.lang.String)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">getApplication</span><span class="params">(String appName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取配置信息</span></span><br><span class="line">    <span class="comment">//配置参数，是否禁用远程区域的服务注册列表</span></span><br><span class="line">    <span class="keyword">boolean</span> disableTransparentFallback = serverConfig.disableTransparentFallbackToOtherRegion();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getApplication(appName, !disableTransparentFallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据服务集群ID，查询服务集群列表</span></span><br><span class="line"><span class="comment"> * Get application information.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the application</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">getApplication</span><span class="params">(String appName, <span class="keyword">boolean</span> includeRemoteRegion)</span> </span>&#123;</span><br><span class="line">    Application app = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取本地注册列表中的服务集群信息</span></span><br><span class="line">    Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseMap = registry.get(appName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leaseMap != <span class="keyword">null</span> &amp;&amp; leaseMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//构建集群实例Application</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; entry : leaseMap.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">                app = <span class="keyword">new</span> Application(appName);</span><br><span class="line">            &#125;</span><br><span class="line">            app.addInstance(decorateInstanceInfo(entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (includeRemoteRegion) &#123;</span><br><span class="line">        <span class="comment">//包含远程区域时，通过远程区域注册服务查询集群信息</span></span><br><span class="line">        <span class="keyword">for</span> (RemoteRegionRegistry remoteRegistry : <span class="keyword">this</span>.regionNameVSRemoteRegistry.values()) &#123;</span><br><span class="line">            Application application = remoteRegistry.getApplication(appName);</span><br><span class="line">            <span class="keyword">if</span> (application != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> application;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回集群实例</span></span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>getApplication功能主要由以下方法完成：<br>getApplication ： 根据 集群名称以及参数是否禁用其它区域来获取集群列表Application</p><ol><li>通过本地缓存注册信息获取组装集群实例Application</li><li>当本地缓存中未查到集群信息且可用远程区域发现服务查询时，遍历远程区域发现服务查询集群信息组装<br>集群实例Application</li><li>返回集群实例Application</li></ol></blockquote><ol start="5"><li>getInstancesById功能方法实现<blockquote><p>与4功能类似</p></blockquote></li><li>getNextServerFromEureka功能方法实现<blockquote><p>空实现</p></blockquote></li></ol><h5 id="客户端实现DiscoveryClient"><a href="#客户端实现DiscoveryClient" class="headerlink" title="客户端实现DiscoveryClient"></a>客户端实现DiscoveryClient</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (non-Javadoc)</span></span><br><span class="line"><span class="comment"> * @see com.netflix.discovery.shared.LookupService#getApplication(java.lang.String)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">getApplication</span><span class="params">(String appName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getApplications().getRegisteredApplications(appName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (non-Javadoc)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see com.netflix.discovery.shared.LookupService#getApplications()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Applications <span class="title">getApplications</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> localRegionApps.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (non-Javadoc)</span></span><br><span class="line"><span class="comment"> * @see com.netflix.discovery.shared.LookupService#getInstancesById(java.lang.String)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;InstanceInfo&gt; <span class="title">getInstancesById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    List&lt;InstanceInfo&gt; instancesList = <span class="keyword">new</span> ArrayList&lt;InstanceInfo&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Application app : <span class="keyword">this</span>.getApplications()</span><br><span class="line">            .getRegisteredApplications()) &#123;</span><br><span class="line">        InstanceInfo instanceInfo = app.getByInstanceId(id);</span><br><span class="line">        <span class="keyword">if</span> (instanceInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            instancesList.add(instanceInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instancesList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在客户端的实现方法中可以清晰的看到是通过localRegionApps.get()获取服务注册列表实例，此实例是在本地缓存存储且为原子性的。下面我们主要查看localRegionApps是怎么加载以及更新</p></blockquote><ul><li>构造函数首次加载localRegionApps</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//通过fetchRegistry方法首次从远程Server端获取注册列表缓存到客户端本地，默认选择增量拉取</span></span><br><span class="line"><span class="keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="keyword">false</span>)) &#123;</span><br><span class="line">    fetchRegistryFromBackup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在构造函数中调用fetchRegistry 首次初始化从服务端拉取服务注册实例并缓存到客户端内存中</p><ul><li>初始化定时任务，定时拉取服务端注册信息刷新本地缓存</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Initializes all scheduled tasks.</span><br><span class="line"> */</span><br><span class="line">private void initScheduledTasks() &#123;</span><br><span class="line">    //判断客户端远程拉取注册表禁用配置，true，标识客户端运行定时拉取远程注册表配置</span><br><span class="line">    if (clientConfig.shouldFetchRegistry()) &#123;</span><br><span class="line">        // registry cache refresh timer</span><br><span class="line">        int registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();</span><br><span class="line">        int expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();</span><br><span class="line">        //定时任务定时执行客户端远程拉取注册表来更新客户端本地缓存</span><br><span class="line">        scheduler.schedule(</span><br><span class="line">                new TimedSupervisorTask(</span><br><span class="line">                        &quot;cacheRefresh&quot;,</span><br><span class="line">                        scheduler,</span><br><span class="line">                        cacheRefreshExecutor,</span><br><span class="line">                        registryFetchIntervalSeconds,</span><br><span class="line">                        TimeUnit.SECONDS,</span><br><span class="line">                        expBackOffBound,</span><br><span class="line">                        new CacheRefreshThread()</span><br><span class="line">                ),</span><br><span class="line">                registryFetchIntervalSeconds, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line"> * 远程拉取Server端注册表信息更新客户端本地缓存，定时任务，客户端定时执行此任务</span><br><span class="line"> * The task that fetches the registry information at specified intervals.</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">class CacheRefreshThread implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        refreshRegistry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>构造函数初始化定时任务，调用initScheduledTasks</li><li>定时任务，初始化刷新服务注册表实例定时任务</li><li>CacheRefreshThread线程定时执行，调用refreshRegistry()方法从server端拉取注册信息并刷新本地缓存</li></ol></blockquote><ul><li>fetchRegistry功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端拉取Eureka Server服务注册列表，本地缓存 (forceFullRegistryFetch 是否全量拉取标识)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">fetchRegistry</span><span class="params">(<span class="keyword">boolean</span> forceFullRegistryFetch)</span> </span>&#123;</span><br><span class="line">        Stopwatch tracer = FETCH_REGISTRY_TIMER.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// If the delta is disabled or if it is the first time, get all</span></span><br><span class="line">            <span class="comment">// applications</span></span><br><span class="line">            <span class="comment">//本地缓存中获取注册列表信息</span></span><br><span class="line">            Applications applications = getApplications();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断全量拉取还是增量拉取</span></span><br><span class="line">            <span class="keyword">if</span> (clientConfig.shouldDisableDelta()</span><br><span class="line">                    || (!Strings.isNullOrEmpty(clientConfig.getRegistryRefreshSingleVipAddress()))</span><br><span class="line">                    || forceFullRegistryFetch</span><br><span class="line">                    || (applications == <span class="keyword">null</span>)</span><br><span class="line">                    || (applications.getRegisteredApplications().size() == <span class="number">0</span>)</span><br><span class="line">                    || (applications.getVersion() == -<span class="number">1</span>)) <span class="comment">//Client application does not have latest library supporting delta</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//全量拉取注册表信息</span></span><br><span class="line">                getAndStoreFullRegistry();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//增量拉取注册表信息</span></span><br><span class="line">                getAndUpdateDelta(applications);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置hashCode，注册列表判断变化是根据hashCode</span></span><br><span class="line">            applications.setAppsHashCode(applications.getReconcileHashCode());</span><br><span class="line">            <span class="comment">//日志打印统计</span></span><br><span class="line">            logTotalInstances();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(PREFIX + appPathIdentifier + <span class="string">" - was unable to refresh its cache! status = "</span> + e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (tracer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                tracer.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通知缓存刷新事件</span></span><br><span class="line">        <span class="comment">// Notify about cache refresh before updating the instance remote status</span></span><br><span class="line">        onCacheRefreshed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新实例的远程状态</span></span><br><span class="line">        <span class="comment">// Update remote status based on refreshed data held in the cache</span></span><br><span class="line">        updateInstanceRemoteStatus();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// registry was fetched successfully, so return true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全量拉取Eureka Server端的注册列表信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAndStoreFullRegistry</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> currentUpdateGeneration = fetchRegistryGeneration.get();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"Getting all instance registry info from the eureka server"</span>);</span><br><span class="line"></span><br><span class="line">        Applications apps = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//通过远程通讯组件请求Server端获取全量注册列表</span></span><br><span class="line">        EurekaHttpResponse&lt;Applications&gt; httpResponse = clientConfig.getRegistryRefreshSingleVipAddress() == <span class="keyword">null</span></span><br><span class="line">                ? eurekaTransport.queryClient.getApplications(remoteRegionsRef.get())</span><br><span class="line">                : eurekaTransport.queryClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress(), remoteRegionsRef.get());</span><br><span class="line">        <span class="keyword">if</span> (httpResponse.getStatusCode() == Status.OK.getStatusCode()) &#123;</span><br><span class="line">            apps = httpResponse.getEntity();</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">"The response status is &#123;&#125;"</span>, httpResponse.getStatusCode());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (apps == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">"The application is null for some reason. Not storing this information"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//获取的注册列表缓存到本地</span></span><br><span class="line">            localRegionApps.set(<span class="keyword">this</span>.filterAndShuffle(apps));</span><br><span class="line">            logger.debug(<span class="string">"Got full registry with apps hashcode &#123;&#125;"</span>, apps.getAppsHashCode());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(<span class="string">"Not updating applications as another thread is updating it already"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增量拉取Eureka Server端的注册列表信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAndUpdateDelta</span><span class="params">(Applications applications)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> currentUpdateGeneration = fetchRegistryGeneration.get();</span><br><span class="line"></span><br><span class="line">        Applications delta = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//通过远程通讯组件请求Server端获取增量注册列表</span></span><br><span class="line">        EurekaHttpResponse&lt;Applications&gt; httpResponse = eurekaTransport.queryClient.getDelta(remoteRegionsRef.get());</span><br><span class="line">        <span class="keyword">if</span> (httpResponse.getStatusCode() == Status.OK.getStatusCode()) &#123;</span><br><span class="line">            delta = httpResponse.getEntity();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (delta == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">"The server does not allow the delta revision to be applied because it is not safe. "</span></span><br><span class="line">                    + <span class="string">"Hence got the full registry."</span>);</span><br><span class="line">            <span class="comment">//增量获取为空时，全量拉取</span></span><br><span class="line">            getAndStoreFullRegistry();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + <span class="number">1</span>)) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Got delta update with apps hashcode &#123;&#125;"</span>, delta.getAppsHashCode());</span><br><span class="line">            String reconcileHashCode = <span class="string">""</span>;</span><br><span class="line">            <span class="comment">//拉取注册表更新锁</span></span><br><span class="line">            <span class="keyword">if</span> (fetchRegistryUpdateLock.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//更新增量信息到本地缓存中的注册表中</span></span><br><span class="line">                    updateDelta(delta);</span><br><span class="line">                    <span class="comment">//获取更新后的HashCode</span></span><br><span class="line">                    reconcileHashCode = getReconcileHashCode(applications);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    fetchRegistryUpdateLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(<span class="string">"Cannot acquire update lock, aborting getAndUpdateDelta"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断本地的hashCode是否与远程hashCode一致，不一致时，需要同步一致</span></span><br><span class="line">            <span class="comment">// There is a diff in number of instances for some reason</span></span><br><span class="line">            <span class="keyword">if</span> (!reconcileHashCode.equals(delta.getAppsHashCode()) || clientConfig.shouldLogDeltaDiff()) &#123;</span><br><span class="line">                reconcileAndLogDifference(delta, reconcileHashCode);  <span class="comment">// this makes a remoteCall</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(<span class="string">"Not updating application delta as another thread is updating it already"</span>);</span><br><span class="line">            logger.debug(<span class="string">"Ignoring delta update with apps hashcode &#123;&#125;, as another thread is updating it already"</span>, delta.getAppsHashCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>fetchRegistry : 根据传入参数以及配置信息判断是否全量拉取还是增量拉取，全量拉取调用getAndStoreFullRegistry方法 ；增量拉取调用getAndUpdateDelta方法</li><li>getAndStoreFullRegistry：全量从Server拉取服务注册信息，更新本地缓存。此方法通过Eureka提供的远程通讯模块调用Server端暴露的Resources信息获取服务注册列表实例apps</li><li>getAndUpdateDelta ：增量从Server端拉取服务的增量注册信息，更新本地缓存实例。</li></ol></blockquote><h5 id="远程区域服务发现实现RemoteRegionRegistry"><a href="#远程区域服务发现实现RemoteRegionRegistry" class="headerlink" title="远程区域服务发现实现RemoteRegionRegistry"></a>远程区域服务发现实现RemoteRegionRegistry</h5><blockquote><p>与客户端实现方式基本一致，不在描述</p></blockquote><h4 id="客户端，服务端，远程区域服务端交互"><a href="#客户端，服务端，远程区域服务端交互" class="headerlink" title="客户端，服务端，远程区域服务端交互"></a>客户端，服务端，远程区域服务端交互</h4><p><img src="https://github.com/guofazhan/image/blob/master/LookupService1.png?raw=true" alt="image"></p><hr>]]></content>
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Eureka之远程通讯模块</title>
      <link href="/2018/08/25/Eureka%E4%B9%8B%E8%BF%9C%E7%A8%8B%E9%80%9A%E8%AE%AF%E6%A8%A1%E5%9D%97/"/>
      <url>/2018/08/25/Eureka%E4%B9%8B%E8%BF%9C%E7%A8%8B%E9%80%9A%E8%AE%AF%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<blockquote><p>Eureka 架构为C-S模式 同时支持S 集群 ，不可避免的在client-server、server-server之间是需要远程通讯的，上面已经知道，Eureka 提供是http协议rest api，下面通过源码源码分析学习下eureka 提供的远程通讯模块</p></blockquote><h4 id="提供远程通讯模块的包路径"><a href="#提供远程通讯模块的包路径" class="headerlink" title="提供远程通讯模块的包路径"></a>提供远程通讯模块的包路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.netflix.discovery.shared.transport</span><br></pre></td></tr></table></figure><h4 id="通讯模块对外的核心接口矩阵"><a href="#通讯模块对外的核心接口矩阵" class="headerlink" title="通讯模块对外的核心接口矩阵"></a>通讯模块对外的核心接口矩阵</h4><p><img src="https://github.com/guofazhan/image/blob/master/%E9%80%9A%E8%AE%AF%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3.png?raw=true" alt="image"></p><blockquote><ol><li>EurekaHttpClient 通讯请求接口，负责发送http请求</li><li>EurekaHttpClientFactory EurekaHttpClient创建工厂接口，负责创建高等级的client</li><li>TransportClientFactory EurekaHttpClient创建工厂接口，负责创建低等级的client</li><li>EurekaTransportConfig 通讯相关配置获取接口，负责在配置文件中读取通讯模块的配置信息</li></ol></blockquote><blockquote><p><strong>备注：</strong> EurekaHttpClientFactory与TransportClientFactory同样都是创建client工厂，不过两个的职责不一样，client按功能划分为两大类，下面详细介绍。<br><a id="more"></a></p></blockquote><h4 id="EurekaHttpClient"><a href="#EurekaHttpClient" class="headerlink" title="EurekaHttpClient"></a>EurekaHttpClient</h4><p><img src="https://github.com/guofazhan/image/blob/master/EurekaHttpClient.png?raw=true" alt="image"></p><blockquote><p>通过上图可以明确的看出EurekaHttpClient接口实现为两大类:</p><ol><li>实现http通讯的lowlevel实现；</li><li>使用装饰器模式实现特定功能的top level实现 。</li></ol></blockquote><blockquote><p>low level实现：  Eureka 根据http client 实现了两个AbstractJerseyEurekaHttpClient与AbstractJersey2EurekaHttpClient的low level 实现。从上面可以看出，如果Jersey1与Jersey2都不满足我们的自己的需求的话，我也可以根据自己需要的httpClient实现替代类，例如实现以OKhttp作为底层通讯的OkHttpEurekaHttpClient 或实现以netty作为底层通讯的NettyEurekaHttpClient，</p></blockquote><blockquote><p>top level实现 ： 通过装饰器模式eueka 内置了 响应指标采集功能的装饰器、失败重试功能装饰器等，同时我们也可以扩展。</p></blockquote><blockquote><p><strong> 备注：</strong> HttpReplicationClient是eureka 专为server端集群节点通讯提供的通讯接口。其本质low level</p></blockquote><ul><li>EurekaHttpClient接口方法</li></ul><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>register(InstanceInfo info)</td><td>服务注册</td></tr><tr><td>cancel(String appName, String id)</td><td>服务下线</td></tr><tr><td>sendHeartBeat</td><td>服务续约</td></tr><tr><td>statusUpdate</td><td>服务状态更新</td></tr><tr><td>deleteStatusOverride</td><td></td></tr><tr><td>getApplications(String… regions)</td><td>获取服务注册列表</td></tr><tr><td>getDelta(String… regions)</td><td>获取增量列表</td></tr><tr><td>getVip(String vipAddress, String… regions)</td><td>根据vip获取列表</td></tr><tr><td>getSecureVip(String secureVipAddress, String… regions)</td><td>根据svip获取列表</td></tr><tr><td>getApplication(String appName)</td><td>根据集群ID获取服务集群列表</td></tr><tr><td>getInstance(String appName, String id)</td><td>根据集群ID与服务ID获取服务</td></tr><tr><td>getInstance(String id)</td><td>根据服务ID获取服务</td></tr></tbody></table><ul><li>HttpReplicationClient接口方法 (server 节点数据同步特有)</li></ul><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>statusUpdate(String asgName, ASGStatus newStatus)</td><td>状态更新同步</td></tr><tr><td>submitBatchUpdates(ReplicationList replicationList)</td><td>批量执行更新同步任务</td></tr></tbody></table><h4 id="EurekaTransportConfig通讯配置新获取"><a href="#EurekaTransportConfig通讯配置新获取" class="headerlink" title="EurekaTransportConfig通讯配置新获取"></a>EurekaTransportConfig通讯配置新获取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * eureka 远程通讯客户端配置默认实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> David Liu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEurekaTransportConfig</span> <span class="keyword">implements</span> <span class="title">EurekaTransportConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUB_NAMESPACE = TRANSPORT_CONFIG_SUB_NAMESPACE + <span class="string">"."</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namespace;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DynamicPropertyFactory configInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEurekaTransportConfig</span><span class="params">(String parentNamespace, DynamicPropertyFactory configInstance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.namespace = parentNamespace == <span class="keyword">null</span></span><br><span class="line">                ? SUB_NAMESPACE</span><br><span class="line">                : (parentNamespace.endsWith(<span class="string">"."</span>)</span><br><span class="line">                    ? parentNamespace + SUB_NAMESPACE</span><br><span class="line">                    : parentNamespace + <span class="string">"."</span> + SUB_NAMESPACE);</span><br><span class="line">        <span class="keyword">this</span>.configInstance = configInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSessionedClientReconnectIntervalSeconds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInstance.getIntProperty(namespace + SESSION_RECONNECT_INTERVAL_KEY, Values.SESSION_RECONNECT_INTERVAL).get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>1.构建函数创建 DynamicPropertyFactory</p><ol start="2"><li>构建函数 初始化namespace 配置key的前缀</li><li>获取配置信息通过DynamicPropertyFactory 动态在配置文件中获取</li></ol></blockquote><h4 id="EurekaHttpClients-工具类"><a href="#EurekaHttpClients-工具类" class="headerlink" title="EurekaHttpClients 工具类"></a>EurekaHttpClients 工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaHttpClients</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(EurekaHttpClients.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EurekaHttpClients</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EurekaHttpClientFactory <span class="title">queryClientFactory</span><span class="params">(ClusterResolver bootstrapResolver,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                             TransportClientFactory transportClientFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                             EurekaClientConfig clientConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                             EurekaTransportConfig transportConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                             InstanceInfo myInstanceInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                             ApplicationsResolver.ApplicationsSource applicationsSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClosableResolver queryResolver = transportConfig.useBootstrapResolverForQuery()</span><br><span class="line">                ? wrapClosable(bootstrapResolver)</span><br><span class="line">                : queryClientResolver(bootstrapResolver, transportClientFactory,</span><br><span class="line">                clientConfig, transportConfig, myInstanceInfo, applicationsSource);</span><br><span class="line">        <span class="keyword">return</span> canonicalClientFactory(EurekaClientNames.QUERY, transportConfig, queryResolver, transportClientFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EurekaHttpClientFactory <span class="title">registrationClientFactory</span><span class="params">(ClusterResolver bootstrapResolver,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                    TransportClientFactory transportClientFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                    EurekaTransportConfig transportConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> canonicalClientFactory(EurekaClientNames.REGISTRATION, transportConfig, bootstrapResolver, transportClientFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> EurekaHttpClientFactory <span class="title">canonicalClientFactory</span><span class="params">(<span class="keyword">final</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                          <span class="keyword">final</span> EurekaTransportConfig transportConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                          <span class="keyword">final</span> ClusterResolver&lt;EurekaEndpoint&gt; clusterResolver,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                          <span class="keyword">final</span> TransportClientFactory transportClientFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EurekaHttpClientFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> EurekaHttpClient <span class="title">newClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SessionedEurekaHttpClient(</span><br><span class="line">                        name,</span><br><span class="line">                        RetryableEurekaHttpClient.createFactory(</span><br><span class="line">                                name,</span><br><span class="line">                                transportConfig,</span><br><span class="line">                                clusterResolver,</span><br><span class="line">                                RedirectingEurekaHttpClient.createFactory(transportClientFactory),</span><br><span class="line">                                ServerStatusEvaluators.legacyEvaluator()),</span><br><span class="line">                        transportConfig.getSessionedClientReconnectIntervalSeconds() * <span class="number">1000</span></span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                wrapClosable(clusterResolver).shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>EurekaHttpClients，是创建EurekaHttpClientFactory的工具类</p></blockquote><h4 id="EurekaHttpClient-Low-Level部分"><a href="#EurekaHttpClient-Low-Level部分" class="headerlink" title="EurekaHttpClient Low Level部分"></a>EurekaHttpClient Low Level部分</h4><ul><li>JerseyEurekaHttpClientFactory</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JerseyEurekaHttpClientFactory</span> <span class="keyword">implements</span> <span class="title">TransportClientFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTTP_X_DISCOVERY_ALLOW_REDIRECT = <span class="string">"X-Discovery-AllowRedirect"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaJerseyClient jerseyClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApacheHttpClient4 apacheClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApacheHttpClientConnectionCleaner cleaner;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; additionalHeaders;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JerseyEurekaHttpClientFactory</span><span class="params">(EurekaJerseyClient jerseyClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          ApacheHttpClient4 apacheClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">long</span> connectionIdleTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Map&lt;String, String&gt; additionalHeaders)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jerseyClient = jerseyClient;</span><br><span class="line">        <span class="keyword">this</span>.apacheClient = jerseyClient != <span class="keyword">null</span> ? jerseyClient.getClient() : apacheClient;</span><br><span class="line">        <span class="keyword">this</span>.additionalHeaders = additionalHeaders;</span><br><span class="line">        <span class="keyword">this</span>.cleaner = <span class="keyword">new</span> ApacheHttpClientConnectionCleaner(<span class="keyword">this</span>.apacheClient, connectionIdleTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务创建JerseyApplicationClient</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EurekaHttpClient <span class="title">newClient</span><span class="params">(EurekaEndpoint endpoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JerseyApplicationClient(apacheClient, endpoint.getServiceUrl(), additionalHeaders);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>JerseyEurekaHttpClientFactory 为TransportClientFactory的Jersey1实现主要负责创建JerseyEurekaHttpClient </p></blockquote><ul><li>AbstractJerseyEurekaHttpClient</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractJerseyEurekaHttpClient</span> <span class="keyword">implements</span> <span class="title">EurekaHttpClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbstractJerseyEurekaHttpClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * jersey1 http 客户端，负责底层发送http请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Client jerseyClient;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * server url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String serviceUrl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractJerseyEurekaHttpClient</span><span class="params">(Client jerseyClient, String serviceUrl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jerseyClient = jerseyClient;</span><br><span class="line">        <span class="keyword">this</span>.serviceUrl = serviceUrl;</span><br><span class="line">        logger.debug(<span class="string">"Created client for url: &#123;&#125;"</span>, serviceUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务注册</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> info</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">register</span><span class="params">(InstanceInfo info)</span> </span>&#123;</span><br><span class="line">        String urlPath = <span class="string">"apps/"</span> + info.getAppName();</span><br><span class="line">        ClientResponse response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过HTTP客户端发送http请求</span></span><br><span class="line">            Builder resourceBuilder = jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder();</span><br><span class="line">            addExtraHeaders(resourceBuilder);</span><br><span class="line">            <span class="comment">//构建响应结果</span></span><br><span class="line">            response = resourceBuilder</span><br><span class="line">                    .header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>)</span><br><span class="line">                    .type(MediaType.APPLICATION_JSON_TYPE)</span><br><span class="line">                    .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">                    .post(ClientResponse.class, info);</span><br><span class="line">            <span class="keyword">return</span> anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Jersey HTTP POST &#123;&#125;/&#123;&#125; with instance &#123;&#125;; statusCode=&#123;&#125;"</span>, serviceUrl, urlPath, info.getId(),</span><br><span class="line">                        response == <span class="keyword">null</span> ? <span class="string">"N/A"</span> : response.getStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>1.通过构建函数 可以看到传入一个jersey1 http 客户端</p><ol start="2"><li>register方法 实际是通过jersey1HttpClient发送http底层请求</li></ol></blockquote><blockquote><p>在这里可以看到AbstractJerseyEurekaHttpClient实际上是不做底层通讯的工作的，全部都是交由com.sun.jersey.api.client.Client处理的，这个是在创建工厂创建时设置到AbstractJerseyEurekaHttpClient中的</p></blockquote><blockquote><p><strong>备注:</strong> AbstractJersey2EurekaHttpClient与AbstractJerseyEurekaHttpClient的实现原理基本一样只是底层通讯的client不一致，后边不在描述</p></blockquote><h4 id="EurekaHttpClient-Top-Level部分"><a href="#EurekaHttpClient-Top-Level部分" class="headerlink" title="EurekaHttpClient Top Level部分"></a>EurekaHttpClient Top Level部分</h4><ul><li>EurekaHttpClientDecorator</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象Eureka远程通讯客户端装饰器，使用设计模式-装饰器模式 为客户端添加新的功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Tomasz Bak</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaHttpClientDecorator</span> <span class="keyword">implements</span> <span class="title">EurekaHttpClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> RequestType &#123;</span><br><span class="line">        <span class="comment">//注册</span></span><br><span class="line">        Register,</span><br><span class="line">        <span class="comment">//下线</span></span><br><span class="line">        Cancel,</span><br><span class="line">        <span class="comment">//心跳</span></span><br><span class="line">        SendHeartBeat,</span><br><span class="line">        <span class="comment">//状态更新</span></span><br><span class="line">        StatusUpdate,</span><br><span class="line">        DeleteStatusOverride,</span><br><span class="line">        GetApplications,</span><br><span class="line">        GetDelta,</span><br><span class="line">        GetVip,</span><br><span class="line">        GetSecureVip,</span><br><span class="line">        GetApplication,</span><br><span class="line">        GetInstance,</span><br><span class="line">        GetApplicationInstance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求执行接口，负责执行请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;R&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestExecutor</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行请求并返回响应信息</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> delegate 目标的客户端</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(EurekaHttpClient delegate)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 请求的类型</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">RequestType <span class="title">getRequestType</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象的执行方法，由子装饰器实现，附加其它功能</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestExecutor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;R&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;R&gt; <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个注册请求的执行器，并执行</span></span><br><span class="line">        <span class="keyword">return</span> execute(<span class="keyword">new</span> RequestExecutor&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">(EurekaHttpClient delegate)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> delegate.register(info);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> RequestType <span class="title">getRequestType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> RequestType.Register;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">cancel</span><span class="params">(<span class="keyword">final</span> String appName, <span class="keyword">final</span> String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个下线请求的执行，并执行</span></span><br><span class="line">        <span class="keyword">return</span> execute(<span class="keyword">new</span> RequestExecutor&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">(EurekaHttpClient delegate)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> delegate.cancel(appName, id);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> RequestType <span class="title">getRequestType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> RequestType.Cancel;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>基础的包装器 主要完成如下功能</p><ul><li>实现EurekaHttpClient接口每个基础方法，都有如下流程</li></ul><ol><li>创建一个请求执行接口</li><li>通过调用抽象的execute方法将RequestExecutor传入</li><li>子类在RequestExecutor执行前或后完成新功能的附加</li></ol></blockquote><ul><li>EurekaHttpClientDecorator实现</li></ul><table><thead><tr><th>实现类</th><th>描述</th></tr></thead><tbody><tr><td>MetricsCollectingEurekaHttpClient</td><td>实现请求响应状态指标采集的Eureka远程通讯客户端装饰器，为EurekaHttpClient添加响应状态指标采集向功能</td></tr><tr><td>RedirectingEurekaHttpClient</td><td>实现请求重定向的Eureka远程通讯客户端装饰器，为EurekaHttpClient添加请求重定向功能</td></tr><tr><td>RetryableEurekaHttpClient</td><td>实现请求失败重试的Eureka远程通讯客户端装饰器，为EurekaHttpClient添加失败重试功能</td></tr><tr><td>SessionedEurekaHttpClient</td><td>TODO</td></tr></tbody></table><hr><blockquote><p>从以上来看eureka 通讯模块结构和功能还是非常明了清晰，同时后期如果需要扩展，也是非常方便与快捷的</p></blockquote>]]></content>
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Eureka之REST API</title>
      <link href="/2018/08/23/Eureka%E4%B9%8BREST-API-1/"/>
      <url>/2018/08/23/Eureka%E4%B9%8BREST-API-1/</url>
      <content type="html"><![CDATA[<blockquote><p>Eureka服务端与客户之间的通讯方式为http，服务端通过提供rest API风格的接口与客户端或其它服务端交互。</p></blockquote><h4 id="交互数据格式"><a href="#交互数据格式" class="headerlink" title="交互数据格式"></a>交互数据格式</h4><blockquote><p>JSON/XML</p></blockquote><h4 id="提供资源服务的包路径"><a href="#提供资源服务的包路径" class="headerlink" title="提供资源服务的包路径"></a>提供资源服务的包路径</h4><blockquote><p><strong>com.netflix.eureka.resources</strong><br><a id="more"></a></p></blockquote><h4 id="提供可使用的REST-API接口"><a href="#提供可使用的REST-API接口" class="headerlink" title="提供可使用的REST API接口"></a>提供可使用的REST API接口</h4><blockquote><p><strong>/{version}/apps 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/apps.png?raw=true" alt="image"></p><blockquote><p><strong>/{version}/instances 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/rs.png?raw=true" alt="image"></p><blockquote><p><strong>/{version}/status 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/status.png?raw=true" alt="image"></p><blockquote><p><strong>/{version}/peerreplication 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/pree.png?raw=true" alt="image"></p><blockquote><p><strong>/{version}/vips 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/vip.png?raw=true" alt="image"></p><blockquote><p><strong>/{version}/svips 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/svip.png?raw=true" alt="image"></p>]]></content>
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Eureka之服务注册数据模型</title>
      <link href="/2018/08/23/Eureka%E4%B9%8B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/08/23/Eureka%E4%B9%8B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<blockquote><p>Eureka 作为注册中心，担任着服务节点的注册以及发现，并提供着动态的管理（坏点摘除，服务检测等）。可以说是整个系统的基础设施。</p></blockquote><ul><li>注册列表的数据模型</li></ul><p><img src="https://github.com/guofazhan/image/blob/master/eureka%E6%B3%A8%E5%86%8C%E5%88%97%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B.png?raw=true" alt="image"><br><a id="more"></a><br><strong>1. Applications</strong></p><blockquote><p>注册列表，包含注册到当前注册中心上的所有实例信息，每个注册中心在内存中保持一份数据。在Applications中持有Application的队列</p></blockquote><p><strong>2. Application</strong></p><blockquote><p>注册到注册中心的服务集群信息，Application可以看做为一组对外提供相同服务的集群列表。在Application包含一组提供相同服务的InstanceInfo集合</p></blockquote><p><strong>3. InstanceInfo</strong></p><blockquote><p>注册列表里的单个服务实例信息，代表系统中提供一项服务的某个节点，里面包含节点的基础信息，以及唯一标识instanceId。</p></blockquote><p><strong>4. DataCenterInfo</strong></p><blockquote><p>服务实例所在的数据中心，默认为MyOwn，为InstanceInfo子属性</p></blockquote><p><strong>5. LeaseInfo</strong></p><blockquote><p>服务实例的租约信息，用于对服务做健康检查，续租，过期等服务可用性的管理。为InstanceInfo子属性</p></blockquote><hr><p>通过数据模型图可以清楚的看到Eureka将我们系统中的服务信息抽象成5个对象进行精细化的管理。我们注册进去的服务信息都将实例化成上述对象存储在eureka的服务端内存中，从而对外提供服务的注册以及发现。</p>]]></content>
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Eureka之server端集群节点发现，数据同步</title>
      <link href="/2018/08/23/Eureka%E4%B9%8Bserver%E7%AB%AF%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E5%8F%91%E7%8E%B0%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5-1/"/>
      <url>/2018/08/23/Eureka%E4%B9%8Bserver%E7%AB%AF%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E5%8F%91%E7%8E%B0%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5-1/</url>
      <content type="html"><![CDATA[<blockquote><p>Eureka服务端支持集群部署，通过源码查看集群节点发现以及数据同步功能的实现</p></blockquote><h4 id="提供集群功能的包路径"><a href="#提供集群功能的包路径" class="headerlink" title="提供集群功能的包路径"></a>提供集群功能的包路径</h4><blockquote><p>com.netflix.eureka.cluster</p></blockquote><h4 id="集群节点发现以及动态更新节点功能"><a href="#集群节点发现以及动态更新节点功能" class="headerlink" title="集群节点发现以及动态更新节点功能"></a>集群节点发现以及动态更新节点功能</h4><blockquote><p>Eureka服务端封装了一个集群节点管理的类名称为PeerEurekaNodes 通过名称翻译出来为对等的Eureka节点集合，可以看出这个类是对eureka服务端集群节点抽象，下面通过源码查询eureka是怎么管理与发现节点信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * eureka server 集群节点 集合类 帮助管理维护集群节点</span></span><br><span class="line"><span class="comment"> * Helper class to manage lifecycle of a collection of &#123;<span class="doctag">@link</span> PeerEurekaNode&#125;s.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Tomasz Bak</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeerEurekaNodes</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集群节点集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;PeerEurekaNode&gt; peerEurekaNodes = Collections.emptyList();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集群节点URL集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;String&gt; peerEurekaNodeUrls = Collections.emptySet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时任务线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ScheduledExecutorService taskExecutor;</span><br></pre></td></tr></table></figure><blockquote><p>通过PeerEurekaNodes类属性可以看到提供了两个集合以及一个执行定时任务的线程池，其它配置属性忽略</p><ol><li>peerEurekaNodes 表示集群节点集合</li><li>peerEurekaNodeUrls 表示集群节点对应的URL集合</li><li>taskExecutor 执行定时任务的线程池<a id="more"></a>同时 PeerEurekaNodes 类提供start 与shutdown方法，接下来主要看start方法的实现</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动方法，此方法管理集群节点间的通讯</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化定时任务线程池</span></span><br><span class="line">        taskExecutor = Executors.newSingleThreadScheduledExecutor(</span><br><span class="line">                <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                        Thread thread = <span class="keyword">new</span> Thread(r, <span class="string">"Eureka-PeerNodesUpdater"</span>);</span><br><span class="line">                        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> thread;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            updatePeerEurekaNodes(resolvePeerUrls());</span><br><span class="line">            <span class="comment">//节点更新任务线程</span></span><br><span class="line">            Runnable peersUpdateTask = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        updatePeerEurekaNodes(resolvePeerUrls());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        logger.error(<span class="string">"Cannot update the replica Nodes"</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。</span></span><br><span class="line"><span class="comment">//            如果任务的任一执行遇到异常，就会取消后续执行。否则，只能通过执行程序的取消或终止方法来终止该任务。</span></span><br><span class="line"><span class="comment">//            参数：</span></span><br><span class="line"><span class="comment">//            command - 要执行的任务</span></span><br><span class="line"><span class="comment">//            initialdelay - 首次执行的延迟时间</span></span><br><span class="line"><span class="comment">//            delay - 一次执行终止和下一次执行开始之间的延迟</span></span><br><span class="line"><span class="comment">//            unit - initialdelay 和 delay 参数的时间单位</span></span><br><span class="line">            <span class="comment">//定时执行节点更新任务线程</span></span><br><span class="line">            taskExecutor.scheduleWithFixedDelay(</span><br><span class="line">                    peersUpdateTask,</span><br><span class="line">                    serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</span><br><span class="line">                    serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</span><br><span class="line">                    TimeUnit.MILLISECONDS</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (PeerEurekaNode node : peerEurekaNodes) &#123;</span><br><span class="line">            logger.info(<span class="string">"Replica node URL:  "</span> + node.getServiceUrl());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>start 方法主要完成以下几件事</p><ol><li>初始化定时任务线程池</li><li>首次更新集群节点 updatePeerEurekaNodes方法</li><li>创建更新集群节点任务线程</li><li>通过定时任务线程池定时执行更新集群节点线程</li></ol></blockquote><blockquote><p>通过start 可以看出 eureka是通过一个定时线程定时去更新集群的节点信息达到对集群节点的动态发现和感知，在上面我们可以看到更新操作主要由updatePeerEurekaNodes方法完成，下面查看此方法的实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updatePeerEurekaNodes</span><span class="params">(List&lt;String&gt; newPeerUrls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newPeerUrls.isEmpty()) &#123;</span><br><span class="line">        logger.warn(<span class="string">"The replica size seems to be empty. Check the route 53 DNS Registry"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; toShutdown = <span class="keyword">new</span> HashSet&lt;&gt;(peerEurekaNodeUrls);</span><br><span class="line">    toShutdown.removeAll(newPeerUrls);</span><br><span class="line">    Set&lt;String&gt; toAdd = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</span><br><span class="line">    toAdd.removeAll(peerEurekaNodeUrls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验新的URL集合与旧有的URL集合是否一致，一致，不需要更新直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (toShutdown.isEmpty() &amp;&amp; toAdd.isEmpty()) &#123; <span class="comment">// No change</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove peers no long available</span></span><br><span class="line">    List&lt;PeerEurekaNode&gt; newNodeList = <span class="keyword">new</span> ArrayList&lt;&gt;(peerEurekaNodes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除旧集合中不可用的节点信息</span></span><br><span class="line">    <span class="keyword">if</span> (!toShutdown.isEmpty()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Removing no longer available peer nodes &#123;&#125;"</span>, toShutdown);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; newNodeList.size()) &#123;</span><br><span class="line">            PeerEurekaNode eurekaNode = newNodeList.get(i);</span><br><span class="line">            <span class="keyword">if</span> (toShutdown.contains(eurekaNode.getServiceUrl())) &#123;</span><br><span class="line">                newNodeList.remove(i);</span><br><span class="line">                eurekaNode.shutDown();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加新增加的节点信息</span></span><br><span class="line">    <span class="comment">// Add new peers</span></span><br><span class="line">    <span class="keyword">if</span> (!toAdd.isEmpty()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Adding new peer nodes &#123;&#125;"</span>, toAdd);</span><br><span class="line">        <span class="keyword">for</span> (String peerUrl : toAdd) &#123;</span><br><span class="line">            newNodeList.add(createPeerEurekaNode(peerUrl));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新赋值peerEurekaNodes与peerEurekaNodeUrls</span></span><br><span class="line">    <span class="keyword">this</span>.peerEurekaNodes = newNodeList;</span><br><span class="line">    <span class="keyword">this</span>.peerEurekaNodeUrls = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>updatePeerEurekaNodes根据传入的新集群URL集合完成节点的更新</p><ol><li>校验传入的URL集合是否需要更新</li><li>移除新url集合中没有的旧节点并关闭节点</li><li>创建旧节点集合中没有的新URL节点通过createPeerEurekaNode方法</li><li>重新赋值节点集合以及URL集合完成节点的更新</li></ol></blockquote><blockquote><p>updatePeerEurekaNodes传入的新URL集合是通过resolvePeerUrls方法获取，这个方法实际上是解析配置文件中的eureka.serviceUrl前缀的配置获取，并动态监听配置的更新。 创建新的节点是通过createPeerEurekaNode创建，下面查看此方法源码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据URL创建server新节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> peerEurekaNodeUrl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> PeerEurekaNode <span class="title">createPeerEurekaNode</span><span class="params">(String peerEurekaNodeUrl)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个连接远程节点的客户端</span></span><br><span class="line">    HttpReplicationClient replicationClient = JerseyReplicationClient.createReplicationClient(serverConfig, serverCodecs, peerEurekaNodeUrl);</span><br><span class="line">    <span class="comment">//获取新节点host信息</span></span><br><span class="line">    String targetHost = hostFromUrl(peerEurekaNodeUrl);</span><br><span class="line">    <span class="keyword">if</span> (targetHost == <span class="keyword">null</span>) &#123;</span><br><span class="line">        targetHost = <span class="string">"host"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建新节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PeerEurekaNode(registry, targetHost, peerEurekaNodeUrl, replicationClient, serverConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PeerEurekaNode 方法 </p><ol><li>创建远程通讯客户端replicationClient 用户与此节点间通讯，数据同步等工作</li><li>获取要创建的远程节点的host</li><li>创建一个表示远程节点实例 PeerEurekaNode</li></ol></blockquote><blockquote><p>PeerEurekaNode 表示一个与当前节点对等的远程节点，当前节点与远程节点的数据同步工作都是在此实例中完成的。</p></blockquote><h4 id="集群节点数据同步"><a href="#集群节点数据同步" class="headerlink" title="集群节点数据同步"></a>集群节点数据同步</h4><blockquote><p>在上面节点发现中知道eureka是通过PeerEurekaNode表示远程对等接点，并将远程通讯客户端replicationClient传入到PeerEurekaNode中，接下来通过查看PeerEurekaNode源码来看eureka集群节点间都有那些数据需要同步以及通讯内容</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* For testing */</span> PeerEurekaNode(PeerAwareInstanceRegistry registry, String targetHost, String serviceUrl,</span><br><span class="line">                                 HttpReplicationClient replicationClient, EurekaServerConfig config,</span><br><span class="line">                                 <span class="keyword">int</span> batchSize, <span class="keyword">long</span> maxBatchingDelayMs,</span><br><span class="line">                                 <span class="keyword">long</span> retrySleepTimeMs, <span class="keyword">long</span> serverUnavailableSleepTimeMs) &#123;</span><br><span class="line">    String batcherName = getBatcherName();</span><br><span class="line">    <span class="comment">//任务处理器</span></span><br><span class="line">    ReplicationTaskProcessor taskProcessor = <span class="keyword">new</span> ReplicationTaskProcessor(targetHost, replicationClient);</span><br><span class="line">    <span class="comment">//创建一个批量执行的任务调度器</span></span><br><span class="line">    <span class="keyword">this</span>.batchingDispatcher = TaskDispatchers.createBatchingTaskDispatcher(</span><br><span class="line">            batcherName,</span><br><span class="line">            config.getMaxElementsInPeerReplicationPool(),</span><br><span class="line">            batchSize,</span><br><span class="line">            config.getMaxThreadsForPeerReplication(),</span><br><span class="line">            maxBatchingDelayMs,</span><br><span class="line">            serverUnavailableSleepTimeMs,</span><br><span class="line">            retrySleepTimeMs,</span><br><span class="line">            taskProcessor</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//创建一个单任务调度器</span></span><br><span class="line">    <span class="keyword">this</span>.nonBatchingDispatcher = TaskDispatchers.createNonBatchingTaskDispatcher(</span><br><span class="line">            targetHost,</span><br><span class="line">            config.getMaxElementsInStatusReplicationPool(),</span><br><span class="line">            config.getMaxThreadsForStatusReplication(),</span><br><span class="line">            maxBatchingDelayMs,</span><br><span class="line">            serverUnavailableSleepTimeMs,</span><br><span class="line">            retrySleepTimeMs,</span><br><span class="line">            taskProcessor</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PeerEurekaNode 完成以下事件</p><ol><li>创建数据同步的任务处理器ReplicationTaskProcessor</li><li>创建批处理任务调度器</li><li>创建单任务处理调度器</li></ol></blockquote><blockquote><p><strong>说明:</strong>  eureka将节点间的数据同步工作包装成一个个细微的任务ReplicationTask ，每一个数据操作代表一个任务，将任务发送给任务调度器TaskDispatcher去异步处理。</p></blockquote><blockquote><p>下来查看PeerEurekaNode都可以创建那些同步任务</p><ul><li>register</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当eureka server注册新服务时，同时创建一个定时任务将新服务同步到集群其它节点</span></span><br><span class="line"><span class="comment"> * Sends the registration information of &#123;<span class="doctag">@link</span> InstanceInfo&#125; receiving by</span></span><br><span class="line"><span class="comment"> * this node to the peer node represented by this class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> info</span></span><br><span class="line"><span class="comment"> *            the instance information &#123;<span class="doctag">@link</span> InstanceInfo&#125; of any instance</span></span><br><span class="line"><span class="comment"> *            that is send to this instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info);</span><br><span class="line">    <span class="comment">//任务调度器中添加一个请求类型为注册register新服务的同步任务</span></span><br><span class="line">    batchingDispatcher.process(</span><br><span class="line">            taskId(<span class="string">"register"</span>, info),</span><br><span class="line">            <span class="keyword">new</span> InstanceReplicationTask(targetHost, Action.Register, info, <span class="keyword">null</span>, <span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> replicationClient.register(info);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            expiryTime</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注册同步任务，当有服务注册到当前节点时，通过注册同步任务将服务信息同步到集群远程节点</p></blockquote><ul><li>cancel</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">(<span class="keyword">final</span> String appName, <span class="keyword">final</span> String id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> expiryTime = System.currentTimeMillis() + maxProcessingDelayMs;</span><br><span class="line">     <span class="comment">//任务调度器中添加一个请求类型为取消cancel服务的同步任务</span></span><br><span class="line">     batchingDispatcher.process(</span><br><span class="line">             taskId(<span class="string">"cancel"</span>, appName, id),</span><br><span class="line">             <span class="keyword">new</span> InstanceReplicationTask(targetHost, Action.Cancel, appName, id) &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                     <span class="keyword">return</span> replicationClient.cancel(appName, id);</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleFailure</span><span class="params">(<span class="keyword">int</span> statusCode, Object responseEntity)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                     <span class="keyword">super</span>.handleFailure(statusCode, responseEntity);</span><br><span class="line">                     <span class="keyword">if</span> (statusCode == <span class="number">404</span>) &#123;</span><br><span class="line">                         logger.warn(<span class="string">"&#123;&#125;: missing entry."</span>, getTaskName());</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;,</span><br><span class="line">             expiryTime</span><br><span class="line">     );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>取消服务注册任务，当前节点有服务取消注册，将信息同步到集群远程节点</p><ul><li>heartbeat</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public void heartbeat(final String appName, final String id,</span><br><span class="line">                      final InstanceInfo info, final InstanceStatus overriddenStatus,</span><br><span class="line">                      boolean primeConnection) throws Throwable &#123;</span><br><span class="line">    //当第一次连接时直接发送心跳到远端</span><br><span class="line">    if (primeConnection) &#123;</span><br><span class="line">        // We do not care about the result for priming request.</span><br><span class="line">        replicationClient.sendHeartBeat(appName, id, info, overriddenStatus);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //心跳同步任务</span><br><span class="line">    ReplicationTask replicationTask = new InstanceReplicationTask(targetHost, Action.Heartbeat, info, overriddenStatus, false) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public EurekaHttpResponse&lt;InstanceInfo&gt; execute() throws Throwable &#123;</span><br><span class="line">            return replicationClient.sendHeartBeat(appName, id, info, overriddenStatus);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleFailure(int statusCode, Object responseEntity) throws Throwable &#123;</span><br><span class="line">            super.handleFailure(statusCode, responseEntity);</span><br><span class="line">            if (statusCode == 404) &#123;</span><br><span class="line">                logger.warn(&quot;&#123;&#125;: missing entry.&quot;, getTaskName());</span><br><span class="line">                if (info != null) &#123;</span><br><span class="line">                    logger.warn(&quot;&#123;&#125;: cannot find instance id &#123;&#125; and hence replicating the instance with status &#123;&#125;&quot;,</span><br><span class="line">                            getTaskName(), info.getId(), info.getStatus());</span><br><span class="line">                    register(info);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (config.shouldSyncWhenTimestampDiffers()) &#123;</span><br><span class="line">                InstanceInfo peerInstanceInfo = (InstanceInfo) responseEntity;</span><br><span class="line">                if (peerInstanceInfo != null) &#123;</span><br><span class="line">                    syncInstancesIfTimestampDiffers(appName, id, info, peerInstanceInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    long expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info);</span><br><span class="line">    //任务调度器中添加一个请求类型为heartbeat服务的同步任务</span><br><span class="line">    batchingDispatcher.process(taskId(&quot;heartbeat&quot;, info), replicationTask, expiryTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>心跳同步任务，当前节点有服务发送心跳续租，将信息同步到集群远程节点</p><ul><li>StatusUpdate </li><li>DeleteStatusOverride</li></ul></blockquote><h4 id="集群节点数据同步任务处理"><a href="#集群节点数据同步任务处理" class="headerlink" title="集群节点数据同步任务处理"></a>集群节点数据同步任务处理</h4><blockquote><p>在PeerEurekaNode的构造函数中可以看到同步任务处理由ReplicationTaskProcessor完成，下面看此类源码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 单个处理ReplicationTask任务</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ProcessingResult <span class="title">process</span><span class="params">(ReplicationTask task)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//调用任务execute方法，完成任务的执行</span></span><br><span class="line">           EurekaHttpResponse&lt;?&gt; httpResponse = task.execute();</span><br><span class="line">           <span class="keyword">int</span> statusCode = httpResponse.getStatusCode();</span><br><span class="line">           <span class="comment">//判断任务返回结果</span></span><br><span class="line">           Object entity = httpResponse.getEntity();</span><br><span class="line">           <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">               logger.debug(<span class="string">"Replication task &#123;&#125; completed with status &#123;&#125;, (includes entity &#123;&#125;)"</span>, task.getTaskName(), statusCode, entity != <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (isSuccess(statusCode)) &#123;</span><br><span class="line">               task.handleSuccess();</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusCode == <span class="number">503</span>) &#123;</span><br><span class="line">               logger.debug(<span class="string">"Server busy (503) reply for task &#123;&#125;"</span>, task.getTaskName());</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.Congestion;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               task.handleFailure(statusCode, entity);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.PermanentError;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           <span class="keyword">if</span> (isNetworkConnectException(e)) &#123;</span><br><span class="line">               logNetworkErrorSample(task, e);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.TransientError;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               logger.error(peerId + <span class="string">": "</span> + task.getTaskName() + <span class="string">"Not re-trying this exception because it does not seem to be a network exception"</span>, e);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.PermanentError;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ProcessingResult.Success;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>单任务处理 </p><ol><li>调用任务task的execute完成远程数据同步</li><li>分析远程返回结果</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 批量处理ReplicationTask任务</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> tasks</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ProcessingResult <span class="title">process</span><span class="params">(List&lt;ReplicationTask&gt; tasks)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//根据task集合创建ReplicationList</span></span><br><span class="line">       ReplicationList list = createReplicationListOf(tasks);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//调用批量同步接口 将同步集合发送到远端节点同步数据</span></span><br><span class="line">           EurekaHttpResponse&lt;ReplicationListResponse&gt; response = replicationClient.submitBatchUpdates(list);</span><br><span class="line">           <span class="comment">//判断同步返回结果</span></span><br><span class="line">           <span class="keyword">int</span> statusCode = response.getStatusCode();</span><br><span class="line">           <span class="keyword">if</span> (!isSuccess(statusCode)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (statusCode == <span class="number">503</span>) &#123;</span><br><span class="line">                   logger.warn(<span class="string">"Server busy (503) HTTP status code received from the peer &#123;&#125;; rescheduling tasks after delay"</span>, peerId);</span><br><span class="line">                   <span class="keyword">return</span> ProcessingResult.Congestion;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// Unexpected error returned from the server. This should ideally never happen.</span></span><br><span class="line">                   logger.error(<span class="string">"Batch update failure with HTTP status code &#123;&#125;; discarding &#123;&#125; replication tasks"</span>, statusCode, tasks.size());</span><br><span class="line">                   <span class="keyword">return</span> ProcessingResult.PermanentError;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               handleBatchResponse(tasks, response.getEntity().getResponseList());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           <span class="keyword">if</span> (isNetworkConnectException(e)) &#123;</span><br><span class="line">               logNetworkErrorSample(<span class="keyword">null</span>, e);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.TransientError;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               logger.error(<span class="string">"Not re-trying this exception because it does not seem to be a network exception"</span>, e);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.PermanentError;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ProcessingResult.Success;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>批处理任务，将一组任务一次性发送到远程进行处理</p><ol><li>根据task集合创建ReplicationList</li><li>调用批量同步接口将同步集合发送到远端节点同步数据 即调用rest API /{version}/peerreplication</li><li>分析远程返回结果</li></ol></blockquote><hr><blockquote><p><strong>eureka 服务端 集群节点发现，数据同步功能主要是由PeerEurekaNodes与PeerEurekaNode类实现,通过源码的跟踪可以清晰看出集群实现的逻辑，方便在实际应用中对问题的定位</strong></p></blockquote>]]></content>
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/08/23/hello-world/"/>
      <url>/2018/08/23/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
