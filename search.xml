<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Eureka之REST API</title>
      <link href="/2018/08/23/Eureka%E4%B9%8BREST-API-1/"/>
      <url>/2018/08/23/Eureka%E4%B9%8BREST-API-1/</url>
      <content type="html"><![CDATA[<blockquote><p>Eureka服务端与客户之间的通讯方式为http，服务端通过提供rest API风格的接口与客户端或其它服务端交互。</p></blockquote><h4 id="交互数据格式"><a href="#交互数据格式" class="headerlink" title="交互数据格式"></a>交互数据格式</h4><blockquote><p>JSON/XML</p></blockquote><h4 id="提供资源服务的包路径"><a href="#提供资源服务的包路径" class="headerlink" title="提供资源服务的包路径"></a>提供资源服务的包路径</h4><blockquote><p><strong>com.netflix.eureka.resources</strong></p></blockquote><h4 id="提供可使用的REST-API接口"><a href="#提供可使用的REST-API接口" class="headerlink" title="提供可使用的REST API接口"></a>提供可使用的REST API接口</h4><blockquote><p><strong>/{version}/apps 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/apps.png?raw=true" alt="image"></p><blockquote><p><strong>/{version}/instances 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/rs.png?raw=true" alt="image"></p><blockquote><p><strong>/{version}/status 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/status.png?raw=true" alt="image"></p><blockquote><p><strong>/{version}/peerreplication 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/pree.png?raw=true" alt="image"></p><blockquote><p><strong>/{version}/vips 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/vip.png?raw=true" alt="image"></p><blockquote><p><strong>/{version}/svips 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/svip.png?raw=true" alt="image"></p>]]></content>
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Eureka之服务注册数据模型</title>
      <link href="/2018/08/23/Eureka%E4%B9%8B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/08/23/Eureka%E4%B9%8B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<blockquote><p>Eureka 作为注册中心，担任着服务节点的注册以及发现，并提供着动态的管理（坏点摘除，服务检测等）。可以说是整个系统的基础设施。</p></blockquote><ul><li>注册列表的数据模型</li></ul><p><img src="https://github.com/guofazhan/image/blob/master/eureka%E6%B3%A8%E5%86%8C%E5%88%97%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B.png?raw=true" alt="image"></p><p><strong>1. Applications</strong></p><blockquote><p>注册列表，包含注册到当前注册中心上的所有实例信息，每个注册中心在内存中保持一份数据。在Applications中持有Application的队列</p></blockquote><p><strong>2. Application</strong></p><blockquote><p>注册到注册中心的服务集群信息，Application可以看做为一组对外提供相同服务的集群列表。在Application包含一组提供相同服务的InstanceInfo集合</p></blockquote><p><strong>3. InstanceInfo</strong></p><blockquote><p>注册列表里的单个服务实例信息，代表系统中提供一项服务的某个节点，里面包含节点的基础信息，以及唯一标识instanceId。</p></blockquote><p><strong>4. DataCenterInfo</strong></p><blockquote><p>服务实例所在的数据中心，默认为MyOwn，为InstanceInfo子属性</p></blockquote><p><strong>5. LeaseInfo</strong></p><blockquote><p>服务实例的租约信息，用于对服务做健康检查，续租，过期等服务可用性的管理。为InstanceInfo子属性</p></blockquote><hr><p>通过数据模型图可以清楚的看到Eureka将我们系统中的服务信息抽象成5个对象进行精细化的管理。我们注册进去的服务信息都将实例化成上述对象存储在eureka的服务端内存中，从而对外提供服务的注册以及发现。</p>]]></content>
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Eureka之server端集群节点发现，数据同步</title>
      <link href="/2018/08/23/Eureka%E4%B9%8Bserver%E7%AB%AF%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E5%8F%91%E7%8E%B0%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5-1/"/>
      <url>/2018/08/23/Eureka%E4%B9%8Bserver%E7%AB%AF%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E5%8F%91%E7%8E%B0%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5-1/</url>
      <content type="html"><![CDATA[<blockquote><p>Eureka服务端支持集群部署，通过源码查看集群节点发现以及数据同步功能的实现</p></blockquote><h4 id="提供集群功能的包路径"><a href="#提供集群功能的包路径" class="headerlink" title="提供集群功能的包路径"></a>提供集群功能的包路径</h4><blockquote><p>com.netflix.eureka.cluster</p></blockquote><h4 id="集群节点发现以及动态更新节点功能"><a href="#集群节点发现以及动态更新节点功能" class="headerlink" title="集群节点发现以及动态更新节点功能"></a>集群节点发现以及动态更新节点功能</h4><blockquote><p>Eureka服务端封装了一个集群节点管理的类名称为PeerEurekaNodes 通过名称翻译出来为对等的Eureka节点集合，可以看出这个类是对eureka服务端集群节点抽象，下面通过源码查询eureka是怎么管理与发现节点信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * eureka server 集群节点 集合类 帮助管理维护集群节点</span></span><br><span class="line"><span class="comment"> * Helper class to manage lifecycle of a collection of &#123;<span class="doctag">@link</span> PeerEurekaNode&#125;s.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Tomasz Bak</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeerEurekaNodes</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集群节点集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;PeerEurekaNode&gt; peerEurekaNodes = Collections.emptyList();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集群节点URL集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;String&gt; peerEurekaNodeUrls = Collections.emptySet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时任务线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ScheduledExecutorService taskExecutor;</span><br></pre></td></tr></table></figure><blockquote><p>通过PeerEurekaNodes类属性可以看到提供了两个集合以及一个执行定时任务的线程池，其它配置属性忽略</p><ol><li>peerEurekaNodes 表示集群节点集合</li><li>peerEurekaNodeUrls 表示集群节点对应的URL集合</li><li>taskExecutor 执行定时任务的线程池</li></ol></blockquote><blockquote><p>同时 PeerEurekaNodes 类提供start 与shutdown方法，接下来主要看start方法的实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动方法，此方法管理集群节点间的通讯</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化定时任务线程池</span></span><br><span class="line">        taskExecutor = Executors.newSingleThreadScheduledExecutor(</span><br><span class="line">                <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                        Thread thread = <span class="keyword">new</span> Thread(r, <span class="string">"Eureka-PeerNodesUpdater"</span>);</span><br><span class="line">                        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> thread;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            updatePeerEurekaNodes(resolvePeerUrls());</span><br><span class="line">            <span class="comment">//节点更新任务线程</span></span><br><span class="line">            Runnable peersUpdateTask = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        updatePeerEurekaNodes(resolvePeerUrls());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        logger.error(<span class="string">"Cannot update the replica Nodes"</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。</span></span><br><span class="line"><span class="comment">//            如果任务的任一执行遇到异常，就会取消后续执行。否则，只能通过执行程序的取消或终止方法来终止该任务。</span></span><br><span class="line"><span class="comment">//            参数：</span></span><br><span class="line"><span class="comment">//            command - 要执行的任务</span></span><br><span class="line"><span class="comment">//            initialdelay - 首次执行的延迟时间</span></span><br><span class="line"><span class="comment">//            delay - 一次执行终止和下一次执行开始之间的延迟</span></span><br><span class="line"><span class="comment">//            unit - initialdelay 和 delay 参数的时间单位</span></span><br><span class="line">            <span class="comment">//定时执行节点更新任务线程</span></span><br><span class="line">            taskExecutor.scheduleWithFixedDelay(</span><br><span class="line">                    peersUpdateTask,</span><br><span class="line">                    serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</span><br><span class="line">                    serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</span><br><span class="line">                    TimeUnit.MILLISECONDS</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (PeerEurekaNode node : peerEurekaNodes) &#123;</span><br><span class="line">            logger.info(<span class="string">"Replica node URL:  "</span> + node.getServiceUrl());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>start 方法主要完成以下几件事</p><ol><li>初始化定时任务线程池</li><li>首次更新集群节点 updatePeerEurekaNodes方法</li><li>创建更新集群节点任务线程</li><li>通过定时任务线程池定时执行更新集群节点线程</li></ol></blockquote><blockquote><p>通过start 可以看出 eureka是通过一个定时线程定时去更新集群的节点信息达到对集群节点的动态发现和感知，在上面我们可以看到更新操作主要由updatePeerEurekaNodes方法完成，下面查看此方法的实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updatePeerEurekaNodes</span><span class="params">(List&lt;String&gt; newPeerUrls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newPeerUrls.isEmpty()) &#123;</span><br><span class="line">        logger.warn(<span class="string">"The replica size seems to be empty. Check the route 53 DNS Registry"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; toShutdown = <span class="keyword">new</span> HashSet&lt;&gt;(peerEurekaNodeUrls);</span><br><span class="line">    toShutdown.removeAll(newPeerUrls);</span><br><span class="line">    Set&lt;String&gt; toAdd = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</span><br><span class="line">    toAdd.removeAll(peerEurekaNodeUrls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验新的URL集合与旧有的URL集合是否一致，一致，不需要更新直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (toShutdown.isEmpty() &amp;&amp; toAdd.isEmpty()) &#123; <span class="comment">// No change</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove peers no long available</span></span><br><span class="line">    List&lt;PeerEurekaNode&gt; newNodeList = <span class="keyword">new</span> ArrayList&lt;&gt;(peerEurekaNodes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除旧集合中不可用的节点信息</span></span><br><span class="line">    <span class="keyword">if</span> (!toShutdown.isEmpty()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Removing no longer available peer nodes &#123;&#125;"</span>, toShutdown);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; newNodeList.size()) &#123;</span><br><span class="line">            PeerEurekaNode eurekaNode = newNodeList.get(i);</span><br><span class="line">            <span class="keyword">if</span> (toShutdown.contains(eurekaNode.getServiceUrl())) &#123;</span><br><span class="line">                newNodeList.remove(i);</span><br><span class="line">                eurekaNode.shutDown();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加新增加的节点信息</span></span><br><span class="line">    <span class="comment">// Add new peers</span></span><br><span class="line">    <span class="keyword">if</span> (!toAdd.isEmpty()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Adding new peer nodes &#123;&#125;"</span>, toAdd);</span><br><span class="line">        <span class="keyword">for</span> (String peerUrl : toAdd) &#123;</span><br><span class="line">            newNodeList.add(createPeerEurekaNode(peerUrl));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新赋值peerEurekaNodes与peerEurekaNodeUrls</span></span><br><span class="line">    <span class="keyword">this</span>.peerEurekaNodes = newNodeList;</span><br><span class="line">    <span class="keyword">this</span>.peerEurekaNodeUrls = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>updatePeerEurekaNodes根据传入的新集群URL集合完成节点的更新</p><ol><li>校验传入的URL集合是否需要更新</li><li>移除新url集合中没有的旧节点并关闭节点</li><li>创建旧节点集合中没有的新URL节点通过createPeerEurekaNode方法</li><li>重新赋值节点集合以及URL集合完成节点的更新</li></ol></blockquote><blockquote><p>updatePeerEurekaNodes传入的新URL集合是通过resolvePeerUrls方法获取，这个方法实际上是解析配置文件中的eureka.serviceUrl前缀的配置获取，并动态监听配置的更新。 创建新的节点是通过createPeerEurekaNode创建，下面查看此方法源码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据URL创建server新节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> peerEurekaNodeUrl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> PeerEurekaNode <span class="title">createPeerEurekaNode</span><span class="params">(String peerEurekaNodeUrl)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个连接远程节点的客户端</span></span><br><span class="line">    HttpReplicationClient replicationClient = JerseyReplicationClient.createReplicationClient(serverConfig, serverCodecs, peerEurekaNodeUrl);</span><br><span class="line">    <span class="comment">//获取新节点host信息</span></span><br><span class="line">    String targetHost = hostFromUrl(peerEurekaNodeUrl);</span><br><span class="line">    <span class="keyword">if</span> (targetHost == <span class="keyword">null</span>) &#123;</span><br><span class="line">        targetHost = <span class="string">"host"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建新节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PeerEurekaNode(registry, targetHost, peerEurekaNodeUrl, replicationClient, serverConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PeerEurekaNode 方法 </p><ol><li>创建远程通讯客户端replicationClient 用户与此节点间通讯，数据同步等工作</li><li>获取要创建的远程节点的host</li><li>创建一个表示远程节点实例 PeerEurekaNode</li></ol></blockquote><blockquote><p>PeerEurekaNode 表示一个与当前节点对等的远程节点，当前节点与远程节点的数据同步工作都是在此实例中完成的。</p></blockquote><h4 id="集群节点数据同步"><a href="#集群节点数据同步" class="headerlink" title="集群节点数据同步"></a>集群节点数据同步</h4><blockquote><p>在上面节点发现中知道eureka是通过PeerEurekaNode表示远程对等接点，并将远程通讯客户端replicationClient传入到PeerEurekaNode中，接下来通过查看PeerEurekaNode源码来看eureka集群节点间都有那些数据需要同步以及通讯内容</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* For testing */</span> PeerEurekaNode(PeerAwareInstanceRegistry registry, String targetHost, String serviceUrl,</span><br><span class="line">                                 HttpReplicationClient replicationClient, EurekaServerConfig config,</span><br><span class="line">                                 <span class="keyword">int</span> batchSize, <span class="keyword">long</span> maxBatchingDelayMs,</span><br><span class="line">                                 <span class="keyword">long</span> retrySleepTimeMs, <span class="keyword">long</span> serverUnavailableSleepTimeMs) &#123;</span><br><span class="line">    String batcherName = getBatcherName();</span><br><span class="line">    <span class="comment">//任务处理器</span></span><br><span class="line">    ReplicationTaskProcessor taskProcessor = <span class="keyword">new</span> ReplicationTaskProcessor(targetHost, replicationClient);</span><br><span class="line">    <span class="comment">//创建一个批量执行的任务调度器</span></span><br><span class="line">    <span class="keyword">this</span>.batchingDispatcher = TaskDispatchers.createBatchingTaskDispatcher(</span><br><span class="line">            batcherName,</span><br><span class="line">            config.getMaxElementsInPeerReplicationPool(),</span><br><span class="line">            batchSize,</span><br><span class="line">            config.getMaxThreadsForPeerReplication(),</span><br><span class="line">            maxBatchingDelayMs,</span><br><span class="line">            serverUnavailableSleepTimeMs,</span><br><span class="line">            retrySleepTimeMs,</span><br><span class="line">            taskProcessor</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//创建一个单任务调度器</span></span><br><span class="line">    <span class="keyword">this</span>.nonBatchingDispatcher = TaskDispatchers.createNonBatchingTaskDispatcher(</span><br><span class="line">            targetHost,</span><br><span class="line">            config.getMaxElementsInStatusReplicationPool(),</span><br><span class="line">            config.getMaxThreadsForStatusReplication(),</span><br><span class="line">            maxBatchingDelayMs,</span><br><span class="line">            serverUnavailableSleepTimeMs,</span><br><span class="line">            retrySleepTimeMs,</span><br><span class="line">            taskProcessor</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PeerEurekaNode 完成以下事件</p><ol><li>创建数据同步的任务处理器ReplicationTaskProcessor</li><li>创建批处理任务调度器</li><li>创建单任务处理调度器</li></ol></blockquote><blockquote><p><strong>说明:</strong>  eureka将节点间的数据同步工作包装成一个个细微的任务ReplicationTask ，每一个数据操作代表一个任务，将任务发送给任务调度器TaskDispatcher去异步处理。</p></blockquote><blockquote><p>下来查看PeerEurekaNode都可以创建那些同步任务</p><ul><li>register</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当eureka server注册新服务时，同时创建一个定时任务将新服务同步到集群其它节点</span></span><br><span class="line"><span class="comment"> * Sends the registration information of &#123;<span class="doctag">@link</span> InstanceInfo&#125; receiving by</span></span><br><span class="line"><span class="comment"> * this node to the peer node represented by this class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> info</span></span><br><span class="line"><span class="comment"> *            the instance information &#123;<span class="doctag">@link</span> InstanceInfo&#125; of any instance</span></span><br><span class="line"><span class="comment"> *            that is send to this instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info);</span><br><span class="line">    <span class="comment">//任务调度器中添加一个请求类型为注册register新服务的同步任务</span></span><br><span class="line">    batchingDispatcher.process(</span><br><span class="line">            taskId(<span class="string">"register"</span>, info),</span><br><span class="line">            <span class="keyword">new</span> InstanceReplicationTask(targetHost, Action.Register, info, <span class="keyword">null</span>, <span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> replicationClient.register(info);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            expiryTime</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注册同步任务，当有服务注册到当前节点时，通过注册同步任务将服务信息同步到集群远程节点</p></blockquote><ul><li>cancel</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">(<span class="keyword">final</span> String appName, <span class="keyword">final</span> String id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> expiryTime = System.currentTimeMillis() + maxProcessingDelayMs;</span><br><span class="line">     <span class="comment">//任务调度器中添加一个请求类型为取消cancel服务的同步任务</span></span><br><span class="line">     batchingDispatcher.process(</span><br><span class="line">             taskId(<span class="string">"cancel"</span>, appName, id),</span><br><span class="line">             <span class="keyword">new</span> InstanceReplicationTask(targetHost, Action.Cancel, appName, id) &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                     <span class="keyword">return</span> replicationClient.cancel(appName, id);</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleFailure</span><span class="params">(<span class="keyword">int</span> statusCode, Object responseEntity)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                     <span class="keyword">super</span>.handleFailure(statusCode, responseEntity);</span><br><span class="line">                     <span class="keyword">if</span> (statusCode == <span class="number">404</span>) &#123;</span><br><span class="line">                         logger.warn(<span class="string">"&#123;&#125;: missing entry."</span>, getTaskName());</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;,</span><br><span class="line">             expiryTime</span><br><span class="line">     );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>取消服务注册任务，当前节点有服务取消注册，将信息同步到集群远程节点</p><ul><li>heartbeat</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public void heartbeat(final String appName, final String id,</span><br><span class="line">                      final InstanceInfo info, final InstanceStatus overriddenStatus,</span><br><span class="line">                      boolean primeConnection) throws Throwable &#123;</span><br><span class="line">    //当第一次连接时直接发送心跳到远端</span><br><span class="line">    if (primeConnection) &#123;</span><br><span class="line">        // We do not care about the result for priming request.</span><br><span class="line">        replicationClient.sendHeartBeat(appName, id, info, overriddenStatus);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //心跳同步任务</span><br><span class="line">    ReplicationTask replicationTask = new InstanceReplicationTask(targetHost, Action.Heartbeat, info, overriddenStatus, false) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public EurekaHttpResponse&lt;InstanceInfo&gt; execute() throws Throwable &#123;</span><br><span class="line">            return replicationClient.sendHeartBeat(appName, id, info, overriddenStatus);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleFailure(int statusCode, Object responseEntity) throws Throwable &#123;</span><br><span class="line">            super.handleFailure(statusCode, responseEntity);</span><br><span class="line">            if (statusCode == 404) &#123;</span><br><span class="line">                logger.warn(&quot;&#123;&#125;: missing entry.&quot;, getTaskName());</span><br><span class="line">                if (info != null) &#123;</span><br><span class="line">                    logger.warn(&quot;&#123;&#125;: cannot find instance id &#123;&#125; and hence replicating the instance with status &#123;&#125;&quot;,</span><br><span class="line">                            getTaskName(), info.getId(), info.getStatus());</span><br><span class="line">                    register(info);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (config.shouldSyncWhenTimestampDiffers()) &#123;</span><br><span class="line">                InstanceInfo peerInstanceInfo = (InstanceInfo) responseEntity;</span><br><span class="line">                if (peerInstanceInfo != null) &#123;</span><br><span class="line">                    syncInstancesIfTimestampDiffers(appName, id, info, peerInstanceInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    long expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info);</span><br><span class="line">    //任务调度器中添加一个请求类型为heartbeat服务的同步任务</span><br><span class="line">    batchingDispatcher.process(taskId(&quot;heartbeat&quot;, info), replicationTask, expiryTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>心跳同步任务，当前节点有服务发送心跳续租，将信息同步到集群远程节点</p><ul><li>StatusUpdate </li><li>DeleteStatusOverride</li></ul></blockquote><h4 id="集群节点数据同步任务处理"><a href="#集群节点数据同步任务处理" class="headerlink" title="集群节点数据同步任务处理"></a>集群节点数据同步任务处理</h4><blockquote><p>在PeerEurekaNode的构造函数中可以看到同步任务处理由ReplicationTaskProcessor完成，下面看此类源码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 单个处理ReplicationTask任务</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ProcessingResult <span class="title">process</span><span class="params">(ReplicationTask task)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//调用任务execute方法，完成任务的执行</span></span><br><span class="line">           EurekaHttpResponse&lt;?&gt; httpResponse = task.execute();</span><br><span class="line">           <span class="keyword">int</span> statusCode = httpResponse.getStatusCode();</span><br><span class="line">           <span class="comment">//判断任务返回结果</span></span><br><span class="line">           Object entity = httpResponse.getEntity();</span><br><span class="line">           <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">               logger.debug(<span class="string">"Replication task &#123;&#125; completed with status &#123;&#125;, (includes entity &#123;&#125;)"</span>, task.getTaskName(), statusCode, entity != <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (isSuccess(statusCode)) &#123;</span><br><span class="line">               task.handleSuccess();</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusCode == <span class="number">503</span>) &#123;</span><br><span class="line">               logger.debug(<span class="string">"Server busy (503) reply for task &#123;&#125;"</span>, task.getTaskName());</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.Congestion;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               task.handleFailure(statusCode, entity);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.PermanentError;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           <span class="keyword">if</span> (isNetworkConnectException(e)) &#123;</span><br><span class="line">               logNetworkErrorSample(task, e);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.TransientError;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               logger.error(peerId + <span class="string">": "</span> + task.getTaskName() + <span class="string">"Not re-trying this exception because it does not seem to be a network exception"</span>, e);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.PermanentError;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ProcessingResult.Success;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>单任务处理 </p><ol><li>调用任务task的execute完成远程数据同步</li><li>分析远程返回结果</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 批量处理ReplicationTask任务</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> tasks</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ProcessingResult <span class="title">process</span><span class="params">(List&lt;ReplicationTask&gt; tasks)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//根据task集合创建ReplicationList</span></span><br><span class="line">       ReplicationList list = createReplicationListOf(tasks);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//调用批量同步接口 将同步集合发送到远端节点同步数据</span></span><br><span class="line">           EurekaHttpResponse&lt;ReplicationListResponse&gt; response = replicationClient.submitBatchUpdates(list);</span><br><span class="line">           <span class="comment">//判断同步返回结果</span></span><br><span class="line">           <span class="keyword">int</span> statusCode = response.getStatusCode();</span><br><span class="line">           <span class="keyword">if</span> (!isSuccess(statusCode)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (statusCode == <span class="number">503</span>) &#123;</span><br><span class="line">                   logger.warn(<span class="string">"Server busy (503) HTTP status code received from the peer &#123;&#125;; rescheduling tasks after delay"</span>, peerId);</span><br><span class="line">                   <span class="keyword">return</span> ProcessingResult.Congestion;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// Unexpected error returned from the server. This should ideally never happen.</span></span><br><span class="line">                   logger.error(<span class="string">"Batch update failure with HTTP status code &#123;&#125;; discarding &#123;&#125; replication tasks"</span>, statusCode, tasks.size());</span><br><span class="line">                   <span class="keyword">return</span> ProcessingResult.PermanentError;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               handleBatchResponse(tasks, response.getEntity().getResponseList());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           <span class="keyword">if</span> (isNetworkConnectException(e)) &#123;</span><br><span class="line">               logNetworkErrorSample(<span class="keyword">null</span>, e);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.TransientError;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               logger.error(<span class="string">"Not re-trying this exception because it does not seem to be a network exception"</span>, e);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.PermanentError;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ProcessingResult.Success;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>批处理任务，将一组任务一次性发送到远程进行处理</p><ol><li>根据task集合创建ReplicationList</li><li>调用批量同步接口将同步集合发送到远端节点同步数据 即调用rest API /{version}/peerreplication</li><li>分析远程返回结果</li></ol></blockquote><hr><blockquote><p><strong>eureka 服务端 集群节点发现，数据同步功能主要是由PeerEurekaNodes与PeerEurekaNode类实现,通过源码的跟踪可以清晰看出集群实现的逻辑，方便在实际应用中对问题的定位</strong></p></blockquote>]]></content>
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/08/23/hello-world/"/>
      <url>/2018/08/23/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
