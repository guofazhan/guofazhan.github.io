<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Eureka之远程通讯模块</title>
      <link href="/2018/08/25/Eureka%E4%B9%8B%E8%BF%9C%E7%A8%8B%E9%80%9A%E8%AE%AF%E6%A8%A1%E5%9D%97/"/>
      <url>/2018/08/25/Eureka%E4%B9%8B%E8%BF%9C%E7%A8%8B%E9%80%9A%E8%AE%AF%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<blockquote><p>Eureka 架构为C-S模式 同时支持S 集群 ，不可避免的在client-server、server-server之间是需要远程通讯的，上面已经知道，Eureka 提供是http协议rest api，下面通过源码源码分析学习下eureka 提供的远程通讯模块</p></blockquote><h4 id="提供远程通讯模块的包路径"><a href="#提供远程通讯模块的包路径" class="headerlink" title="提供远程通讯模块的包路径"></a>提供远程通讯模块的包路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.netflix.discovery.shared.transport</span><br></pre></td></tr></table></figure><h4 id="通讯模块对外的核心接口矩阵"><a href="#通讯模块对外的核心接口矩阵" class="headerlink" title="通讯模块对外的核心接口矩阵"></a>通讯模块对外的核心接口矩阵</h4><p><img src="https://github.com/guofazhan/image/blob/master/%E9%80%9A%E8%AE%AF%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3.png?raw=true" alt="image"></p><blockquote><ol><li>EurekaHttpClient 通讯请求接口，负责发送http请求</li><li>EurekaHttpClientFactory EurekaHttpClient创建工厂接口，负责创建高等级的client</li><li>TransportClientFactory EurekaHttpClient创建工厂接口，负责创建低等级的client</li><li>EurekaTransportConfig 通讯相关配置获取接口，负责在配置文件中读取通讯模块的配置信息</li></ol></blockquote><blockquote><p><strong>备注：</strong> EurekaHttpClientFactory与TransportClientFactory同样都是创建client工厂，不过两个的职责不一样，client按功能划分为两大类，下面详细介绍。<br><a id="more"></a></p></blockquote><h4 id="EurekaHttpClient"><a href="#EurekaHttpClient" class="headerlink" title="EurekaHttpClient"></a>EurekaHttpClient</h4><p><img src="https://github.com/guofazhan/image/blob/master/EurekaHttpClient.png?raw=true" alt="image"></p><blockquote><p>通过上图可以明确的看出EurekaHttpClient接口实现为两大类:</p><ol><li>实现http通讯的lowlevel实现；</li><li>使用装饰器模式实现特定功能的top level实现 。</li></ol></blockquote><blockquote><p>low level实现：  Eureka 根据http client 实现了两个AbstractJerseyEurekaHttpClient与AbstractJersey2EurekaHttpClient的low level 实现。从上面可以看出，如果Jersey1与Jersey2都不满足我们的自己的需求的话，我也可以根据自己需要的httpClient实现替代类，例如实现以OKhttp作为底层通讯的OkHttpEurekaHttpClient 或实现以netty作为底层通讯的NettyEurekaHttpClient，</p></blockquote><blockquote><p>top level实现 ： 通过装饰器模式eueka 内置了 响应指标采集功能的装饰器、失败重试功能装饰器等，同时我们也可以扩展。</p></blockquote><blockquote><p><strong> 备注：</strong> HttpReplicationClient是eureka 专为server端集群节点通讯提供的通讯接口。其本质low level</p></blockquote><ul><li>EurekaHttpClient接口方法</li></ul><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>register(InstanceInfo info)</td><td>服务注册</td></tr><tr><td>cancel(String appName, String id)</td><td>服务下线</td></tr><tr><td>sendHeartBeat</td><td>服务续约</td></tr><tr><td>statusUpdate</td><td>服务状态更新</td></tr><tr><td>deleteStatusOverride</td><td></td></tr><tr><td>getApplications(String… regions)</td><td>获取服务注册列表</td></tr><tr><td>getDelta(String… regions)</td><td>获取增量列表</td></tr><tr><td>getVip(String vipAddress, String… regions)</td><td>根据vip获取列表</td></tr><tr><td>getSecureVip(String secureVipAddress, String… regions)</td><td>根据svip获取列表</td></tr><tr><td>getApplication(String appName)</td><td>根据集群ID获取服务集群列表</td></tr><tr><td>getInstance(String appName, String id)</td><td>根据集群ID与服务ID获取服务</td></tr><tr><td>getInstance(String id)</td><td>根据服务ID获取服务</td></tr></tbody></table><ul><li>HttpReplicationClient接口方法 (server 节点数据同步特有)</li></ul><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>statusUpdate(String asgName, ASGStatus newStatus)</td><td>状态更新同步</td></tr><tr><td>submitBatchUpdates(ReplicationList replicationList)</td><td>批量执行更新同步任务</td></tr></tbody></table><h4 id="EurekaTransportConfig通讯配置新获取"><a href="#EurekaTransportConfig通讯配置新获取" class="headerlink" title="EurekaTransportConfig通讯配置新获取"></a>EurekaTransportConfig通讯配置新获取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * eureka 远程通讯客户端配置默认实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> David Liu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEurekaTransportConfig</span> <span class="keyword">implements</span> <span class="title">EurekaTransportConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUB_NAMESPACE = TRANSPORT_CONFIG_SUB_NAMESPACE + <span class="string">"."</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namespace;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DynamicPropertyFactory configInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEurekaTransportConfig</span><span class="params">(String parentNamespace, DynamicPropertyFactory configInstance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.namespace = parentNamespace == <span class="keyword">null</span></span><br><span class="line">                ? SUB_NAMESPACE</span><br><span class="line">                : (parentNamespace.endsWith(<span class="string">"."</span>)</span><br><span class="line">                    ? parentNamespace + SUB_NAMESPACE</span><br><span class="line">                    : parentNamespace + <span class="string">"."</span> + SUB_NAMESPACE);</span><br><span class="line">        <span class="keyword">this</span>.configInstance = configInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSessionedClientReconnectIntervalSeconds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInstance.getIntProperty(namespace + SESSION_RECONNECT_INTERVAL_KEY, Values.SESSION_RECONNECT_INTERVAL).get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>1.构建函数创建 DynamicPropertyFactory</p><ol start="2"><li>构建函数 初始化namespace 配置key的前缀</li><li>获取配置信息通过DynamicPropertyFactory 动态在配置文件中获取</li></ol></blockquote><h4 id="EurekaHttpClients-工具类"><a href="#EurekaHttpClients-工具类" class="headerlink" title="EurekaHttpClients 工具类"></a>EurekaHttpClients 工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaHttpClients</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(EurekaHttpClients.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EurekaHttpClients</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EurekaHttpClientFactory <span class="title">queryClientFactory</span><span class="params">(ClusterResolver bootstrapResolver,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                             TransportClientFactory transportClientFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                             EurekaClientConfig clientConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                             EurekaTransportConfig transportConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                             InstanceInfo myInstanceInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                             ApplicationsResolver.ApplicationsSource applicationsSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClosableResolver queryResolver = transportConfig.useBootstrapResolverForQuery()</span><br><span class="line">                ? wrapClosable(bootstrapResolver)</span><br><span class="line">                : queryClientResolver(bootstrapResolver, transportClientFactory,</span><br><span class="line">                clientConfig, transportConfig, myInstanceInfo, applicationsSource);</span><br><span class="line">        <span class="keyword">return</span> canonicalClientFactory(EurekaClientNames.QUERY, transportConfig, queryResolver, transportClientFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EurekaHttpClientFactory <span class="title">registrationClientFactory</span><span class="params">(ClusterResolver bootstrapResolver,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                    TransportClientFactory transportClientFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                    EurekaTransportConfig transportConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> canonicalClientFactory(EurekaClientNames.REGISTRATION, transportConfig, bootstrapResolver, transportClientFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> EurekaHttpClientFactory <span class="title">canonicalClientFactory</span><span class="params">(<span class="keyword">final</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                          <span class="keyword">final</span> EurekaTransportConfig transportConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                          <span class="keyword">final</span> ClusterResolver&lt;EurekaEndpoint&gt; clusterResolver,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                          <span class="keyword">final</span> TransportClientFactory transportClientFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EurekaHttpClientFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> EurekaHttpClient <span class="title">newClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SessionedEurekaHttpClient(</span><br><span class="line">                        name,</span><br><span class="line">                        RetryableEurekaHttpClient.createFactory(</span><br><span class="line">                                name,</span><br><span class="line">                                transportConfig,</span><br><span class="line">                                clusterResolver,</span><br><span class="line">                                RedirectingEurekaHttpClient.createFactory(transportClientFactory),</span><br><span class="line">                                ServerStatusEvaluators.legacyEvaluator()),</span><br><span class="line">                        transportConfig.getSessionedClientReconnectIntervalSeconds() * <span class="number">1000</span></span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                wrapClosable(clusterResolver).shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>EurekaHttpClients，是创建EurekaHttpClientFactory的工具类</p></blockquote><h4 id="EurekaHttpClient-Low-Level部分"><a href="#EurekaHttpClient-Low-Level部分" class="headerlink" title="EurekaHttpClient Low Level部分"></a>EurekaHttpClient Low Level部分</h4><ul><li>JerseyEurekaHttpClientFactory</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JerseyEurekaHttpClientFactory</span> <span class="keyword">implements</span> <span class="title">TransportClientFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTTP_X_DISCOVERY_ALLOW_REDIRECT = <span class="string">"X-Discovery-AllowRedirect"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaJerseyClient jerseyClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApacheHttpClient4 apacheClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApacheHttpClientConnectionCleaner cleaner;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; additionalHeaders;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JerseyEurekaHttpClientFactory</span><span class="params">(EurekaJerseyClient jerseyClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          ApacheHttpClient4 apacheClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">long</span> connectionIdleTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Map&lt;String, String&gt; additionalHeaders)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jerseyClient = jerseyClient;</span><br><span class="line">        <span class="keyword">this</span>.apacheClient = jerseyClient != <span class="keyword">null</span> ? jerseyClient.getClient() : apacheClient;</span><br><span class="line">        <span class="keyword">this</span>.additionalHeaders = additionalHeaders;</span><br><span class="line">        <span class="keyword">this</span>.cleaner = <span class="keyword">new</span> ApacheHttpClientConnectionCleaner(<span class="keyword">this</span>.apacheClient, connectionIdleTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务创建JerseyApplicationClient</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EurekaHttpClient <span class="title">newClient</span><span class="params">(EurekaEndpoint endpoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JerseyApplicationClient(apacheClient, endpoint.getServiceUrl(), additionalHeaders);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>JerseyEurekaHttpClientFactory 为TransportClientFactory的Jersey1实现主要负责创建JerseyEurekaHttpClient </p></blockquote><ul><li>AbstractJerseyEurekaHttpClient</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractJerseyEurekaHttpClient</span> <span class="keyword">implements</span> <span class="title">EurekaHttpClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbstractJerseyEurekaHttpClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * jersey1 http 客户端，负责底层发送http请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Client jerseyClient;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * server url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String serviceUrl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractJerseyEurekaHttpClient</span><span class="params">(Client jerseyClient, String serviceUrl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jerseyClient = jerseyClient;</span><br><span class="line">        <span class="keyword">this</span>.serviceUrl = serviceUrl;</span><br><span class="line">        logger.debug(<span class="string">"Created client for url: &#123;&#125;"</span>, serviceUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务注册</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> info</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">register</span><span class="params">(InstanceInfo info)</span> </span>&#123;</span><br><span class="line">        String urlPath = <span class="string">"apps/"</span> + info.getAppName();</span><br><span class="line">        ClientResponse response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过HTTP客户端发送http请求</span></span><br><span class="line">            Builder resourceBuilder = jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder();</span><br><span class="line">            addExtraHeaders(resourceBuilder);</span><br><span class="line">            <span class="comment">//构建响应结果</span></span><br><span class="line">            response = resourceBuilder</span><br><span class="line">                    .header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>)</span><br><span class="line">                    .type(MediaType.APPLICATION_JSON_TYPE)</span><br><span class="line">                    .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">                    .post(ClientResponse.class, info);</span><br><span class="line">            <span class="keyword">return</span> anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Jersey HTTP POST &#123;&#125;/&#123;&#125; with instance &#123;&#125;; statusCode=&#123;&#125;"</span>, serviceUrl, urlPath, info.getId(),</span><br><span class="line">                        response == <span class="keyword">null</span> ? <span class="string">"N/A"</span> : response.getStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>1.通过构建函数 可以看到传入一个jersey1 http 客户端</p><ol start="2"><li>register方法 实际是通过jersey1HttpClient发送http底层请求</li></ol></blockquote><blockquote><p>在这里可以看到AbstractJerseyEurekaHttpClient实际上是不做底层通讯的工作的，全部都是交由com.sun.jersey.api.client.Client处理的，这个是在创建工厂创建时设置到AbstractJerseyEurekaHttpClient中的</p></blockquote><blockquote><p><strong>备注:</strong> AbstractJersey2EurekaHttpClient与AbstractJerseyEurekaHttpClient的实现原理基本一样只是底层通讯的client不一致，后边不在描述</p></blockquote><h4 id="EurekaHttpClient-Top-Level部分"><a href="#EurekaHttpClient-Top-Level部分" class="headerlink" title="EurekaHttpClient Top Level部分"></a>EurekaHttpClient Top Level部分</h4><ul><li>EurekaHttpClientDecorator</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象Eureka远程通讯客户端装饰器，使用设计模式-装饰器模式 为客户端添加新的功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Tomasz Bak</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaHttpClientDecorator</span> <span class="keyword">implements</span> <span class="title">EurekaHttpClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> RequestType &#123;</span><br><span class="line">        <span class="comment">//注册</span></span><br><span class="line">        Register,</span><br><span class="line">        <span class="comment">//下线</span></span><br><span class="line">        Cancel,</span><br><span class="line">        <span class="comment">//心跳</span></span><br><span class="line">        SendHeartBeat,</span><br><span class="line">        <span class="comment">//状态更新</span></span><br><span class="line">        StatusUpdate,</span><br><span class="line">        DeleteStatusOverride,</span><br><span class="line">        GetApplications,</span><br><span class="line">        GetDelta,</span><br><span class="line">        GetVip,</span><br><span class="line">        GetSecureVip,</span><br><span class="line">        GetApplication,</span><br><span class="line">        GetInstance,</span><br><span class="line">        GetApplicationInstance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求执行接口，负责执行请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;R&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestExecutor</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行请求并返回响应信息</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> delegate 目标的客户端</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(EurekaHttpClient delegate)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 请求的类型</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">RequestType <span class="title">getRequestType</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象的执行方法，由子装饰器实现，附加其它功能</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestExecutor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;R&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;R&gt; <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个注册请求的执行器，并执行</span></span><br><span class="line">        <span class="keyword">return</span> execute(<span class="keyword">new</span> RequestExecutor&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">(EurekaHttpClient delegate)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> delegate.register(info);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> RequestType <span class="title">getRequestType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> RequestType.Register;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">cancel</span><span class="params">(<span class="keyword">final</span> String appName, <span class="keyword">final</span> String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个下线请求的执行，并执行</span></span><br><span class="line">        <span class="keyword">return</span> execute(<span class="keyword">new</span> RequestExecutor&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">(EurekaHttpClient delegate)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> delegate.cancel(appName, id);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> RequestType <span class="title">getRequestType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> RequestType.Cancel;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>基础的包装器 主要完成如下功能</p><ul><li>实现EurekaHttpClient接口每个基础方法，都有如下流程</li></ul><ol><li>创建一个请求执行接口</li><li>通过调用抽象的execute方法将RequestExecutor传入</li><li>子类在RequestExecutor执行前或后完成新功能的附加</li></ol></blockquote><ul><li>EurekaHttpClientDecorator实现</li></ul><table><thead><tr><th>实现类</th><th>描述</th></tr></thead><tbody><tr><td>MetricsCollectingEurekaHttpClient</td><td>实现请求响应状态指标采集的Eureka远程通讯客户端装饰器，为EurekaHttpClient添加响应状态指标采集向功能</td></tr><tr><td>RedirectingEurekaHttpClient</td><td>实现请求重定向的Eureka远程通讯客户端装饰器，为EurekaHttpClient添加请求重定向功能</td></tr><tr><td>RetryableEurekaHttpClient</td><td>实现请求失败重试的Eureka远程通讯客户端装饰器，为EurekaHttpClient添加失败重试功能</td></tr><tr><td>SessionedEurekaHttpClient</td><td>TODO</td></tr></tbody></table><hr><blockquote><p>从以上来看eureka 通讯模块结构和功能还是非常明了清晰，同时后期如果需要扩展，也是非常方便与快捷的</p></blockquote>]]></content>
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Eureka之REST API</title>
      <link href="/2018/08/23/Eureka%E4%B9%8BREST-API-1/"/>
      <url>/2018/08/23/Eureka%E4%B9%8BREST-API-1/</url>
      <content type="html"><![CDATA[<blockquote><p>Eureka服务端与客户之间的通讯方式为http，服务端通过提供rest API风格的接口与客户端或其它服务端交互。</p></blockquote><h4 id="交互数据格式"><a href="#交互数据格式" class="headerlink" title="交互数据格式"></a>交互数据格式</h4><blockquote><p>JSON/XML</p></blockquote><h4 id="提供资源服务的包路径"><a href="#提供资源服务的包路径" class="headerlink" title="提供资源服务的包路径"></a>提供资源服务的包路径</h4><blockquote><p><strong>com.netflix.eureka.resources</strong><br><a id="more"></a></p></blockquote><h4 id="提供可使用的REST-API接口"><a href="#提供可使用的REST-API接口" class="headerlink" title="提供可使用的REST API接口"></a>提供可使用的REST API接口</h4><blockquote><p><strong>/{version}/apps 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/apps.png?raw=true" alt="image"></p><blockquote><p><strong>/{version}/instances 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/rs.png?raw=true" alt="image"></p><blockquote><p><strong>/{version}/status 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/status.png?raw=true" alt="image"></p><blockquote><p><strong>/{version}/peerreplication 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/pree.png?raw=true" alt="image"></p><blockquote><p><strong>/{version}/vips 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/vip.png?raw=true" alt="image"></p><blockquote><p><strong>/{version}/svips 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/svip.png?raw=true" alt="image"></p>]]></content>
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Eureka之服务注册数据模型</title>
      <link href="/2018/08/23/Eureka%E4%B9%8B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/08/23/Eureka%E4%B9%8B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<blockquote><p>Eureka 作为注册中心，担任着服务节点的注册以及发现，并提供着动态的管理（坏点摘除，服务检测等）。可以说是整个系统的基础设施。</p></blockquote><ul><li>注册列表的数据模型</li></ul><p><img src="https://github.com/guofazhan/image/blob/master/eureka%E6%B3%A8%E5%86%8C%E5%88%97%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B.png?raw=true" alt="image"><br><a id="more"></a><br><strong>1. Applications</strong></p><blockquote><p>注册列表，包含注册到当前注册中心上的所有实例信息，每个注册中心在内存中保持一份数据。在Applications中持有Application的队列</p></blockquote><p><strong>2. Application</strong></p><blockquote><p>注册到注册中心的服务集群信息，Application可以看做为一组对外提供相同服务的集群列表。在Application包含一组提供相同服务的InstanceInfo集合</p></blockquote><p><strong>3. InstanceInfo</strong></p><blockquote><p>注册列表里的单个服务实例信息，代表系统中提供一项服务的某个节点，里面包含节点的基础信息，以及唯一标识instanceId。</p></blockquote><p><strong>4. DataCenterInfo</strong></p><blockquote><p>服务实例所在的数据中心，默认为MyOwn，为InstanceInfo子属性</p></blockquote><p><strong>5. LeaseInfo</strong></p><blockquote><p>服务实例的租约信息，用于对服务做健康检查，续租，过期等服务可用性的管理。为InstanceInfo子属性</p></blockquote><hr><p>通过数据模型图可以清楚的看到Eureka将我们系统中的服务信息抽象成5个对象进行精细化的管理。我们注册进去的服务信息都将实例化成上述对象存储在eureka的服务端内存中，从而对外提供服务的注册以及发现。</p>]]></content>
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Eureka之server端集群节点发现，数据同步</title>
      <link href="/2018/08/23/Eureka%E4%B9%8Bserver%E7%AB%AF%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E5%8F%91%E7%8E%B0%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5-1/"/>
      <url>/2018/08/23/Eureka%E4%B9%8Bserver%E7%AB%AF%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E5%8F%91%E7%8E%B0%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5-1/</url>
      <content type="html"><![CDATA[<blockquote><p>Eureka服务端支持集群部署，通过源码查看集群节点发现以及数据同步功能的实现</p></blockquote><h4 id="提供集群功能的包路径"><a href="#提供集群功能的包路径" class="headerlink" title="提供集群功能的包路径"></a>提供集群功能的包路径</h4><blockquote><p>com.netflix.eureka.cluster</p></blockquote><h4 id="集群节点发现以及动态更新节点功能"><a href="#集群节点发现以及动态更新节点功能" class="headerlink" title="集群节点发现以及动态更新节点功能"></a>集群节点发现以及动态更新节点功能</h4><blockquote><p>Eureka服务端封装了一个集群节点管理的类名称为PeerEurekaNodes 通过名称翻译出来为对等的Eureka节点集合，可以看出这个类是对eureka服务端集群节点抽象，下面通过源码查询eureka是怎么管理与发现节点信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * eureka server 集群节点 集合类 帮助管理维护集群节点</span></span><br><span class="line"><span class="comment"> * Helper class to manage lifecycle of a collection of &#123;<span class="doctag">@link</span> PeerEurekaNode&#125;s.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Tomasz Bak</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeerEurekaNodes</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集群节点集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;PeerEurekaNode&gt; peerEurekaNodes = Collections.emptyList();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集群节点URL集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;String&gt; peerEurekaNodeUrls = Collections.emptySet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时任务线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ScheduledExecutorService taskExecutor;</span><br></pre></td></tr></table></figure><blockquote><p>通过PeerEurekaNodes类属性可以看到提供了两个集合以及一个执行定时任务的线程池，其它配置属性忽略</p><ol><li>peerEurekaNodes 表示集群节点集合</li><li>peerEurekaNodeUrls 表示集群节点对应的URL集合</li><li>taskExecutor 执行定时任务的线程池<a id="more"></a>同时 PeerEurekaNodes 类提供start 与shutdown方法，接下来主要看start方法的实现</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动方法，此方法管理集群节点间的通讯</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化定时任务线程池</span></span><br><span class="line">        taskExecutor = Executors.newSingleThreadScheduledExecutor(</span><br><span class="line">                <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                        Thread thread = <span class="keyword">new</span> Thread(r, <span class="string">"Eureka-PeerNodesUpdater"</span>);</span><br><span class="line">                        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> thread;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            updatePeerEurekaNodes(resolvePeerUrls());</span><br><span class="line">            <span class="comment">//节点更新任务线程</span></span><br><span class="line">            Runnable peersUpdateTask = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        updatePeerEurekaNodes(resolvePeerUrls());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        logger.error(<span class="string">"Cannot update the replica Nodes"</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。</span></span><br><span class="line"><span class="comment">//            如果任务的任一执行遇到异常，就会取消后续执行。否则，只能通过执行程序的取消或终止方法来终止该任务。</span></span><br><span class="line"><span class="comment">//            参数：</span></span><br><span class="line"><span class="comment">//            command - 要执行的任务</span></span><br><span class="line"><span class="comment">//            initialdelay - 首次执行的延迟时间</span></span><br><span class="line"><span class="comment">//            delay - 一次执行终止和下一次执行开始之间的延迟</span></span><br><span class="line"><span class="comment">//            unit - initialdelay 和 delay 参数的时间单位</span></span><br><span class="line">            <span class="comment">//定时执行节点更新任务线程</span></span><br><span class="line">            taskExecutor.scheduleWithFixedDelay(</span><br><span class="line">                    peersUpdateTask,</span><br><span class="line">                    serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</span><br><span class="line">                    serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</span><br><span class="line">                    TimeUnit.MILLISECONDS</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (PeerEurekaNode node : peerEurekaNodes) &#123;</span><br><span class="line">            logger.info(<span class="string">"Replica node URL:  "</span> + node.getServiceUrl());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>start 方法主要完成以下几件事</p><ol><li>初始化定时任务线程池</li><li>首次更新集群节点 updatePeerEurekaNodes方法</li><li>创建更新集群节点任务线程</li><li>通过定时任务线程池定时执行更新集群节点线程</li></ol></blockquote><blockquote><p>通过start 可以看出 eureka是通过一个定时线程定时去更新集群的节点信息达到对集群节点的动态发现和感知，在上面我们可以看到更新操作主要由updatePeerEurekaNodes方法完成，下面查看此方法的实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updatePeerEurekaNodes</span><span class="params">(List&lt;String&gt; newPeerUrls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newPeerUrls.isEmpty()) &#123;</span><br><span class="line">        logger.warn(<span class="string">"The replica size seems to be empty. Check the route 53 DNS Registry"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; toShutdown = <span class="keyword">new</span> HashSet&lt;&gt;(peerEurekaNodeUrls);</span><br><span class="line">    toShutdown.removeAll(newPeerUrls);</span><br><span class="line">    Set&lt;String&gt; toAdd = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</span><br><span class="line">    toAdd.removeAll(peerEurekaNodeUrls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验新的URL集合与旧有的URL集合是否一致，一致，不需要更新直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (toShutdown.isEmpty() &amp;&amp; toAdd.isEmpty()) &#123; <span class="comment">// No change</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove peers no long available</span></span><br><span class="line">    List&lt;PeerEurekaNode&gt; newNodeList = <span class="keyword">new</span> ArrayList&lt;&gt;(peerEurekaNodes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除旧集合中不可用的节点信息</span></span><br><span class="line">    <span class="keyword">if</span> (!toShutdown.isEmpty()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Removing no longer available peer nodes &#123;&#125;"</span>, toShutdown);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; newNodeList.size()) &#123;</span><br><span class="line">            PeerEurekaNode eurekaNode = newNodeList.get(i);</span><br><span class="line">            <span class="keyword">if</span> (toShutdown.contains(eurekaNode.getServiceUrl())) &#123;</span><br><span class="line">                newNodeList.remove(i);</span><br><span class="line">                eurekaNode.shutDown();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加新增加的节点信息</span></span><br><span class="line">    <span class="comment">// Add new peers</span></span><br><span class="line">    <span class="keyword">if</span> (!toAdd.isEmpty()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Adding new peer nodes &#123;&#125;"</span>, toAdd);</span><br><span class="line">        <span class="keyword">for</span> (String peerUrl : toAdd) &#123;</span><br><span class="line">            newNodeList.add(createPeerEurekaNode(peerUrl));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新赋值peerEurekaNodes与peerEurekaNodeUrls</span></span><br><span class="line">    <span class="keyword">this</span>.peerEurekaNodes = newNodeList;</span><br><span class="line">    <span class="keyword">this</span>.peerEurekaNodeUrls = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>updatePeerEurekaNodes根据传入的新集群URL集合完成节点的更新</p><ol><li>校验传入的URL集合是否需要更新</li><li>移除新url集合中没有的旧节点并关闭节点</li><li>创建旧节点集合中没有的新URL节点通过createPeerEurekaNode方法</li><li>重新赋值节点集合以及URL集合完成节点的更新</li></ol></blockquote><blockquote><p>updatePeerEurekaNodes传入的新URL集合是通过resolvePeerUrls方法获取，这个方法实际上是解析配置文件中的eureka.serviceUrl前缀的配置获取，并动态监听配置的更新。 创建新的节点是通过createPeerEurekaNode创建，下面查看此方法源码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据URL创建server新节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> peerEurekaNodeUrl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> PeerEurekaNode <span class="title">createPeerEurekaNode</span><span class="params">(String peerEurekaNodeUrl)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个连接远程节点的客户端</span></span><br><span class="line">    HttpReplicationClient replicationClient = JerseyReplicationClient.createReplicationClient(serverConfig, serverCodecs, peerEurekaNodeUrl);</span><br><span class="line">    <span class="comment">//获取新节点host信息</span></span><br><span class="line">    String targetHost = hostFromUrl(peerEurekaNodeUrl);</span><br><span class="line">    <span class="keyword">if</span> (targetHost == <span class="keyword">null</span>) &#123;</span><br><span class="line">        targetHost = <span class="string">"host"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建新节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PeerEurekaNode(registry, targetHost, peerEurekaNodeUrl, replicationClient, serverConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PeerEurekaNode 方法 </p><ol><li>创建远程通讯客户端replicationClient 用户与此节点间通讯，数据同步等工作</li><li>获取要创建的远程节点的host</li><li>创建一个表示远程节点实例 PeerEurekaNode</li></ol></blockquote><blockquote><p>PeerEurekaNode 表示一个与当前节点对等的远程节点，当前节点与远程节点的数据同步工作都是在此实例中完成的。</p></blockquote><h4 id="集群节点数据同步"><a href="#集群节点数据同步" class="headerlink" title="集群节点数据同步"></a>集群节点数据同步</h4><blockquote><p>在上面节点发现中知道eureka是通过PeerEurekaNode表示远程对等接点，并将远程通讯客户端replicationClient传入到PeerEurekaNode中，接下来通过查看PeerEurekaNode源码来看eureka集群节点间都有那些数据需要同步以及通讯内容</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* For testing */</span> PeerEurekaNode(PeerAwareInstanceRegistry registry, String targetHost, String serviceUrl,</span><br><span class="line">                                 HttpReplicationClient replicationClient, EurekaServerConfig config,</span><br><span class="line">                                 <span class="keyword">int</span> batchSize, <span class="keyword">long</span> maxBatchingDelayMs,</span><br><span class="line">                                 <span class="keyword">long</span> retrySleepTimeMs, <span class="keyword">long</span> serverUnavailableSleepTimeMs) &#123;</span><br><span class="line">    String batcherName = getBatcherName();</span><br><span class="line">    <span class="comment">//任务处理器</span></span><br><span class="line">    ReplicationTaskProcessor taskProcessor = <span class="keyword">new</span> ReplicationTaskProcessor(targetHost, replicationClient);</span><br><span class="line">    <span class="comment">//创建一个批量执行的任务调度器</span></span><br><span class="line">    <span class="keyword">this</span>.batchingDispatcher = TaskDispatchers.createBatchingTaskDispatcher(</span><br><span class="line">            batcherName,</span><br><span class="line">            config.getMaxElementsInPeerReplicationPool(),</span><br><span class="line">            batchSize,</span><br><span class="line">            config.getMaxThreadsForPeerReplication(),</span><br><span class="line">            maxBatchingDelayMs,</span><br><span class="line">            serverUnavailableSleepTimeMs,</span><br><span class="line">            retrySleepTimeMs,</span><br><span class="line">            taskProcessor</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//创建一个单任务调度器</span></span><br><span class="line">    <span class="keyword">this</span>.nonBatchingDispatcher = TaskDispatchers.createNonBatchingTaskDispatcher(</span><br><span class="line">            targetHost,</span><br><span class="line">            config.getMaxElementsInStatusReplicationPool(),</span><br><span class="line">            config.getMaxThreadsForStatusReplication(),</span><br><span class="line">            maxBatchingDelayMs,</span><br><span class="line">            serverUnavailableSleepTimeMs,</span><br><span class="line">            retrySleepTimeMs,</span><br><span class="line">            taskProcessor</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PeerEurekaNode 完成以下事件</p><ol><li>创建数据同步的任务处理器ReplicationTaskProcessor</li><li>创建批处理任务调度器</li><li>创建单任务处理调度器</li></ol></blockquote><blockquote><p><strong>说明:</strong>  eureka将节点间的数据同步工作包装成一个个细微的任务ReplicationTask ，每一个数据操作代表一个任务，将任务发送给任务调度器TaskDispatcher去异步处理。</p></blockquote><blockquote><p>下来查看PeerEurekaNode都可以创建那些同步任务</p><ul><li>register</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当eureka server注册新服务时，同时创建一个定时任务将新服务同步到集群其它节点</span></span><br><span class="line"><span class="comment"> * Sends the registration information of &#123;<span class="doctag">@link</span> InstanceInfo&#125; receiving by</span></span><br><span class="line"><span class="comment"> * this node to the peer node represented by this class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> info</span></span><br><span class="line"><span class="comment"> *            the instance information &#123;<span class="doctag">@link</span> InstanceInfo&#125; of any instance</span></span><br><span class="line"><span class="comment"> *            that is send to this instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info);</span><br><span class="line">    <span class="comment">//任务调度器中添加一个请求类型为注册register新服务的同步任务</span></span><br><span class="line">    batchingDispatcher.process(</span><br><span class="line">            taskId(<span class="string">"register"</span>, info),</span><br><span class="line">            <span class="keyword">new</span> InstanceReplicationTask(targetHost, Action.Register, info, <span class="keyword">null</span>, <span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> replicationClient.register(info);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            expiryTime</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注册同步任务，当有服务注册到当前节点时，通过注册同步任务将服务信息同步到集群远程节点</p></blockquote><ul><li>cancel</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">(<span class="keyword">final</span> String appName, <span class="keyword">final</span> String id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> expiryTime = System.currentTimeMillis() + maxProcessingDelayMs;</span><br><span class="line">     <span class="comment">//任务调度器中添加一个请求类型为取消cancel服务的同步任务</span></span><br><span class="line">     batchingDispatcher.process(</span><br><span class="line">             taskId(<span class="string">"cancel"</span>, appName, id),</span><br><span class="line">             <span class="keyword">new</span> InstanceReplicationTask(targetHost, Action.Cancel, appName, id) &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                     <span class="keyword">return</span> replicationClient.cancel(appName, id);</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleFailure</span><span class="params">(<span class="keyword">int</span> statusCode, Object responseEntity)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                     <span class="keyword">super</span>.handleFailure(statusCode, responseEntity);</span><br><span class="line">                     <span class="keyword">if</span> (statusCode == <span class="number">404</span>) &#123;</span><br><span class="line">                         logger.warn(<span class="string">"&#123;&#125;: missing entry."</span>, getTaskName());</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;,</span><br><span class="line">             expiryTime</span><br><span class="line">     );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>取消服务注册任务，当前节点有服务取消注册，将信息同步到集群远程节点</p><ul><li>heartbeat</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public void heartbeat(final String appName, final String id,</span><br><span class="line">                      final InstanceInfo info, final InstanceStatus overriddenStatus,</span><br><span class="line">                      boolean primeConnection) throws Throwable &#123;</span><br><span class="line">    //当第一次连接时直接发送心跳到远端</span><br><span class="line">    if (primeConnection) &#123;</span><br><span class="line">        // We do not care about the result for priming request.</span><br><span class="line">        replicationClient.sendHeartBeat(appName, id, info, overriddenStatus);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //心跳同步任务</span><br><span class="line">    ReplicationTask replicationTask = new InstanceReplicationTask(targetHost, Action.Heartbeat, info, overriddenStatus, false) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public EurekaHttpResponse&lt;InstanceInfo&gt; execute() throws Throwable &#123;</span><br><span class="line">            return replicationClient.sendHeartBeat(appName, id, info, overriddenStatus);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleFailure(int statusCode, Object responseEntity) throws Throwable &#123;</span><br><span class="line">            super.handleFailure(statusCode, responseEntity);</span><br><span class="line">            if (statusCode == 404) &#123;</span><br><span class="line">                logger.warn(&quot;&#123;&#125;: missing entry.&quot;, getTaskName());</span><br><span class="line">                if (info != null) &#123;</span><br><span class="line">                    logger.warn(&quot;&#123;&#125;: cannot find instance id &#123;&#125; and hence replicating the instance with status &#123;&#125;&quot;,</span><br><span class="line">                            getTaskName(), info.getId(), info.getStatus());</span><br><span class="line">                    register(info);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (config.shouldSyncWhenTimestampDiffers()) &#123;</span><br><span class="line">                InstanceInfo peerInstanceInfo = (InstanceInfo) responseEntity;</span><br><span class="line">                if (peerInstanceInfo != null) &#123;</span><br><span class="line">                    syncInstancesIfTimestampDiffers(appName, id, info, peerInstanceInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    long expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info);</span><br><span class="line">    //任务调度器中添加一个请求类型为heartbeat服务的同步任务</span><br><span class="line">    batchingDispatcher.process(taskId(&quot;heartbeat&quot;, info), replicationTask, expiryTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>心跳同步任务，当前节点有服务发送心跳续租，将信息同步到集群远程节点</p><ul><li>StatusUpdate </li><li>DeleteStatusOverride</li></ul></blockquote><h4 id="集群节点数据同步任务处理"><a href="#集群节点数据同步任务处理" class="headerlink" title="集群节点数据同步任务处理"></a>集群节点数据同步任务处理</h4><blockquote><p>在PeerEurekaNode的构造函数中可以看到同步任务处理由ReplicationTaskProcessor完成，下面看此类源码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 单个处理ReplicationTask任务</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ProcessingResult <span class="title">process</span><span class="params">(ReplicationTask task)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//调用任务execute方法，完成任务的执行</span></span><br><span class="line">           EurekaHttpResponse&lt;?&gt; httpResponse = task.execute();</span><br><span class="line">           <span class="keyword">int</span> statusCode = httpResponse.getStatusCode();</span><br><span class="line">           <span class="comment">//判断任务返回结果</span></span><br><span class="line">           Object entity = httpResponse.getEntity();</span><br><span class="line">           <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">               logger.debug(<span class="string">"Replication task &#123;&#125; completed with status &#123;&#125;, (includes entity &#123;&#125;)"</span>, task.getTaskName(), statusCode, entity != <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (isSuccess(statusCode)) &#123;</span><br><span class="line">               task.handleSuccess();</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusCode == <span class="number">503</span>) &#123;</span><br><span class="line">               logger.debug(<span class="string">"Server busy (503) reply for task &#123;&#125;"</span>, task.getTaskName());</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.Congestion;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               task.handleFailure(statusCode, entity);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.PermanentError;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           <span class="keyword">if</span> (isNetworkConnectException(e)) &#123;</span><br><span class="line">               logNetworkErrorSample(task, e);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.TransientError;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               logger.error(peerId + <span class="string">": "</span> + task.getTaskName() + <span class="string">"Not re-trying this exception because it does not seem to be a network exception"</span>, e);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.PermanentError;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ProcessingResult.Success;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>单任务处理 </p><ol><li>调用任务task的execute完成远程数据同步</li><li>分析远程返回结果</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 批量处理ReplicationTask任务</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> tasks</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ProcessingResult <span class="title">process</span><span class="params">(List&lt;ReplicationTask&gt; tasks)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//根据task集合创建ReplicationList</span></span><br><span class="line">       ReplicationList list = createReplicationListOf(tasks);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//调用批量同步接口 将同步集合发送到远端节点同步数据</span></span><br><span class="line">           EurekaHttpResponse&lt;ReplicationListResponse&gt; response = replicationClient.submitBatchUpdates(list);</span><br><span class="line">           <span class="comment">//判断同步返回结果</span></span><br><span class="line">           <span class="keyword">int</span> statusCode = response.getStatusCode();</span><br><span class="line">           <span class="keyword">if</span> (!isSuccess(statusCode)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (statusCode == <span class="number">503</span>) &#123;</span><br><span class="line">                   logger.warn(<span class="string">"Server busy (503) HTTP status code received from the peer &#123;&#125;; rescheduling tasks after delay"</span>, peerId);</span><br><span class="line">                   <span class="keyword">return</span> ProcessingResult.Congestion;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// Unexpected error returned from the server. This should ideally never happen.</span></span><br><span class="line">                   logger.error(<span class="string">"Batch update failure with HTTP status code &#123;&#125;; discarding &#123;&#125; replication tasks"</span>, statusCode, tasks.size());</span><br><span class="line">                   <span class="keyword">return</span> ProcessingResult.PermanentError;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               handleBatchResponse(tasks, response.getEntity().getResponseList());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           <span class="keyword">if</span> (isNetworkConnectException(e)) &#123;</span><br><span class="line">               logNetworkErrorSample(<span class="keyword">null</span>, e);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.TransientError;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               logger.error(<span class="string">"Not re-trying this exception because it does not seem to be a network exception"</span>, e);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.PermanentError;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ProcessingResult.Success;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>批处理任务，将一组任务一次性发送到远程进行处理</p><ol><li>根据task集合创建ReplicationList</li><li>调用批量同步接口将同步集合发送到远端节点同步数据 即调用rest API /{version}/peerreplication</li><li>分析远程返回结果</li></ol></blockquote><hr><blockquote><p><strong>eureka 服务端 集群节点发现，数据同步功能主要是由PeerEurekaNodes与PeerEurekaNode类实现,通过源码的跟踪可以清晰看出集群实现的逻辑，方便在实际应用中对问题的定位</strong></p></blockquote>]]></content>
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/08/23/hello-world/"/>
      <url>/2018/08/23/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
