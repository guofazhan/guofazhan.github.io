<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Eureka Server之注册服务实例租约信息管理LeaseManager</title>
      <link href="/2018/09/04/Eureka-Server%E4%B9%8B%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E7%A7%9F%E7%BA%A6%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86LeaseManager/"/>
      <url>/2018/09/04/Eureka-Server%E4%B9%8B%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E7%A7%9F%E7%BA%A6%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86LeaseManager/</url>
      <content type="html"><![CDATA[<blockquote><p>Eureka 注册中心服务端对注册进来的服务信息提供了一个基于时间的可用性管理(租约Lease)。通过此来管理注册服务的有效性<br><a id="more"></a></p></blockquote><h4 id="提供租约管理的包路径"><a href="#提供租约管理的包路径" class="headerlink" title="提供租约管理的包路径"></a>提供租约管理的包路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.netflix.eureka.lease</span><br></pre></td></tr></table></figure><h4 id="描述注册服务基于时间可用性"><a href="#描述注册服务基于时间可用性" class="headerlink" title="描述注册服务基于时间可用性"></a>描述注册服务基于时间可用性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例租约包装类，描述实例基于时间的可用性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lease</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例针对租约变化的动作类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">enum</span> Action &#123;</span><br><span class="line">        <span class="comment">//实例注册</span></span><br><span class="line">        Register,</span><br><span class="line">        <span class="comment">//实例取消</span></span><br><span class="line">        Cancel,</span><br><span class="line">        <span class="comment">//实例刷新</span></span><br><span class="line">        Renew</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的租约有效时长 90s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_DURATION_IN_SECS = <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例信息，此处默认为 InstanceInfo</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T holder;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消注册时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> evictionTimestamp;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> registrationTimestamp;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> serviceUpTimestamp;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最后更新时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// Make it volatile so that the expiration task would see this quicker</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastUpdateTimestamp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 租约的有效时长</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> durationInSecs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lease</span><span class="params">(T r, <span class="keyword">int</span> durationInSecs)</span> </span>&#123;</span><br><span class="line">        holder = r;</span><br><span class="line">        registrationTimestamp = System.currentTimeMillis();</span><br><span class="line">        lastUpdateTimestamp = registrationTimestamp;</span><br><span class="line">        duration = (durationInSecs * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>在Lease类中可以看到是使用了装饰模式对注册实例进行了包装，提供了基于时间可用性的新功能。</p><ul><li>enum Action  定义了租约时间变更的动作类型，此处包含注册，下线，刷新（心跳发送刷新租约信息）等三个动作</li><li>evictionTimestamp：服务下线时间</li><li>registrationTimestamp: 服务注册时间</li><li>lastUpdateTimestamp: 最后更新时间</li><li>duration : 租约的有效时长默认90s</li></ul></blockquote><blockquote><p>Lease类对实例InstanceInfo进行功能扩展的方法：</p></blockquote><ol><li><p>renew</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 刷新租约的时间信息，租约续订更新最后更新时间为当前时间+租约有效时长</span></span><br><span class="line"><span class="comment"> * Renew the lease, use renewal duration if it was specified by the</span></span><br><span class="line"><span class="comment"> * associated &#123;<span class="doctag">@link</span> T&#125; during registration, otherwise default duration is</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #DEFAULT_DURATION_IN_SECS&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">renew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lastUpdateTimestamp = System.currentTimeMillis() + duration;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>cancel</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册列表剔除当前服务，更新租约的时间信息</span></span><br><span class="line"><span class="comment"> * Cancels the lease by updating the eviction time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evictionTimestamp &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        evictionTimestamp = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>serviceUp</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务上线时间</span></span><br><span class="line"><span class="comment"> * Mark the service as up. This will only take affect the first time called,</span></span><br><span class="line"><span class="comment"> * subsequent calls will be ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (serviceUpTimestamp == <span class="number">0</span>) &#123;</span><br><span class="line">        serviceUpTimestamp = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>isExpired</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测租约是否过期</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">(<span class="keyword">long</span> additionalLeaseMs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//剔除服务时间&gt;0或当前时间&gt;（最后更新时间+租约有效时长+时间偏差）时 表示租约已失效</span></span><br><span class="line">    <span class="keyword">return</span> (evictionTimestamp &gt; <span class="number">0</span> || System.currentTimeMillis() &gt; (lastUpdateTimestamp + duration + additionalLeaseMs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>renew:针对动作Renew</li><li>cancel:针对动作cancel</li><li>serviceUp:针对动作Register</li><li>isExpired: 用于校验当前实例的租约是否有效，对外提供服务可用性的检测</li></ol></blockquote><h4 id="注册服务基于时间可用性管理"><a href="#注册服务基于时间可用性管理" class="headerlink" title="注册服务基于时间可用性管理"></a>注册服务基于时间可用性管理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例租约管理接口，根据租约更新的动作类型操作实例的租约信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LeaseManager</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册实例，更新实例租约信息</span></span><br><span class="line"><span class="comment">     * Assign a new &#123;<span class="doctag">@link</span> Lease&#125; to the passed in &#123;<span class="doctag">@link</span> T&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(T r, <span class="keyword">int</span> leaseDuration, <span class="keyword">boolean</span> isReplication)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 剔除实例时，更新实例租约信息</span></span><br><span class="line"><span class="comment">     * Cancel the &#123;<span class="doctag">@link</span> Lease&#125; associated w/ the passed in &lt;code&gt;appName&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * and &lt;code&gt;id&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 刷新实例时更新实例租约信息</span></span><br><span class="line"><span class="comment">     * Renew the &#123;<span class="doctag">@link</span> Lease&#125; associated w/ the passed in &lt;code&gt;appName&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * and &lt;code&gt;id&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 剔除已过期的租约实例信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">evict</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>LeaseManager接口用于提供服务实例基于时间可控性的管理（租约管理），提供以下功能：</p><ol><li>register ： 服务注册进来设置租约的serviceUp</li><li>cancel : 服务下线，设置实例租约的cancel</li><li>renew ： 服务报活（心跳检测）设置租约的renew</li><li>evict : 遍历注册表通过实例租约isExpired方法校验是否过期，过期强制服务下线操作</li></ol></blockquote><blockquote><p>其中 1-3 是Eureka 客户端发起操作，4,为服务端定时任务轮询服务注册表，主动剔除过期实例。</p></blockquote><blockquote><p>LeaseManager默认实现类 AbstractInstanceRegistry</p></blockquote><ol><li>register</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册实例，更新实例租约信息</span></span><br><span class="line"><span class="comment">     * Registers a new instance with a given duration.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(InstanceInfo registrant, <span class="keyword">int</span> leaseDuration, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            read.lock();</span><br><span class="line">            <span class="comment">//注册表中查询当前注册服务的集群列表信息</span></span><br><span class="line">            Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(registrant.getAppName());</span><br><span class="line">            REGISTER.increment(isReplication);</span><br><span class="line">            <span class="keyword">if</span> (gMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//集群不存在时，创建一个新的空集群并添加到注册表</span></span><br><span class="line">                <span class="keyword">final</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt; gNewMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt;();</span><br><span class="line">                gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap);</span><br><span class="line">                <span class="keyword">if</span> (gMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    gMap = gNewMap;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在集群列表中根据服务ID查询实例信息</span></span><br><span class="line">            Lease&lt;InstanceInfo&gt; existingLease = gMap.get(registrant.getId());</span><br><span class="line">            <span class="comment">// Retain the last dirty timestamp without overwriting it, if there is already a lease</span></span><br><span class="line">            <span class="keyword">if</span> (existingLease != <span class="keyword">null</span> &amp;&amp; (existingLease.getHolder() != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="comment">//服务实例信息已存在与集群中</span></span><br><span class="line">                <span class="comment">//根据传入实例与已存在实例的LastDirtyTimestamp判断使用具体实例</span></span><br><span class="line">                Long existingLastDirtyTimestamp = existingLease.getHolder().getLastDirtyTimestamp();</span><br><span class="line">                Long registrationLastDirtyTimestamp = registrant.getLastDirtyTimestamp();</span><br><span class="line">                logger.debug(<span class="string">"Existing lease found (existing=&#123;&#125;, provided=&#123;&#125;"</span>, existingLastDirtyTimestamp, registrationLastDirtyTimestamp);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is a &gt; instead of a &gt;= because if the timestamps are equal, we still take the remote transmitted</span></span><br><span class="line">                <span class="comment">// InstanceInfo instead of the server local copy.</span></span><br><span class="line">                <span class="keyword">if</span> (existingLastDirtyTimestamp &gt; registrationLastDirtyTimestamp) &#123;</span><br><span class="line">                    registrant = existingLease.getHolder();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//服务实例信息不存在与集群中</span></span><br><span class="line">                <span class="comment">// The lease does not exist and hence it is a new registration</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// Since the client wants to cancel it, reduce the threshold</span></span><br><span class="line">                        <span class="comment">// (1</span></span><br><span class="line">                        <span class="comment">// for 30 seconds, 2 for a minute)</span></span><br><span class="line">                        <span class="keyword">this</span>.expectedNumberOfRenewsPerMin = <span class="keyword">this</span>.expectedNumberOfRenewsPerMin + <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">this</span>.numberOfRenewsPerMinThreshold =</span><br><span class="line">                                (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                logger.debug(<span class="string">"No previous lease information found; it is new registration"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据服务实例信息构建新的租约实例信息</span></span><br><span class="line">            Lease&lt;InstanceInfo&gt; lease = <span class="keyword">new</span> Lease&lt;InstanceInfo&gt;(registrant, leaseDuration);</span><br><span class="line">            <span class="keyword">if</span> (existingLease != <span class="keyword">null</span>) &#123;</span><br><span class="line">                lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//添加服务实例到集群列表</span></span><br><span class="line">            gMap.put(registrant.getId(), lease);</span><br><span class="line">            <span class="keyword">synchronized</span> (recentRegisteredQueue) &#123;</span><br><span class="line">                <span class="comment">//新注册队列中添加当前注册的信息</span></span><br><span class="line">                recentRegisteredQueue.add(<span class="keyword">new</span> Pair&lt;Long, String&gt;(</span><br><span class="line">                        System.currentTimeMillis(),</span><br><span class="line">                        registrant.getAppName() + <span class="string">"("</span> + registrant.getId() + <span class="string">")"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断重载状态</span></span><br><span class="line">            <span class="comment">// This is where the initial state transfer of overridden status happens</span></span><br><span class="line">            <span class="keyword">if</span> (!InstanceStatus.UNKNOWN.equals(registrant.getOverriddenStatus())) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Found overridden status &#123;&#125; for instance &#123;&#125;. Checking to see if needs to be add to the "</span></span><br><span class="line">                                + <span class="string">"overrides"</span>, registrant.getOverriddenStatus(), registrant.getId());</span><br><span class="line">                <span class="keyword">if</span> (!overriddenInstanceStatusMap.containsKey(registrant.getId())) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Not found overridden id &#123;&#125; and hence adding it"</span>, registrant.getId());</span><br><span class="line">                    <span class="comment">//将当前服务实例的重载状态添加到重载状态MAP集合中</span></span><br><span class="line">                    overriddenInstanceStatusMap.put(registrant.getId(), registrant.getOverriddenStatus());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取当前实例的重载状态</span></span><br><span class="line">            InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(registrant.getId());</span><br><span class="line">            <span class="keyword">if</span> (overriddenStatusFromMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.info(<span class="string">"Storing overridden status &#123;&#125; from map"</span>, overriddenStatusFromMap);</span><br><span class="line">                <span class="comment">//设置服务的重载状态</span></span><br><span class="line">                registrant.setOverriddenStatus(overriddenStatusFromMap);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//基于状态规则重新设置状态</span></span><br><span class="line">            <span class="comment">// Set the status based on the overridden status rules</span></span><br><span class="line">            InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(registrant, existingLease, isReplication);</span><br><span class="line">            registrant.setStatusWithoutDirty(overriddenInstanceStatus);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断服务注册状态，当状态为UP 更新租约信息</span></span><br><span class="line">            <span class="comment">// If the lease is registered with UP status, set lease service up timestamp</span></span><br><span class="line">            <span class="keyword">if</span> (InstanceStatus.UP.equals(registrant.getStatus())) &#123;</span><br><span class="line">                lease.serviceUp();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置服务实例的动作类型为ADD</span></span><br><span class="line">            registrant.setActionType(ActionType.ADDED);</span><br><span class="line">            <span class="comment">//将服务添加到最近的改变队列</span></span><br><span class="line">            recentlyChangedQueue.add(<span class="keyword">new</span> RecentlyChangedItem(lease));</span><br><span class="line">            <span class="comment">//设置服务最后更新时间</span></span><br><span class="line">            registrant.setLastUpdatedTimestamp();</span><br><span class="line">            <span class="comment">//校验缓存信息</span></span><br><span class="line">            invalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress());</span><br><span class="line">            logger.info(<span class="string">"Registered instance &#123;&#125;/&#123;&#125; with status &#123;&#125; (replication=&#123;&#125;)"</span>,</span><br><span class="line">                    registrant.getAppName(), registrant.getId(), registrant.getStatus(), isReplication);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            read.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>cancel</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据集群ID ，服务实例ID剔除集群中服务信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">internalCancel</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           read.lock();</span><br><span class="line">           CANCEL.increment(isReplication);</span><br><span class="line">           <span class="comment">//注册表中获取集群信息列表</span></span><br><span class="line">           Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</span><br><span class="line">           Lease&lt;InstanceInfo&gt; leaseToCancel = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//在就集群列表中根据服务ID移除服务</span></span><br><span class="line">               leaseToCancel = gMap.remove(id);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">synchronized</span> (recentCanceledQueue) &#123;</span><br><span class="line">               <span class="comment">//添加最近下线队列，将当前的下线信息</span></span><br><span class="line">               recentCanceledQueue.add(<span class="keyword">new</span> Pair&lt;Long, String&gt;(System.currentTimeMillis(), appName + <span class="string">"("</span> + id + <span class="string">")"</span>));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//重载实例状态map集合中移除当前的实例的重载状态</span></span><br><span class="line">           InstanceStatus instanceStatus = overriddenInstanceStatusMap.remove(id);</span><br><span class="line">           <span class="keyword">if</span> (instanceStatus != <span class="keyword">null</span>) &#123;</span><br><span class="line">               logger.debug(<span class="string">"Removed instance id &#123;&#125; from the overridden map which has value &#123;&#125;"</span>, id, instanceStatus.name());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (leaseToCancel == <span class="keyword">null</span>) &#123;</span><br><span class="line">               CANCEL_NOT_FOUND.increment(isReplication);</span><br><span class="line">               logger.warn(<span class="string">"DS: Registry: cancel failed because Lease is not registered for: &#123;&#125;/&#123;&#125;"</span>, appName, id);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//调用租约实例的下线方法，变更租约信息</span></span><br><span class="line">               leaseToCancel.cancel();</span><br><span class="line">               <span class="comment">//获取实例信息</span></span><br><span class="line">               InstanceInfo instanceInfo = leaseToCancel.getHolder();</span><br><span class="line">               String vip = <span class="keyword">null</span>;</span><br><span class="line">               String svip = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> (instanceInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">//设置实例操作类型为DELETED</span></span><br><span class="line">                   instanceInfo.setActionType(ActionType.DELETED);</span><br><span class="line">                   <span class="comment">//最近变更队列中添加当前实例信息</span></span><br><span class="line">                   recentlyChangedQueue.add(<span class="keyword">new</span> RecentlyChangedItem(leaseToCancel));</span><br><span class="line">                   <span class="comment">//更新实例的最后更新时间</span></span><br><span class="line">                   instanceInfo.setLastUpdatedTimestamp();</span><br><span class="line">                   vip = instanceInfo.getVIPAddress();</span><br><span class="line">                   svip = instanceInfo.getSecureVipAddress();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//校验缓存信息</span></span><br><span class="line">               invalidateCache(appName, vip, svip);</span><br><span class="line">               logger.info(<span class="string">"Cancelled instance &#123;&#125;/&#123;&#125; (replication=&#123;&#125;)"</span>, appName, id, isReplication);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           read.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>renew</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 刷新实例时更新实例租约信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">        RENEW.increment(isReplication);</span><br><span class="line">        <span class="comment">//获取集群列表</span></span><br><span class="line">        Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</span><br><span class="line">        Lease&lt;InstanceInfo&gt; leaseToRenew = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//集群列表中查询实例信息</span></span><br><span class="line">            leaseToRenew = gMap.get(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leaseToRenew == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RENEW_NOT_FOUND.increment(isReplication);</span><br><span class="line">            logger.warn(<span class="string">"DS: Registry: lease doesn't exist, registering resource: &#123;&#125; - &#123;&#125;"</span>, appName, id);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获取实例信息</span></span><br><span class="line">            InstanceInfo instanceInfo = leaseToRenew.getHolder();</span><br><span class="line">            <span class="keyword">if</span> (instanceInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// touchASGCache(instanceInfo.getASGName());</span></span><br><span class="line">                <span class="comment">//基于状态规则重新设置状态</span></span><br><span class="line">                InstanceStatus overriddenInstanceStatus = <span class="keyword">this</span>.getOverriddenInstanceStatus(</span><br><span class="line">                        instanceInfo, leaseToRenew, isReplication);</span><br><span class="line">                <span class="keyword">if</span> (overriddenInstanceStatus == InstanceStatus.UNKNOWN) &#123;</span><br><span class="line">                    RENEW_NOT_FOUND.increment(isReplication);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) &#123;</span><br><span class="line">                    Object[] args = &#123;</span><br><span class="line">                            instanceInfo.getStatus().name(),</span><br><span class="line">                            instanceInfo.getOverriddenStatus().name(),</span><br><span class="line">                            instanceInfo.getId()</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">//设置实例状态</span></span><br><span class="line">                    instanceInfo.setStatusWithoutDirty(overriddenInstanceStatus);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            renewsLastMin.increment();</span><br><span class="line">            <span class="comment">//租约刷新</span></span><br><span class="line">            leaseToRenew.renew();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>evict</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 剔除已过期的租约实例信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> additionalLeaseMs</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">(<span class="keyword">long</span> additionalLeaseMs)</span> </span>&#123;</span><br><span class="line">       logger.debug(<span class="string">"Running the evict task"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!isLeaseExpirationEnabled()) &#123;</span><br><span class="line">           logger.debug(<span class="string">"DS: lease expiration is currently disabled."</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// We collect first all expired items, to evict them in random order. For large eviction sets,</span></span><br><span class="line">       <span class="comment">// if we do not that, we might wipe out whole apps before self preservation kicks in. By randomizing it,</span></span><br><span class="line">       <span class="comment">// the impact should be evenly distributed across all applications.</span></span><br><span class="line">       List&lt;Lease&lt;InstanceInfo&gt;&gt; expiredLeases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="comment">//在注册表中查询租约过期的实例列表</span></span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; groupEntry : registry.entrySet()) &#123;</span><br><span class="line">           Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseMap = groupEntry.getValue();</span><br><span class="line">           <span class="keyword">if</span> (leaseMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseEntry : leaseMap.entrySet()) &#123;</span><br><span class="line">                   Lease&lt;InstanceInfo&gt; lease = leaseEntry.getValue();</span><br><span class="line">                   <span class="comment">//lease.isExpired() 判断租约是否过期</span></span><br><span class="line">                   <span class="keyword">if</span> (lease.isExpired(additionalLeaseMs) &amp;&amp; lease.getHolder() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       expiredLeases.add(lease);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// To compensate for GC pauses or drifting local time, we need to use current registry size as a base for</span></span><br><span class="line">       <span class="comment">// triggering self-preservation. Without that we would wipe out full registry.</span></span><br><span class="line">       <span class="comment">//获取本地注册表的大小</span></span><br><span class="line">       <span class="keyword">int</span> registrySize = (<span class="keyword">int</span>) getLocalRegistrySize();</span><br><span class="line">       <span class="comment">//注册表阈值，由registrySize * 配置百分比参数RenewalPercentThreshold</span></span><br><span class="line">       <span class="keyword">int</span> registrySizeThreshold = (<span class="keyword">int</span>) (registrySize * serverConfig.getRenewalPercentThreshold());</span><br><span class="line">       <span class="comment">//剔除租约过期的数量 由于RenewalPercentThreshold取值在0-1之间，当为1时，evictionLimit为0</span></span><br><span class="line">       <span class="comment">// 即toEvict为0，每次时不会进行对过期的租约服务下线操作，同时 evictionLimit &lt; expiredLeases.size() 时，</span></span><br><span class="line">       <span class="comment">// 每次操作不会将全部的过期租约实例下线</span></span><br><span class="line">       <span class="keyword">int</span> evictionLimit = registrySize - registrySizeThreshold;</span><br><span class="line">       <span class="comment">//在租约过期列表大小与每次剔除配置大小中取小值作为本地要剔除的服务实例数</span></span><br><span class="line">       <span class="keyword">int</span> toEvict = Math.min(expiredLeases.size(), evictionLimit);</span><br><span class="line">       <span class="keyword">if</span> (toEvict &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           logger.info(<span class="string">"Evicting &#123;&#125; items (expired=&#123;&#125;, evictionLimit=&#123;&#125;)"</span>, toEvict, expiredLeases.size(), evictionLimit);</span><br><span class="line">           Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">           <span class="comment">//遍历剔除服务</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; toEvict; i++) &#123;</span><br><span class="line">               <span class="comment">// Pick a random item (Knuth shuffle algorithm)</span></span><br><span class="line">               <span class="keyword">int</span> next = i + random.nextInt(expiredLeases.size() - i);</span><br><span class="line">               Collections.swap(expiredLeases, i, next);</span><br><span class="line">               Lease&lt;InstanceInfo&gt; lease = expiredLeases.get(i);</span><br><span class="line"></span><br><span class="line">               String appName = lease.getHolder().getAppName();</span><br><span class="line">               String id = lease.getHolder().getId();</span><br><span class="line">               EXPIRED.increment();</span><br><span class="line">               logger.warn(<span class="string">"DS: Registry: expired lease for &#123;&#125;/&#123;&#125;"</span>, appName, id);</span><br><span class="line">               <span class="comment">//调用下线服务方法</span></span><br><span class="line">               internalCancel(appName, id, <span class="keyword">false</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>AbstractInstanceRegistry类中保存这服务注册表信息，1-3方法为客户端主动发起请求到server端的resources模块，resource接受到客户端的请求，根据请求类型调用<br>AbstractInstanceRegistry中的1-3方法。</p></blockquote><blockquote><p>4 方法为服务端定时清除注册表中的租约过期实例；在AbstractInstanceRegistry类中如下实现：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      renewsLastMin.start();</span><br><span class="line">      <span class="keyword">if</span> (evictionTaskRef.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          evictionTaskRef.get().cancel();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//创建清除过期租约任务</span></span><br><span class="line">      evictionTaskRef.set(<span class="keyword">new</span> EvictionTask());</span><br><span class="line">      <span class="comment">//启动定时清除注册表中过期租约信息定时任务</span></span><br><span class="line">      evictionTimer.schedule(evictionTaskRef.get(),</span><br><span class="line">              serverConfig.getEvictionIntervalTimerInMs(),</span><br><span class="line">              serverConfig.getEvictionIntervalTimerInMs());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>postInit 初始化定时任务信息，执行定时清除租约过期任务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvictionTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong lastExecutionNanosRef = <span class="keyword">new</span> AtomicLong(<span class="number">0l</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> compensationTimeMs = getCompensationTimeMs();</span><br><span class="line">             </span><br><span class="line">                <span class="comment">// 执行租约管理方法evict</span></span><br><span class="line">                evict(compensationTimeMs);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                logger.error(<span class="string">"Could not run the evict task"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><blockquote><p>EvictionTask任务run方法中，执行租约管理的evict方法检测注册表中的过期租约实例，并对其进行下线操作。</p></blockquote><blockquote><p>至此，Eureka赋予了服务注册实例InstanceInfo的基于时间的可用性，并对实例提供了基于时间的可用性的管理。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Eureka之服务发现LookupService</title>
      <link href="/2018/08/28/Eureka%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0LookupService/"/>
      <url>/2018/08/28/Eureka%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0LookupService/</url>
      <content type="html"><![CDATA[<blockquote><p>Eureka 注册中心，核心为提供服务注册，以及服务发现功能，下面我们重点讨论下Eureka核心功能之一的服务发现。<br>我们知道Eureka采用的C-S架构，客户端要通过请求服务端获取注册列表，提供给服务使用，服务端要保存客户端发来的注册信息保存下（Eureka采用的是内存存储），并提供给资源服务Resources使用，有关资源服务可见Eureka之REST API<br><a id="more"></a></p></blockquote><h4 id="LookupService体系图"><a href="#LookupService体系图" class="headerlink" title="LookupService体系图"></a>LookupService体系图</h4><p><img src="https://github.com/guofazhan/image/blob/master/LookupService.png?raw=true" alt="image"></p><blockquote><ol><li>InstanceRegistry为Server端对资源服务提供服务发现功能的接口，用来读取服务端本地缓存注册表信息</li><li>EurekaClient 为Client端实现的服务发现接口，用来获取客户端本地缓存中的注册表信息</li><li>RemoteRegionRegistry 为Server用来读取其它区域的服务注册表的接口，并将其它区域的服务注册表缓存到本地，供本地InstanceRegistry使用。</li></ol></blockquote><h4 id="Eureka区域，分区"><a href="#Eureka区域，分区" class="headerlink" title="Eureka区域，分区"></a>Eureka区域，分区</h4><blockquote><p> eureka提供了region和zone两个概念来进行分区，这两个概念均来自于亚马逊的AWS：</p><ol><li>region：可以简单理解为地理上的分区，比如亚洲地区，或者华北地区，再或者北京等等，没有具体大小的限制。根据项目具体的情况，可以自行合理划分region。RemoteRegionRegistry就是其它分区的服务注册信息。</li><li>zone：可以简单理解为region内的具体机房，比如说region划分为北京，然后北京有两个机房，就可以在此region之下划分出zone1,zone2两个zone。</li></ol></blockquote><blockquote><p>RemoteRegionRegistry 根据配置实例化：         </p><ol><li>配置KEY： eureka.remoteRegionUrlsWithName   </li><li>格式： eureka.remoteRegionUrlsWithName=region1;<a href="http://region1host/eureka/v2,region2;http://region2host/eureka/v2" target="_blank" rel="noopener">http://region1host/eureka/v2,region2;http://region2host/eureka/v2</a></li><li>解析: regionName-&gt;remoteRegionURL 根据解析出来的MAP 创建相应的 RemoteRegionRegistry</li></ol></blockquote><blockquote><p><strong><em>备注：</em></strong> 一般中小行项目基本所有服务都部署在同一机房，不存在区域划分这些，即初始化时:RemoteRegionRegistry List为空,具体可参见AbstractInstanceRegistry的initRemoteRegionRegistry方法</p></blockquote><h4 id="LookupService类图以及实现"><a href="#LookupService类图以及实现" class="headerlink" title="LookupService类图以及实现"></a>LookupService类图以及实现</h4><p><img src="https://github.com/guofazhan/image/blob/master/LookupServiceUml.png?raw=true" alt="image"></p><h5 id="服务发现LookupService接口"><a href="#服务发现LookupService接口" class="headerlink" title="服务发现LookupService接口"></a>服务发现LookupService接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务发现接口</span></span><br><span class="line"><span class="comment"> * Lookup service for finding active instances.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Karthik Ranganathan, Greg Kim.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; for backward compatibility</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LookupService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据集群ID获取集群列表</span></span><br><span class="line"><span class="comment">     * Returns the corresponding &#123;<span class="doctag">@link</span> Application&#125; object which is basically a</span></span><br><span class="line"><span class="comment">     * container of all registered &lt;code&gt;appName&lt;/code&gt; &#123;<span class="doctag">@link</span> InstanceInfo&#125;s.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> appName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> Application&#125; or null if we couldn't locate any app of</span></span><br><span class="line"><span class="comment">     *         the requested appName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Application <span class="title">getApplication</span><span class="params">(String appName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取服务注册列表</span></span><br><span class="line"><span class="comment">     * Returns the &#123;<span class="doctag">@link</span> Applications&#125; object which is basically a container of</span></span><br><span class="line"><span class="comment">     * all currently registered &#123;<span class="doctag">@link</span> Application&#125;s.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Applications&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Applications <span class="title">getApplications</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据实例ID获取实例信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;InstanceInfo&gt; <span class="title">getInstancesById</span><span class="params">(String id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 轮询获取集群中的下一个可用的注册服务，起到负载均衡作用，保证每个可用注册服务均衡的被使用，此方法仅提供个Eureka 客户端使用实现，服务端默认为空实现</span></span><br><span class="line"><span class="comment">     * Gets the next possible server to process the requests from the registry</span></span><br><span class="line"><span class="comment">     * information received from eureka.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">InstanceInfo <span class="title">getNextServerFromEureka</span><span class="params">(String virtualHostname, <span class="keyword">boolean</span> secure)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>从接口可以看到提供了四个功能方法如下：</p><ol><li>getApplication:根据集群ID获取集群列表</li><li>getApplications:获取服务注册列表</li><li>getInstancesById:根据实例ID获取实例信息</li><li>getNextServerFromEureka:轮询获取集群中的下一个可用的注册服务，起到负载均衡作用，保证每个可用注册服务均衡的被使用，此方法仅提供个Eureka 客户端使用实现，服务端默认为空实现</li></ol></blockquote><h5 id="服务端实现AbstractInstanceRegistry"><a href="#服务端实现AbstractInstanceRegistry" class="headerlink" title="服务端实现AbstractInstanceRegistry"></a>服务端实现AbstractInstanceRegistry</h5><ol><li>缓存服务注册属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 服务注册表</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; registry</span><br><span class="line">         = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure><ol start="2"><li>其它区域服务发现集合属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 远程区域服务发现注册服务集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Map&lt;String, RemoteRegionRegistry&gt; regionNameVSRemoteRegistry = <span class="keyword">new</span> HashMap&lt;String, RemoteRegionRegistry&gt;();</span><br></pre></td></tr></table></figure><ol start="3"><li>getApplications功能方法实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取服务注册列表信息</span></span><br><span class="line"><span class="comment"> * Get all applications in this instance registry, falling back to other regions if allowed in the Eureka config.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the list of all known applications</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.netflix.discovery.shared.LookupService#getApplications()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Applications <span class="title">getApplications</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//配置参数，是否禁用远程区域的服务注册列表</span></span><br><span class="line">    <span class="keyword">boolean</span> disableTransparentFallback = serverConfig.disableTransparentFallbackToOtherRegion();</span><br><span class="line">    <span class="keyword">if</span> (disableTransparentFallback) &#123;</span><br><span class="line">        <span class="comment">//获取本地服务注册列表</span></span><br><span class="line">        <span class="keyword">return</span> getApplicationsFromLocalRegionOnly();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取服务注册列表在所有区域中，包含本地</span></span><br><span class="line">        <span class="keyword">return</span> getApplicationsFromAllRemoteRegions();  <span class="comment">// Behavior of falling back to remote region can be disabled.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获服务注册列表,在所有区域</span></span><br><span class="line"><span class="comment"> * Returns applications including instances from all remote regions. &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * Same as calling &#123;<span class="doctag">@link</span> #getApplicationsFromMultipleRegions(String[])&#125; with a &lt;code&gt;null&lt;/code&gt; argument.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Applications <span class="title">getApplicationsFromAllRemoteRegions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据区域信息获取服务注册列表，此处区域列表传入所有远程区域列表</span></span><br><span class="line">    <span class="keyword">return</span> getApplicationsFromMultipleRegions(allKnownRemoteRegions);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取本地服务注册列表</span></span><br><span class="line"><span class="comment"> * Returns applications including instances from local region only. &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * Same as calling &#123;<span class="doctag">@link</span> #getApplicationsFromMultipleRegions(String[])&#125; with an empty array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Applications <span class="title">getApplicationsFromLocalRegionOnly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据区域信息获取服务注册列表，此处区域列表传入空值</span></span><br><span class="line">    <span class="keyword">return</span> getApplicationsFromMultipleRegions(EMPTY_STR_ARRAY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据区域信息查询服务注册列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Applications <span class="title">getApplicationsFromMultipleRegions</span><span class="params">(String[] remoteRegions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否根据远程区域查询服务注册列表标识</span></span><br><span class="line">    <span class="keyword">boolean</span> includeRemoteRegion = <span class="keyword">null</span> != remoteRegions &amp;&amp; remoteRegions.length != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    logger.debug(<span class="string">"Fetching applications registry with remote regions: &#123;&#125;, Regions argument &#123;&#125;"</span>,</span><br><span class="line">            includeRemoteRegion, Arrays.toString(remoteRegions));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录统计监控数据</span></span><br><span class="line">    <span class="keyword">if</span> (includeRemoteRegion) &#123;</span><br><span class="line">        GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS.increment();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        GET_ALL_CACHE_MISS.increment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建服务注册列表实例信息</span></span><br><span class="line">    Applications apps = <span class="keyword">new</span> Applications();</span><br><span class="line">    apps.setVersion(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">//加入本地注册信息到服务注册列表实例中</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; entry : registry.entrySet()) &#123;</span><br><span class="line">        Application app = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; stringLeaseEntry : entry.getValue().entrySet()) &#123;</span><br><span class="line">                Lease&lt;InstanceInfo&gt; lease = stringLeaseEntry.getValue();</span><br><span class="line">                <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    app = <span class="keyword">new</span> Application(lease.getHolder().getAppName());</span><br><span class="line">                &#125;</span><br><span class="line">                app.addInstance(decorateInstanceInfo(lease));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            apps.addApplication(app);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否加入远程区域的注册信息</span></span><br><span class="line">    <span class="keyword">if</span> (includeRemoteRegion) &#123;</span><br><span class="line">        <span class="comment">//遍历远程区域，添加远程区域的注册信息到服务注册列表实例</span></span><br><span class="line">        <span class="keyword">for</span> (String remoteRegion : remoteRegions) &#123;</span><br><span class="line">            RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != remoteRegistry) &#123;</span><br><span class="line">                Applications remoteApps = remoteRegistry.getApplications();</span><br><span class="line">                <span class="keyword">for</span> (Application application : remoteApps.getRegisteredApplications()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) &#123;</span><br><span class="line">                        logger.info(<span class="string">"Application &#123;&#125;  fetched from the remote region &#123;&#125;"</span>,</span><br><span class="line">                                application.getName(), remoteRegion);</span><br><span class="line"></span><br><span class="line">                        Application appInstanceTillNow = apps.getRegisteredApplications(application.getName());</span><br><span class="line">                        <span class="keyword">if</span> (appInstanceTillNow == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            appInstanceTillNow = <span class="keyword">new</span> Application(application.getName());</span><br><span class="line">                            apps.addApplication(appInstanceTillNow);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (InstanceInfo instanceInfo : application.getInstances()) &#123;</span><br><span class="line">                            appInstanceTillNow.addInstance(instanceInfo);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        logger.debug(<span class="string">"Application &#123;&#125; not fetched from the remote region &#123;&#125; as there exists a "</span></span><br><span class="line">                                        + <span class="string">"whitelist and this app is not in the whitelist."</span>,</span><br><span class="line">                                application.getName(), remoteRegion);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(<span class="string">"No remote registry available for the remote region &#123;&#125;"</span>, remoteRegion);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置实例的hashCode</span></span><br><span class="line">    apps.setAppsHashCode(apps.getReconcileHashCode());</span><br><span class="line">    <span class="keyword">return</span> apps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>getApplications功能主要由以下方法完成：</p><ol><li>getApplications : 此方法根据配置参数信息，判断是只从本地缓存中获取注册列表(getApplicationsFromLocalRegionOnly)还是从所以区域获取注册列表(getApplicationsFromAllRemoteRegions)，参数信息：disableTransparentFallback</li><li>getApplicationsFromLocalRegionOnly :获取本地缓存中的注册表信息，调用getApplicationsFromMultipleRegions传入空区域集合</li><li>getApplicationsFromAllRemoteRegions : 从所有区域查找注册表信息，传入全部区域集合。</li><li>getApplicationsFromMultipleRegions ：根据传入区域信息查询注册表信息</li></ol></blockquote><blockquote><p> getApplicationsFromMultipleRegions完成如下功能:</p><ol><li>构建空注册表实例：Applications</li><li>添加本地缓存的注册信息到Applications</li><li>判断是否查找其它区域</li><li>遍历其它区域RemoteRegionRegistry获取Applications</li><li>添加其它区域中注册的信息到Applications（剔除重复的）</li><li>设置apps的hashCode 用于增量更新</li></ol></blockquote><ol start="4"><li>getApplications功能方法实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据服务集群ID，查询服务集群列表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> appName the application name of the application</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the application</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.netflix.discovery.shared.LookupService#getApplication(java.lang.String)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">getApplication</span><span class="params">(String appName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取配置信息</span></span><br><span class="line">    <span class="comment">//配置参数，是否禁用远程区域的服务注册列表</span></span><br><span class="line">    <span class="keyword">boolean</span> disableTransparentFallback = serverConfig.disableTransparentFallbackToOtherRegion();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getApplication(appName, !disableTransparentFallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据服务集群ID，查询服务集群列表</span></span><br><span class="line"><span class="comment"> * Get application information.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the application</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">getApplication</span><span class="params">(String appName, <span class="keyword">boolean</span> includeRemoteRegion)</span> </span>&#123;</span><br><span class="line">    Application app = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取本地注册列表中的服务集群信息</span></span><br><span class="line">    Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseMap = registry.get(appName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leaseMap != <span class="keyword">null</span> &amp;&amp; leaseMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//构建集群实例Application</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; entry : leaseMap.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">                app = <span class="keyword">new</span> Application(appName);</span><br><span class="line">            &#125;</span><br><span class="line">            app.addInstance(decorateInstanceInfo(entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (includeRemoteRegion) &#123;</span><br><span class="line">        <span class="comment">//包含远程区域时，通过远程区域注册服务查询集群信息</span></span><br><span class="line">        <span class="keyword">for</span> (RemoteRegionRegistry remoteRegistry : <span class="keyword">this</span>.regionNameVSRemoteRegistry.values()) &#123;</span><br><span class="line">            Application application = remoteRegistry.getApplication(appName);</span><br><span class="line">            <span class="keyword">if</span> (application != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> application;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回集群实例</span></span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>getApplication功能主要由以下方法完成：<br>getApplication ： 根据 集群名称以及参数是否禁用其它区域来获取集群列表Application</p><ol><li>通过本地缓存注册信息获取组装集群实例Application</li><li>当本地缓存中未查到集群信息且可用远程区域发现服务查询时，遍历远程区域发现服务查询集群信息组装<br>集群实例Application</li><li>返回集群实例Application</li></ol></blockquote><ol start="5"><li>getInstancesById功能方法实现<blockquote><p>与4功能类似</p></blockquote></li><li>getNextServerFromEureka功能方法实现<blockquote><p>空实现</p></blockquote></li></ol><h5 id="客户端实现DiscoveryClient"><a href="#客户端实现DiscoveryClient" class="headerlink" title="客户端实现DiscoveryClient"></a>客户端实现DiscoveryClient</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (non-Javadoc)</span></span><br><span class="line"><span class="comment"> * @see com.netflix.discovery.shared.LookupService#getApplication(java.lang.String)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">getApplication</span><span class="params">(String appName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getApplications().getRegisteredApplications(appName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (non-Javadoc)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see com.netflix.discovery.shared.LookupService#getApplications()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Applications <span class="title">getApplications</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> localRegionApps.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (non-Javadoc)</span></span><br><span class="line"><span class="comment"> * @see com.netflix.discovery.shared.LookupService#getInstancesById(java.lang.String)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;InstanceInfo&gt; <span class="title">getInstancesById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    List&lt;InstanceInfo&gt; instancesList = <span class="keyword">new</span> ArrayList&lt;InstanceInfo&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Application app : <span class="keyword">this</span>.getApplications()</span><br><span class="line">            .getRegisteredApplications()) &#123;</span><br><span class="line">        InstanceInfo instanceInfo = app.getByInstanceId(id);</span><br><span class="line">        <span class="keyword">if</span> (instanceInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            instancesList.add(instanceInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instancesList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在客户端的实现方法中可以清晰的看到是通过localRegionApps.get()获取服务注册列表实例，此实例是在本地缓存存储且为原子性的。下面我们主要查看localRegionApps是怎么加载以及更新</p></blockquote><ul><li>构造函数首次加载localRegionApps</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//通过fetchRegistry方法首次从远程Server端获取注册列表缓存到客户端本地，默认选择增量拉取</span></span><br><span class="line"><span class="keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="keyword">false</span>)) &#123;</span><br><span class="line">    fetchRegistryFromBackup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在构造函数中调用fetchRegistry 首次初始化从服务端拉取服务注册实例并缓存到客户端内存中</p><ul><li>初始化定时任务，定时拉取服务端注册信息刷新本地缓存</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Initializes all scheduled tasks.</span><br><span class="line"> */</span><br><span class="line">private void initScheduledTasks() &#123;</span><br><span class="line">    //判断客户端远程拉取注册表禁用配置，true，标识客户端运行定时拉取远程注册表配置</span><br><span class="line">    if (clientConfig.shouldFetchRegistry()) &#123;</span><br><span class="line">        // registry cache refresh timer</span><br><span class="line">        int registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();</span><br><span class="line">        int expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();</span><br><span class="line">        //定时任务定时执行客户端远程拉取注册表来更新客户端本地缓存</span><br><span class="line">        scheduler.schedule(</span><br><span class="line">                new TimedSupervisorTask(</span><br><span class="line">                        &quot;cacheRefresh&quot;,</span><br><span class="line">                        scheduler,</span><br><span class="line">                        cacheRefreshExecutor,</span><br><span class="line">                        registryFetchIntervalSeconds,</span><br><span class="line">                        TimeUnit.SECONDS,</span><br><span class="line">                        expBackOffBound,</span><br><span class="line">                        new CacheRefreshThread()</span><br><span class="line">                ),</span><br><span class="line">                registryFetchIntervalSeconds, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line"> * 远程拉取Server端注册表信息更新客户端本地缓存，定时任务，客户端定时执行此任务</span><br><span class="line"> * The task that fetches the registry information at specified intervals.</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">class CacheRefreshThread implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        refreshRegistry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>构造函数初始化定时任务，调用initScheduledTasks</li><li>定时任务，初始化刷新服务注册表实例定时任务</li><li>CacheRefreshThread线程定时执行，调用refreshRegistry()方法从server端拉取注册信息并刷新本地缓存</li></ol></blockquote><ul><li>fetchRegistry功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端拉取Eureka Server服务注册列表，本地缓存 (forceFullRegistryFetch 是否全量拉取标识)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">fetchRegistry</span><span class="params">(<span class="keyword">boolean</span> forceFullRegistryFetch)</span> </span>&#123;</span><br><span class="line">        Stopwatch tracer = FETCH_REGISTRY_TIMER.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// If the delta is disabled or if it is the first time, get all</span></span><br><span class="line">            <span class="comment">// applications</span></span><br><span class="line">            <span class="comment">//本地缓存中获取注册列表信息</span></span><br><span class="line">            Applications applications = getApplications();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断全量拉取还是增量拉取</span></span><br><span class="line">            <span class="keyword">if</span> (clientConfig.shouldDisableDelta()</span><br><span class="line">                    || (!Strings.isNullOrEmpty(clientConfig.getRegistryRefreshSingleVipAddress()))</span><br><span class="line">                    || forceFullRegistryFetch</span><br><span class="line">                    || (applications == <span class="keyword">null</span>)</span><br><span class="line">                    || (applications.getRegisteredApplications().size() == <span class="number">0</span>)</span><br><span class="line">                    || (applications.getVersion() == -<span class="number">1</span>)) <span class="comment">//Client application does not have latest library supporting delta</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//全量拉取注册表信息</span></span><br><span class="line">                getAndStoreFullRegistry();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//增量拉取注册表信息</span></span><br><span class="line">                getAndUpdateDelta(applications);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置hashCode，注册列表判断变化是根据hashCode</span></span><br><span class="line">            applications.setAppsHashCode(applications.getReconcileHashCode());</span><br><span class="line">            <span class="comment">//日志打印统计</span></span><br><span class="line">            logTotalInstances();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(PREFIX + appPathIdentifier + <span class="string">" - was unable to refresh its cache! status = "</span> + e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (tracer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                tracer.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通知缓存刷新事件</span></span><br><span class="line">        <span class="comment">// Notify about cache refresh before updating the instance remote status</span></span><br><span class="line">        onCacheRefreshed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新实例的远程状态</span></span><br><span class="line">        <span class="comment">// Update remote status based on refreshed data held in the cache</span></span><br><span class="line">        updateInstanceRemoteStatus();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// registry was fetched successfully, so return true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全量拉取Eureka Server端的注册列表信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAndStoreFullRegistry</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> currentUpdateGeneration = fetchRegistryGeneration.get();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"Getting all instance registry info from the eureka server"</span>);</span><br><span class="line"></span><br><span class="line">        Applications apps = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//通过远程通讯组件请求Server端获取全量注册列表</span></span><br><span class="line">        EurekaHttpResponse&lt;Applications&gt; httpResponse = clientConfig.getRegistryRefreshSingleVipAddress() == <span class="keyword">null</span></span><br><span class="line">                ? eurekaTransport.queryClient.getApplications(remoteRegionsRef.get())</span><br><span class="line">                : eurekaTransport.queryClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress(), remoteRegionsRef.get());</span><br><span class="line">        <span class="keyword">if</span> (httpResponse.getStatusCode() == Status.OK.getStatusCode()) &#123;</span><br><span class="line">            apps = httpResponse.getEntity();</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">"The response status is &#123;&#125;"</span>, httpResponse.getStatusCode());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (apps == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">"The application is null for some reason. Not storing this information"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//获取的注册列表缓存到本地</span></span><br><span class="line">            localRegionApps.set(<span class="keyword">this</span>.filterAndShuffle(apps));</span><br><span class="line">            logger.debug(<span class="string">"Got full registry with apps hashcode &#123;&#125;"</span>, apps.getAppsHashCode());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(<span class="string">"Not updating applications as another thread is updating it already"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增量拉取Eureka Server端的注册列表信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAndUpdateDelta</span><span class="params">(Applications applications)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> currentUpdateGeneration = fetchRegistryGeneration.get();</span><br><span class="line"></span><br><span class="line">        Applications delta = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//通过远程通讯组件请求Server端获取增量注册列表</span></span><br><span class="line">        EurekaHttpResponse&lt;Applications&gt; httpResponse = eurekaTransport.queryClient.getDelta(remoteRegionsRef.get());</span><br><span class="line">        <span class="keyword">if</span> (httpResponse.getStatusCode() == Status.OK.getStatusCode()) &#123;</span><br><span class="line">            delta = httpResponse.getEntity();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (delta == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">"The server does not allow the delta revision to be applied because it is not safe. "</span></span><br><span class="line">                    + <span class="string">"Hence got the full registry."</span>);</span><br><span class="line">            <span class="comment">//增量获取为空时，全量拉取</span></span><br><span class="line">            getAndStoreFullRegistry();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + <span class="number">1</span>)) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Got delta update with apps hashcode &#123;&#125;"</span>, delta.getAppsHashCode());</span><br><span class="line">            String reconcileHashCode = <span class="string">""</span>;</span><br><span class="line">            <span class="comment">//拉取注册表更新锁</span></span><br><span class="line">            <span class="keyword">if</span> (fetchRegistryUpdateLock.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//更新增量信息到本地缓存中的注册表中</span></span><br><span class="line">                    updateDelta(delta);</span><br><span class="line">                    <span class="comment">//获取更新后的HashCode</span></span><br><span class="line">                    reconcileHashCode = getReconcileHashCode(applications);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    fetchRegistryUpdateLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(<span class="string">"Cannot acquire update lock, aborting getAndUpdateDelta"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断本地的hashCode是否与远程hashCode一致，不一致时，需要同步一致</span></span><br><span class="line">            <span class="comment">// There is a diff in number of instances for some reason</span></span><br><span class="line">            <span class="keyword">if</span> (!reconcileHashCode.equals(delta.getAppsHashCode()) || clientConfig.shouldLogDeltaDiff()) &#123;</span><br><span class="line">                reconcileAndLogDifference(delta, reconcileHashCode);  <span class="comment">// this makes a remoteCall</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(<span class="string">"Not updating application delta as another thread is updating it already"</span>);</span><br><span class="line">            logger.debug(<span class="string">"Ignoring delta update with apps hashcode &#123;&#125;, as another thread is updating it already"</span>, delta.getAppsHashCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>fetchRegistry : 根据传入参数以及配置信息判断是否全量拉取还是增量拉取，全量拉取调用getAndStoreFullRegistry方法 ；增量拉取调用getAndUpdateDelta方法</li><li>getAndStoreFullRegistry：全量从Server拉取服务注册信息，更新本地缓存。此方法通过Eureka提供的远程通讯模块调用Server端暴露的Resources信息获取服务注册列表实例apps</li><li>getAndUpdateDelta ：增量从Server端拉取服务的增量注册信息，更新本地缓存实例。</li></ol></blockquote><h5 id="远程区域服务发现实现RemoteRegionRegistry"><a href="#远程区域服务发现实现RemoteRegionRegistry" class="headerlink" title="远程区域服务发现实现RemoteRegionRegistry"></a>远程区域服务发现实现RemoteRegionRegistry</h5><blockquote><p>与客户端实现方式基本一致，不在描述</p></blockquote><h4 id="客户端，服务端，远程区域服务端交互"><a href="#客户端，服务端，远程区域服务端交互" class="headerlink" title="客户端，服务端，远程区域服务端交互"></a>客户端，服务端，远程区域服务端交互</h4><p><img src="https://github.com/guofazhan/image/blob/master/LookupService1.png?raw=true" alt="image"></p><hr>]]></content>
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Eureka之远程通讯模块</title>
      <link href="/2018/08/25/Eureka%E4%B9%8B%E8%BF%9C%E7%A8%8B%E9%80%9A%E8%AE%AF%E6%A8%A1%E5%9D%97/"/>
      <url>/2018/08/25/Eureka%E4%B9%8B%E8%BF%9C%E7%A8%8B%E9%80%9A%E8%AE%AF%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<blockquote><p>Eureka 架构为C-S模式 同时支持S 集群 ，不可避免的在client-server、server-server之间是需要远程通讯的，上面已经知道，Eureka 提供是http协议rest api，下面通过源码源码分析学习下eureka 提供的远程通讯模块</p></blockquote><h4 id="提供远程通讯模块的包路径"><a href="#提供远程通讯模块的包路径" class="headerlink" title="提供远程通讯模块的包路径"></a>提供远程通讯模块的包路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.netflix.discovery.shared.transport</span><br></pre></td></tr></table></figure><h4 id="通讯模块对外的核心接口矩阵"><a href="#通讯模块对外的核心接口矩阵" class="headerlink" title="通讯模块对外的核心接口矩阵"></a>通讯模块对外的核心接口矩阵</h4><p><img src="https://github.com/guofazhan/image/blob/master/%E9%80%9A%E8%AE%AF%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3.png?raw=true" alt="image"></p><blockquote><ol><li>EurekaHttpClient 通讯请求接口，负责发送http请求</li><li>EurekaHttpClientFactory EurekaHttpClient创建工厂接口，负责创建高等级的client</li><li>TransportClientFactory EurekaHttpClient创建工厂接口，负责创建低等级的client</li><li>EurekaTransportConfig 通讯相关配置获取接口，负责在配置文件中读取通讯模块的配置信息</li></ol></blockquote><blockquote><p><strong>备注：</strong> EurekaHttpClientFactory与TransportClientFactory同样都是创建client工厂，不过两个的职责不一样，client按功能划分为两大类，下面详细介绍。<br><a id="more"></a></p></blockquote><h4 id="EurekaHttpClient"><a href="#EurekaHttpClient" class="headerlink" title="EurekaHttpClient"></a>EurekaHttpClient</h4><p><img src="https://github.com/guofazhan/image/blob/master/EurekaHttpClient.png?raw=true" alt="image"></p><blockquote><p>通过上图可以明确的看出EurekaHttpClient接口实现为两大类:</p><ol><li>实现http通讯的lowlevel实现；</li><li>使用装饰器模式实现特定功能的top level实现 。</li></ol></blockquote><blockquote><p>low level实现：  Eureka 根据http client 实现了两个AbstractJerseyEurekaHttpClient与AbstractJersey2EurekaHttpClient的low level 实现。从上面可以看出，如果Jersey1与Jersey2都不满足我们的自己的需求的话，我也可以根据自己需要的httpClient实现替代类，例如实现以OKhttp作为底层通讯的OkHttpEurekaHttpClient 或实现以netty作为底层通讯的NettyEurekaHttpClient，</p></blockquote><blockquote><p>top level实现 ： 通过装饰器模式eueka 内置了 响应指标采集功能的装饰器、失败重试功能装饰器等，同时我们也可以扩展。</p></blockquote><blockquote><p><strong> 备注：</strong> HttpReplicationClient是eureka 专为server端集群节点通讯提供的通讯接口。其本质low level</p></blockquote><ul><li>EurekaHttpClient接口方法</li></ul><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>register(InstanceInfo info)</td><td>服务注册</td></tr><tr><td>cancel(String appName, String id)</td><td>服务下线</td></tr><tr><td>sendHeartBeat</td><td>服务续约</td></tr><tr><td>statusUpdate</td><td>服务状态更新</td></tr><tr><td>deleteStatusOverride</td><td></td></tr><tr><td>getApplications(String… regions)</td><td>获取服务注册列表</td></tr><tr><td>getDelta(String… regions)</td><td>获取增量列表</td></tr><tr><td>getVip(String vipAddress, String… regions)</td><td>根据vip获取列表</td></tr><tr><td>getSecureVip(String secureVipAddress, String… regions)</td><td>根据svip获取列表</td></tr><tr><td>getApplication(String appName)</td><td>根据集群ID获取服务集群列表</td></tr><tr><td>getInstance(String appName, String id)</td><td>根据集群ID与服务ID获取服务</td></tr><tr><td>getInstance(String id)</td><td>根据服务ID获取服务</td></tr></tbody></table><ul><li>HttpReplicationClient接口方法 (server 节点数据同步特有)</li></ul><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>statusUpdate(String asgName, ASGStatus newStatus)</td><td>状态更新同步</td></tr><tr><td>submitBatchUpdates(ReplicationList replicationList)</td><td>批量执行更新同步任务</td></tr></tbody></table><h4 id="EurekaTransportConfig通讯配置新获取"><a href="#EurekaTransportConfig通讯配置新获取" class="headerlink" title="EurekaTransportConfig通讯配置新获取"></a>EurekaTransportConfig通讯配置新获取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * eureka 远程通讯客户端配置默认实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> David Liu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEurekaTransportConfig</span> <span class="keyword">implements</span> <span class="title">EurekaTransportConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUB_NAMESPACE = TRANSPORT_CONFIG_SUB_NAMESPACE + <span class="string">"."</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namespace;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DynamicPropertyFactory configInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEurekaTransportConfig</span><span class="params">(String parentNamespace, DynamicPropertyFactory configInstance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.namespace = parentNamespace == <span class="keyword">null</span></span><br><span class="line">                ? SUB_NAMESPACE</span><br><span class="line">                : (parentNamespace.endsWith(<span class="string">"."</span>)</span><br><span class="line">                    ? parentNamespace + SUB_NAMESPACE</span><br><span class="line">                    : parentNamespace + <span class="string">"."</span> + SUB_NAMESPACE);</span><br><span class="line">        <span class="keyword">this</span>.configInstance = configInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSessionedClientReconnectIntervalSeconds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInstance.getIntProperty(namespace + SESSION_RECONNECT_INTERVAL_KEY, Values.SESSION_RECONNECT_INTERVAL).get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>1.构建函数创建 DynamicPropertyFactory</p><ol start="2"><li>构建函数 初始化namespace 配置key的前缀</li><li>获取配置信息通过DynamicPropertyFactory 动态在配置文件中获取</li></ol></blockquote><h4 id="EurekaHttpClients-工具类"><a href="#EurekaHttpClients-工具类" class="headerlink" title="EurekaHttpClients 工具类"></a>EurekaHttpClients 工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaHttpClients</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(EurekaHttpClients.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EurekaHttpClients</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EurekaHttpClientFactory <span class="title">queryClientFactory</span><span class="params">(ClusterResolver bootstrapResolver,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                             TransportClientFactory transportClientFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                             EurekaClientConfig clientConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                             EurekaTransportConfig transportConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                             InstanceInfo myInstanceInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                             ApplicationsResolver.ApplicationsSource applicationsSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClosableResolver queryResolver = transportConfig.useBootstrapResolverForQuery()</span><br><span class="line">                ? wrapClosable(bootstrapResolver)</span><br><span class="line">                : queryClientResolver(bootstrapResolver, transportClientFactory,</span><br><span class="line">                clientConfig, transportConfig, myInstanceInfo, applicationsSource);</span><br><span class="line">        <span class="keyword">return</span> canonicalClientFactory(EurekaClientNames.QUERY, transportConfig, queryResolver, transportClientFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EurekaHttpClientFactory <span class="title">registrationClientFactory</span><span class="params">(ClusterResolver bootstrapResolver,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                    TransportClientFactory transportClientFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                    EurekaTransportConfig transportConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> canonicalClientFactory(EurekaClientNames.REGISTRATION, transportConfig, bootstrapResolver, transportClientFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> EurekaHttpClientFactory <span class="title">canonicalClientFactory</span><span class="params">(<span class="keyword">final</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                          <span class="keyword">final</span> EurekaTransportConfig transportConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                          <span class="keyword">final</span> ClusterResolver&lt;EurekaEndpoint&gt; clusterResolver,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                          <span class="keyword">final</span> TransportClientFactory transportClientFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EurekaHttpClientFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> EurekaHttpClient <span class="title">newClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SessionedEurekaHttpClient(</span><br><span class="line">                        name,</span><br><span class="line">                        RetryableEurekaHttpClient.createFactory(</span><br><span class="line">                                name,</span><br><span class="line">                                transportConfig,</span><br><span class="line">                                clusterResolver,</span><br><span class="line">                                RedirectingEurekaHttpClient.createFactory(transportClientFactory),</span><br><span class="line">                                ServerStatusEvaluators.legacyEvaluator()),</span><br><span class="line">                        transportConfig.getSessionedClientReconnectIntervalSeconds() * <span class="number">1000</span></span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                wrapClosable(clusterResolver).shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>EurekaHttpClients，是创建EurekaHttpClientFactory的工具类</p></blockquote><h4 id="EurekaHttpClient-Low-Level部分"><a href="#EurekaHttpClient-Low-Level部分" class="headerlink" title="EurekaHttpClient Low Level部分"></a>EurekaHttpClient Low Level部分</h4><ul><li>JerseyEurekaHttpClientFactory</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JerseyEurekaHttpClientFactory</span> <span class="keyword">implements</span> <span class="title">TransportClientFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTTP_X_DISCOVERY_ALLOW_REDIRECT = <span class="string">"X-Discovery-AllowRedirect"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaJerseyClient jerseyClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApacheHttpClient4 apacheClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApacheHttpClientConnectionCleaner cleaner;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; additionalHeaders;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JerseyEurekaHttpClientFactory</span><span class="params">(EurekaJerseyClient jerseyClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          ApacheHttpClient4 apacheClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">long</span> connectionIdleTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Map&lt;String, String&gt; additionalHeaders)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jerseyClient = jerseyClient;</span><br><span class="line">        <span class="keyword">this</span>.apacheClient = jerseyClient != <span class="keyword">null</span> ? jerseyClient.getClient() : apacheClient;</span><br><span class="line">        <span class="keyword">this</span>.additionalHeaders = additionalHeaders;</span><br><span class="line">        <span class="keyword">this</span>.cleaner = <span class="keyword">new</span> ApacheHttpClientConnectionCleaner(<span class="keyword">this</span>.apacheClient, connectionIdleTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务创建JerseyApplicationClient</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EurekaHttpClient <span class="title">newClient</span><span class="params">(EurekaEndpoint endpoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JerseyApplicationClient(apacheClient, endpoint.getServiceUrl(), additionalHeaders);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>JerseyEurekaHttpClientFactory 为TransportClientFactory的Jersey1实现主要负责创建JerseyEurekaHttpClient </p></blockquote><ul><li>AbstractJerseyEurekaHttpClient</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractJerseyEurekaHttpClient</span> <span class="keyword">implements</span> <span class="title">EurekaHttpClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbstractJerseyEurekaHttpClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * jersey1 http 客户端，负责底层发送http请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Client jerseyClient;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * server url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String serviceUrl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractJerseyEurekaHttpClient</span><span class="params">(Client jerseyClient, String serviceUrl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jerseyClient = jerseyClient;</span><br><span class="line">        <span class="keyword">this</span>.serviceUrl = serviceUrl;</span><br><span class="line">        logger.debug(<span class="string">"Created client for url: &#123;&#125;"</span>, serviceUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务注册</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> info</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">register</span><span class="params">(InstanceInfo info)</span> </span>&#123;</span><br><span class="line">        String urlPath = <span class="string">"apps/"</span> + info.getAppName();</span><br><span class="line">        ClientResponse response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过HTTP客户端发送http请求</span></span><br><span class="line">            Builder resourceBuilder = jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder();</span><br><span class="line">            addExtraHeaders(resourceBuilder);</span><br><span class="line">            <span class="comment">//构建响应结果</span></span><br><span class="line">            response = resourceBuilder</span><br><span class="line">                    .header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>)</span><br><span class="line">                    .type(MediaType.APPLICATION_JSON_TYPE)</span><br><span class="line">                    .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">                    .post(ClientResponse.class, info);</span><br><span class="line">            <span class="keyword">return</span> anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Jersey HTTP POST &#123;&#125;/&#123;&#125; with instance &#123;&#125;; statusCode=&#123;&#125;"</span>, serviceUrl, urlPath, info.getId(),</span><br><span class="line">                        response == <span class="keyword">null</span> ? <span class="string">"N/A"</span> : response.getStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>1.通过构建函数 可以看到传入一个jersey1 http 客户端</p><ol start="2"><li>register方法 实际是通过jersey1HttpClient发送http底层请求</li></ol></blockquote><blockquote><p>在这里可以看到AbstractJerseyEurekaHttpClient实际上是不做底层通讯的工作的，全部都是交由com.sun.jersey.api.client.Client处理的，这个是在创建工厂创建时设置到AbstractJerseyEurekaHttpClient中的</p></blockquote><blockquote><p><strong>备注:</strong> AbstractJersey2EurekaHttpClient与AbstractJerseyEurekaHttpClient的实现原理基本一样只是底层通讯的client不一致，后边不在描述</p></blockquote><h4 id="EurekaHttpClient-Top-Level部分"><a href="#EurekaHttpClient-Top-Level部分" class="headerlink" title="EurekaHttpClient Top Level部分"></a>EurekaHttpClient Top Level部分</h4><ul><li>EurekaHttpClientDecorator</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象Eureka远程通讯客户端装饰器，使用设计模式-装饰器模式 为客户端添加新的功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Tomasz Bak</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaHttpClientDecorator</span> <span class="keyword">implements</span> <span class="title">EurekaHttpClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> RequestType &#123;</span><br><span class="line">        <span class="comment">//注册</span></span><br><span class="line">        Register,</span><br><span class="line">        <span class="comment">//下线</span></span><br><span class="line">        Cancel,</span><br><span class="line">        <span class="comment">//心跳</span></span><br><span class="line">        SendHeartBeat,</span><br><span class="line">        <span class="comment">//状态更新</span></span><br><span class="line">        StatusUpdate,</span><br><span class="line">        DeleteStatusOverride,</span><br><span class="line">        GetApplications,</span><br><span class="line">        GetDelta,</span><br><span class="line">        GetVip,</span><br><span class="line">        GetSecureVip,</span><br><span class="line">        GetApplication,</span><br><span class="line">        GetInstance,</span><br><span class="line">        GetApplicationInstance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求执行接口，负责执行请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;R&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestExecutor</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行请求并返回响应信息</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> delegate 目标的客户端</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(EurekaHttpClient delegate)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 请求的类型</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">RequestType <span class="title">getRequestType</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象的执行方法，由子装饰器实现，附加其它功能</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestExecutor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;R&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;R&gt; <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个注册请求的执行器，并执行</span></span><br><span class="line">        <span class="keyword">return</span> execute(<span class="keyword">new</span> RequestExecutor&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">(EurekaHttpClient delegate)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> delegate.register(info);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> RequestType <span class="title">getRequestType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> RequestType.Register;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">cancel</span><span class="params">(<span class="keyword">final</span> String appName, <span class="keyword">final</span> String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个下线请求的执行，并执行</span></span><br><span class="line">        <span class="keyword">return</span> execute(<span class="keyword">new</span> RequestExecutor&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">(EurekaHttpClient delegate)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> delegate.cancel(appName, id);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> RequestType <span class="title">getRequestType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> RequestType.Cancel;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>基础的包装器 主要完成如下功能</p><ul><li>实现EurekaHttpClient接口每个基础方法，都有如下流程</li></ul><ol><li>创建一个请求执行接口</li><li>通过调用抽象的execute方法将RequestExecutor传入</li><li>子类在RequestExecutor执行前或后完成新功能的附加</li></ol></blockquote><ul><li>EurekaHttpClientDecorator实现</li></ul><table><thead><tr><th>实现类</th><th>描述</th></tr></thead><tbody><tr><td>MetricsCollectingEurekaHttpClient</td><td>实现请求响应状态指标采集的Eureka远程通讯客户端装饰器，为EurekaHttpClient添加响应状态指标采集向功能</td></tr><tr><td>RedirectingEurekaHttpClient</td><td>实现请求重定向的Eureka远程通讯客户端装饰器，为EurekaHttpClient添加请求重定向功能</td></tr><tr><td>RetryableEurekaHttpClient</td><td>实现请求失败重试的Eureka远程通讯客户端装饰器，为EurekaHttpClient添加失败重试功能</td></tr><tr><td>SessionedEurekaHttpClient</td><td>TODO</td></tr></tbody></table><hr><blockquote><p>从以上来看eureka 通讯模块结构和功能还是非常明了清晰，同时后期如果需要扩展，也是非常方便与快捷的</p></blockquote>]]></content>
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Eureka之REST API</title>
      <link href="/2018/08/23/Eureka%E4%B9%8BREST-API-1/"/>
      <url>/2018/08/23/Eureka%E4%B9%8BREST-API-1/</url>
      <content type="html"><![CDATA[<blockquote><p>Eureka服务端与客户之间的通讯方式为http，服务端通过提供rest API风格的接口与客户端或其它服务端交互。</p></blockquote><h4 id="交互数据格式"><a href="#交互数据格式" class="headerlink" title="交互数据格式"></a>交互数据格式</h4><blockquote><p>JSON/XML</p></blockquote><h4 id="提供资源服务的包路径"><a href="#提供资源服务的包路径" class="headerlink" title="提供资源服务的包路径"></a>提供资源服务的包路径</h4><blockquote><p><strong>com.netflix.eureka.resources</strong><br><a id="more"></a></p></blockquote><h4 id="提供可使用的REST-API接口"><a href="#提供可使用的REST-API接口" class="headerlink" title="提供可使用的REST API接口"></a>提供可使用的REST API接口</h4><blockquote><p><strong>/{version}/apps 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/apps.png?raw=true" alt="image"></p><blockquote><p><strong>/{version}/instances 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/rs.png?raw=true" alt="image"></p><blockquote><p><strong>/{version}/status 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/status.png?raw=true" alt="image"></p><blockquote><p><strong>/{version}/peerreplication 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/pree.png?raw=true" alt="image"></p><blockquote><p><strong>/{version}/vips 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/vip.png?raw=true" alt="image"></p><blockquote><p><strong>/{version}/svips 路径</strong></p></blockquote><p><img src="https://github.com/guofazhan/image/blob/master/svip.png?raw=true" alt="image"></p>]]></content>
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Eureka之服务注册数据模型</title>
      <link href="/2018/08/23/Eureka%E4%B9%8B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/08/23/Eureka%E4%B9%8B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<blockquote><p>Eureka 作为注册中心，担任着服务节点的注册以及发现，并提供着动态的管理（坏点摘除，服务检测等）。可以说是整个系统的基础设施。</p></blockquote><ul><li>注册列表的数据模型</li></ul><p><img src="https://github.com/guofazhan/image/blob/master/eureka%E6%B3%A8%E5%86%8C%E5%88%97%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B.png?raw=true" alt="image"><br><a id="more"></a><br><strong>1. Applications</strong></p><blockquote><p>注册列表，包含注册到当前注册中心上的所有实例信息，每个注册中心在内存中保持一份数据。在Applications中持有Application的队列</p></blockquote><p><strong>2. Application</strong></p><blockquote><p>注册到注册中心的服务集群信息，Application可以看做为一组对外提供相同服务的集群列表。在Application包含一组提供相同服务的InstanceInfo集合</p></blockquote><p><strong>3. InstanceInfo</strong></p><blockquote><p>注册列表里的单个服务实例信息，代表系统中提供一项服务的某个节点，里面包含节点的基础信息，以及唯一标识instanceId。</p></blockquote><p><strong>4. DataCenterInfo</strong></p><blockquote><p>服务实例所在的数据中心，默认为MyOwn，为InstanceInfo子属性</p></blockquote><p><strong>5. LeaseInfo</strong></p><blockquote><p>服务实例的租约信息，用于对服务做健康检查，续租，过期等服务可用性的管理。为InstanceInfo子属性</p></blockquote><hr><p>通过数据模型图可以清楚的看到Eureka将我们系统中的服务信息抽象成5个对象进行精细化的管理。我们注册进去的服务信息都将实例化成上述对象存储在eureka的服务端内存中，从而对外提供服务的注册以及发现。</p>]]></content>
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Eureka之server端集群节点发现，数据同步</title>
      <link href="/2018/08/23/Eureka%E4%B9%8Bserver%E7%AB%AF%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E5%8F%91%E7%8E%B0%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5-1/"/>
      <url>/2018/08/23/Eureka%E4%B9%8Bserver%E7%AB%AF%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E5%8F%91%E7%8E%B0%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5-1/</url>
      <content type="html"><![CDATA[<blockquote><p>Eureka服务端支持集群部署，通过源码查看集群节点发现以及数据同步功能的实现</p></blockquote><h4 id="提供集群功能的包路径"><a href="#提供集群功能的包路径" class="headerlink" title="提供集群功能的包路径"></a>提供集群功能的包路径</h4><blockquote><p>com.netflix.eureka.cluster</p></blockquote><h4 id="集群节点发现以及动态更新节点功能"><a href="#集群节点发现以及动态更新节点功能" class="headerlink" title="集群节点发现以及动态更新节点功能"></a>集群节点发现以及动态更新节点功能</h4><blockquote><p>Eureka服务端封装了一个集群节点管理的类名称为PeerEurekaNodes 通过名称翻译出来为对等的Eureka节点集合，可以看出这个类是对eureka服务端集群节点抽象，下面通过源码查询eureka是怎么管理与发现节点信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * eureka server 集群节点 集合类 帮助管理维护集群节点</span></span><br><span class="line"><span class="comment"> * Helper class to manage lifecycle of a collection of &#123;<span class="doctag">@link</span> PeerEurekaNode&#125;s.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Tomasz Bak</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeerEurekaNodes</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集群节点集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;PeerEurekaNode&gt; peerEurekaNodes = Collections.emptyList();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集群节点URL集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;String&gt; peerEurekaNodeUrls = Collections.emptySet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时任务线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ScheduledExecutorService taskExecutor;</span><br></pre></td></tr></table></figure><blockquote><p>通过PeerEurekaNodes类属性可以看到提供了两个集合以及一个执行定时任务的线程池，其它配置属性忽略</p><ol><li>peerEurekaNodes 表示集群节点集合</li><li>peerEurekaNodeUrls 表示集群节点对应的URL集合</li><li>taskExecutor 执行定时任务的线程池<a id="more"></a>同时 PeerEurekaNodes 类提供start 与shutdown方法，接下来主要看start方法的实现</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动方法，此方法管理集群节点间的通讯</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化定时任务线程池</span></span><br><span class="line">        taskExecutor = Executors.newSingleThreadScheduledExecutor(</span><br><span class="line">                <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                        Thread thread = <span class="keyword">new</span> Thread(r, <span class="string">"Eureka-PeerNodesUpdater"</span>);</span><br><span class="line">                        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> thread;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            updatePeerEurekaNodes(resolvePeerUrls());</span><br><span class="line">            <span class="comment">//节点更新任务线程</span></span><br><span class="line">            Runnable peersUpdateTask = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        updatePeerEurekaNodes(resolvePeerUrls());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        logger.error(<span class="string">"Cannot update the replica Nodes"</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。</span></span><br><span class="line"><span class="comment">//            如果任务的任一执行遇到异常，就会取消后续执行。否则，只能通过执行程序的取消或终止方法来终止该任务。</span></span><br><span class="line"><span class="comment">//            参数：</span></span><br><span class="line"><span class="comment">//            command - 要执行的任务</span></span><br><span class="line"><span class="comment">//            initialdelay - 首次执行的延迟时间</span></span><br><span class="line"><span class="comment">//            delay - 一次执行终止和下一次执行开始之间的延迟</span></span><br><span class="line"><span class="comment">//            unit - initialdelay 和 delay 参数的时间单位</span></span><br><span class="line">            <span class="comment">//定时执行节点更新任务线程</span></span><br><span class="line">            taskExecutor.scheduleWithFixedDelay(</span><br><span class="line">                    peersUpdateTask,</span><br><span class="line">                    serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</span><br><span class="line">                    serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</span><br><span class="line">                    TimeUnit.MILLISECONDS</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (PeerEurekaNode node : peerEurekaNodes) &#123;</span><br><span class="line">            logger.info(<span class="string">"Replica node URL:  "</span> + node.getServiceUrl());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>start 方法主要完成以下几件事</p><ol><li>初始化定时任务线程池</li><li>首次更新集群节点 updatePeerEurekaNodes方法</li><li>创建更新集群节点任务线程</li><li>通过定时任务线程池定时执行更新集群节点线程</li></ol></blockquote><blockquote><p>通过start 可以看出 eureka是通过一个定时线程定时去更新集群的节点信息达到对集群节点的动态发现和感知，在上面我们可以看到更新操作主要由updatePeerEurekaNodes方法完成，下面查看此方法的实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updatePeerEurekaNodes</span><span class="params">(List&lt;String&gt; newPeerUrls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newPeerUrls.isEmpty()) &#123;</span><br><span class="line">        logger.warn(<span class="string">"The replica size seems to be empty. Check the route 53 DNS Registry"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; toShutdown = <span class="keyword">new</span> HashSet&lt;&gt;(peerEurekaNodeUrls);</span><br><span class="line">    toShutdown.removeAll(newPeerUrls);</span><br><span class="line">    Set&lt;String&gt; toAdd = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</span><br><span class="line">    toAdd.removeAll(peerEurekaNodeUrls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验新的URL集合与旧有的URL集合是否一致，一致，不需要更新直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (toShutdown.isEmpty() &amp;&amp; toAdd.isEmpty()) &#123; <span class="comment">// No change</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove peers no long available</span></span><br><span class="line">    List&lt;PeerEurekaNode&gt; newNodeList = <span class="keyword">new</span> ArrayList&lt;&gt;(peerEurekaNodes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除旧集合中不可用的节点信息</span></span><br><span class="line">    <span class="keyword">if</span> (!toShutdown.isEmpty()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Removing no longer available peer nodes &#123;&#125;"</span>, toShutdown);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; newNodeList.size()) &#123;</span><br><span class="line">            PeerEurekaNode eurekaNode = newNodeList.get(i);</span><br><span class="line">            <span class="keyword">if</span> (toShutdown.contains(eurekaNode.getServiceUrl())) &#123;</span><br><span class="line">                newNodeList.remove(i);</span><br><span class="line">                eurekaNode.shutDown();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加新增加的节点信息</span></span><br><span class="line">    <span class="comment">// Add new peers</span></span><br><span class="line">    <span class="keyword">if</span> (!toAdd.isEmpty()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Adding new peer nodes &#123;&#125;"</span>, toAdd);</span><br><span class="line">        <span class="keyword">for</span> (String peerUrl : toAdd) &#123;</span><br><span class="line">            newNodeList.add(createPeerEurekaNode(peerUrl));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新赋值peerEurekaNodes与peerEurekaNodeUrls</span></span><br><span class="line">    <span class="keyword">this</span>.peerEurekaNodes = newNodeList;</span><br><span class="line">    <span class="keyword">this</span>.peerEurekaNodeUrls = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>updatePeerEurekaNodes根据传入的新集群URL集合完成节点的更新</p><ol><li>校验传入的URL集合是否需要更新</li><li>移除新url集合中没有的旧节点并关闭节点</li><li>创建旧节点集合中没有的新URL节点通过createPeerEurekaNode方法</li><li>重新赋值节点集合以及URL集合完成节点的更新</li></ol></blockquote><blockquote><p>updatePeerEurekaNodes传入的新URL集合是通过resolvePeerUrls方法获取，这个方法实际上是解析配置文件中的eureka.serviceUrl前缀的配置获取，并动态监听配置的更新。 创建新的节点是通过createPeerEurekaNode创建，下面查看此方法源码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据URL创建server新节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> peerEurekaNodeUrl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> PeerEurekaNode <span class="title">createPeerEurekaNode</span><span class="params">(String peerEurekaNodeUrl)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个连接远程节点的客户端</span></span><br><span class="line">    HttpReplicationClient replicationClient = JerseyReplicationClient.createReplicationClient(serverConfig, serverCodecs, peerEurekaNodeUrl);</span><br><span class="line">    <span class="comment">//获取新节点host信息</span></span><br><span class="line">    String targetHost = hostFromUrl(peerEurekaNodeUrl);</span><br><span class="line">    <span class="keyword">if</span> (targetHost == <span class="keyword">null</span>) &#123;</span><br><span class="line">        targetHost = <span class="string">"host"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建新节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PeerEurekaNode(registry, targetHost, peerEurekaNodeUrl, replicationClient, serverConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PeerEurekaNode 方法 </p><ol><li>创建远程通讯客户端replicationClient 用户与此节点间通讯，数据同步等工作</li><li>获取要创建的远程节点的host</li><li>创建一个表示远程节点实例 PeerEurekaNode</li></ol></blockquote><blockquote><p>PeerEurekaNode 表示一个与当前节点对等的远程节点，当前节点与远程节点的数据同步工作都是在此实例中完成的。</p></blockquote><h4 id="集群节点数据同步"><a href="#集群节点数据同步" class="headerlink" title="集群节点数据同步"></a>集群节点数据同步</h4><blockquote><p>在上面节点发现中知道eureka是通过PeerEurekaNode表示远程对等接点，并将远程通讯客户端replicationClient传入到PeerEurekaNode中，接下来通过查看PeerEurekaNode源码来看eureka集群节点间都有那些数据需要同步以及通讯内容</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* For testing */</span> PeerEurekaNode(PeerAwareInstanceRegistry registry, String targetHost, String serviceUrl,</span><br><span class="line">                                 HttpReplicationClient replicationClient, EurekaServerConfig config,</span><br><span class="line">                                 <span class="keyword">int</span> batchSize, <span class="keyword">long</span> maxBatchingDelayMs,</span><br><span class="line">                                 <span class="keyword">long</span> retrySleepTimeMs, <span class="keyword">long</span> serverUnavailableSleepTimeMs) &#123;</span><br><span class="line">    String batcherName = getBatcherName();</span><br><span class="line">    <span class="comment">//任务处理器</span></span><br><span class="line">    ReplicationTaskProcessor taskProcessor = <span class="keyword">new</span> ReplicationTaskProcessor(targetHost, replicationClient);</span><br><span class="line">    <span class="comment">//创建一个批量执行的任务调度器</span></span><br><span class="line">    <span class="keyword">this</span>.batchingDispatcher = TaskDispatchers.createBatchingTaskDispatcher(</span><br><span class="line">            batcherName,</span><br><span class="line">            config.getMaxElementsInPeerReplicationPool(),</span><br><span class="line">            batchSize,</span><br><span class="line">            config.getMaxThreadsForPeerReplication(),</span><br><span class="line">            maxBatchingDelayMs,</span><br><span class="line">            serverUnavailableSleepTimeMs,</span><br><span class="line">            retrySleepTimeMs,</span><br><span class="line">            taskProcessor</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//创建一个单任务调度器</span></span><br><span class="line">    <span class="keyword">this</span>.nonBatchingDispatcher = TaskDispatchers.createNonBatchingTaskDispatcher(</span><br><span class="line">            targetHost,</span><br><span class="line">            config.getMaxElementsInStatusReplicationPool(),</span><br><span class="line">            config.getMaxThreadsForStatusReplication(),</span><br><span class="line">            maxBatchingDelayMs,</span><br><span class="line">            serverUnavailableSleepTimeMs,</span><br><span class="line">            retrySleepTimeMs,</span><br><span class="line">            taskProcessor</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PeerEurekaNode 完成以下事件</p><ol><li>创建数据同步的任务处理器ReplicationTaskProcessor</li><li>创建批处理任务调度器</li><li>创建单任务处理调度器</li></ol></blockquote><blockquote><p><strong>说明:</strong>  eureka将节点间的数据同步工作包装成一个个细微的任务ReplicationTask ，每一个数据操作代表一个任务，将任务发送给任务调度器TaskDispatcher去异步处理。</p></blockquote><blockquote><p>下来查看PeerEurekaNode都可以创建那些同步任务</p><ul><li>register</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当eureka server注册新服务时，同时创建一个定时任务将新服务同步到集群其它节点</span></span><br><span class="line"><span class="comment"> * Sends the registration information of &#123;<span class="doctag">@link</span> InstanceInfo&#125; receiving by</span></span><br><span class="line"><span class="comment"> * this node to the peer node represented by this class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> info</span></span><br><span class="line"><span class="comment"> *            the instance information &#123;<span class="doctag">@link</span> InstanceInfo&#125; of any instance</span></span><br><span class="line"><span class="comment"> *            that is send to this instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info);</span><br><span class="line">    <span class="comment">//任务调度器中添加一个请求类型为注册register新服务的同步任务</span></span><br><span class="line">    batchingDispatcher.process(</span><br><span class="line">            taskId(<span class="string">"register"</span>, info),</span><br><span class="line">            <span class="keyword">new</span> InstanceReplicationTask(targetHost, Action.Register, info, <span class="keyword">null</span>, <span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> replicationClient.register(info);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            expiryTime</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注册同步任务，当有服务注册到当前节点时，通过注册同步任务将服务信息同步到集群远程节点</p></blockquote><ul><li>cancel</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">(<span class="keyword">final</span> String appName, <span class="keyword">final</span> String id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> expiryTime = System.currentTimeMillis() + maxProcessingDelayMs;</span><br><span class="line">     <span class="comment">//任务调度器中添加一个请求类型为取消cancel服务的同步任务</span></span><br><span class="line">     batchingDispatcher.process(</span><br><span class="line">             taskId(<span class="string">"cancel"</span>, appName, id),</span><br><span class="line">             <span class="keyword">new</span> InstanceReplicationTask(targetHost, Action.Cancel, appName, id) &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                     <span class="keyword">return</span> replicationClient.cancel(appName, id);</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleFailure</span><span class="params">(<span class="keyword">int</span> statusCode, Object responseEntity)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                     <span class="keyword">super</span>.handleFailure(statusCode, responseEntity);</span><br><span class="line">                     <span class="keyword">if</span> (statusCode == <span class="number">404</span>) &#123;</span><br><span class="line">                         logger.warn(<span class="string">"&#123;&#125;: missing entry."</span>, getTaskName());</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;,</span><br><span class="line">             expiryTime</span><br><span class="line">     );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>取消服务注册任务，当前节点有服务取消注册，将信息同步到集群远程节点</p><ul><li>heartbeat</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public void heartbeat(final String appName, final String id,</span><br><span class="line">                      final InstanceInfo info, final InstanceStatus overriddenStatus,</span><br><span class="line">                      boolean primeConnection) throws Throwable &#123;</span><br><span class="line">    //当第一次连接时直接发送心跳到远端</span><br><span class="line">    if (primeConnection) &#123;</span><br><span class="line">        // We do not care about the result for priming request.</span><br><span class="line">        replicationClient.sendHeartBeat(appName, id, info, overriddenStatus);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //心跳同步任务</span><br><span class="line">    ReplicationTask replicationTask = new InstanceReplicationTask(targetHost, Action.Heartbeat, info, overriddenStatus, false) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public EurekaHttpResponse&lt;InstanceInfo&gt; execute() throws Throwable &#123;</span><br><span class="line">            return replicationClient.sendHeartBeat(appName, id, info, overriddenStatus);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleFailure(int statusCode, Object responseEntity) throws Throwable &#123;</span><br><span class="line">            super.handleFailure(statusCode, responseEntity);</span><br><span class="line">            if (statusCode == 404) &#123;</span><br><span class="line">                logger.warn(&quot;&#123;&#125;: missing entry.&quot;, getTaskName());</span><br><span class="line">                if (info != null) &#123;</span><br><span class="line">                    logger.warn(&quot;&#123;&#125;: cannot find instance id &#123;&#125; and hence replicating the instance with status &#123;&#125;&quot;,</span><br><span class="line">                            getTaskName(), info.getId(), info.getStatus());</span><br><span class="line">                    register(info);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (config.shouldSyncWhenTimestampDiffers()) &#123;</span><br><span class="line">                InstanceInfo peerInstanceInfo = (InstanceInfo) responseEntity;</span><br><span class="line">                if (peerInstanceInfo != null) &#123;</span><br><span class="line">                    syncInstancesIfTimestampDiffers(appName, id, info, peerInstanceInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    long expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info);</span><br><span class="line">    //任务调度器中添加一个请求类型为heartbeat服务的同步任务</span><br><span class="line">    batchingDispatcher.process(taskId(&quot;heartbeat&quot;, info), replicationTask, expiryTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>心跳同步任务，当前节点有服务发送心跳续租，将信息同步到集群远程节点</p><ul><li>StatusUpdate </li><li>DeleteStatusOverride</li></ul></blockquote><h4 id="集群节点数据同步任务处理"><a href="#集群节点数据同步任务处理" class="headerlink" title="集群节点数据同步任务处理"></a>集群节点数据同步任务处理</h4><blockquote><p>在PeerEurekaNode的构造函数中可以看到同步任务处理由ReplicationTaskProcessor完成，下面看此类源码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 单个处理ReplicationTask任务</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ProcessingResult <span class="title">process</span><span class="params">(ReplicationTask task)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//调用任务execute方法，完成任务的执行</span></span><br><span class="line">           EurekaHttpResponse&lt;?&gt; httpResponse = task.execute();</span><br><span class="line">           <span class="keyword">int</span> statusCode = httpResponse.getStatusCode();</span><br><span class="line">           <span class="comment">//判断任务返回结果</span></span><br><span class="line">           Object entity = httpResponse.getEntity();</span><br><span class="line">           <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">               logger.debug(<span class="string">"Replication task &#123;&#125; completed with status &#123;&#125;, (includes entity &#123;&#125;)"</span>, task.getTaskName(), statusCode, entity != <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (isSuccess(statusCode)) &#123;</span><br><span class="line">               task.handleSuccess();</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusCode == <span class="number">503</span>) &#123;</span><br><span class="line">               logger.debug(<span class="string">"Server busy (503) reply for task &#123;&#125;"</span>, task.getTaskName());</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.Congestion;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               task.handleFailure(statusCode, entity);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.PermanentError;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           <span class="keyword">if</span> (isNetworkConnectException(e)) &#123;</span><br><span class="line">               logNetworkErrorSample(task, e);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.TransientError;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               logger.error(peerId + <span class="string">": "</span> + task.getTaskName() + <span class="string">"Not re-trying this exception because it does not seem to be a network exception"</span>, e);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.PermanentError;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ProcessingResult.Success;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>单任务处理 </p><ol><li>调用任务task的execute完成远程数据同步</li><li>分析远程返回结果</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 批量处理ReplicationTask任务</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> tasks</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ProcessingResult <span class="title">process</span><span class="params">(List&lt;ReplicationTask&gt; tasks)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//根据task集合创建ReplicationList</span></span><br><span class="line">       ReplicationList list = createReplicationListOf(tasks);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//调用批量同步接口 将同步集合发送到远端节点同步数据</span></span><br><span class="line">           EurekaHttpResponse&lt;ReplicationListResponse&gt; response = replicationClient.submitBatchUpdates(list);</span><br><span class="line">           <span class="comment">//判断同步返回结果</span></span><br><span class="line">           <span class="keyword">int</span> statusCode = response.getStatusCode();</span><br><span class="line">           <span class="keyword">if</span> (!isSuccess(statusCode)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (statusCode == <span class="number">503</span>) &#123;</span><br><span class="line">                   logger.warn(<span class="string">"Server busy (503) HTTP status code received from the peer &#123;&#125;; rescheduling tasks after delay"</span>, peerId);</span><br><span class="line">                   <span class="keyword">return</span> ProcessingResult.Congestion;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// Unexpected error returned from the server. This should ideally never happen.</span></span><br><span class="line">                   logger.error(<span class="string">"Batch update failure with HTTP status code &#123;&#125;; discarding &#123;&#125; replication tasks"</span>, statusCode, tasks.size());</span><br><span class="line">                   <span class="keyword">return</span> ProcessingResult.PermanentError;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               handleBatchResponse(tasks, response.getEntity().getResponseList());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           <span class="keyword">if</span> (isNetworkConnectException(e)) &#123;</span><br><span class="line">               logNetworkErrorSample(<span class="keyword">null</span>, e);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.TransientError;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               logger.error(<span class="string">"Not re-trying this exception because it does not seem to be a network exception"</span>, e);</span><br><span class="line">               <span class="keyword">return</span> ProcessingResult.PermanentError;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ProcessingResult.Success;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>批处理任务，将一组任务一次性发送到远程进行处理</p><ol><li>根据task集合创建ReplicationList</li><li>调用批量同步接口将同步集合发送到远端节点同步数据 即调用rest API /{version}/peerreplication</li><li>分析远程返回结果</li></ol></blockquote><hr><blockquote><p><strong>eureka 服务端 集群节点发现，数据同步功能主要是由PeerEurekaNodes与PeerEurekaNode类实现,通过源码的跟踪可以清晰看出集群实现的逻辑，方便在实际应用中对问题的定位</strong></p></blockquote>]]></content>
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/08/23/hello-world/"/>
      <url>/2018/08/23/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
